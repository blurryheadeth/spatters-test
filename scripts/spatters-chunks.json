{
  "chunks": [
    "let canvasWidth = 1200;\r\nlet canvasHeight = 600;\r\nlet seedpoints = [];\r\nlet matchingPixels = [];\r\nlet borderPixels = [];\r\nlet previousLines = [];\r\nlet maxCurvature = 100;\r\nlet canvasArray = [];\r\nlet shapeArray = [];\r\nlet weightsArray = [];\r\nlet linesToRightArray = [];\r\nlet blankShapeCanvasArray = [];\r\nlet blankShapeShapeArray = [];\r\nlet blankShapeWeightsArray = [];\r\nlet blankShapeLinesToRightArrray = [];\r\nlet blankShapeMatchingPixels = [];\r\nlet blankShapeMaxX = {};\r\nlet blankShapeMinX = {};\r\nlet blankShapeBorderPixels = [];\r\nlet blankShapeBackgroundArray = [];\r\nlet originalPalette = [\"#fc1a4a\", \"#75d494\", \"#2587c3\", \"#f2c945\", \"#000000\", \"#FFFFFF\"];\r\nlet showingHistory = false;\r\nlet canvasHistory = [];\r\nlet historicalIndex = 0;\r\n\r\nlet variablesGenerated = false;\r\nlet setupVariables = {\r\n    aspectRatio: 0.5,\r\n    canvasWidth: 1200,\r\n    baseRadius: 0,\r\n    numSeedpoints: 5,\r\n    seedpoints: [],\r\n    gradientType: 0,\r\n    dividerCount: 0,\r\n    circleCount: 0,\r\n    lineCount: 0,\r\n    circles: [],\r\n    lines: [],\r\n    colors: [],\r\n    selectedcolors: [],\r\n    dividers: [],\r\n    mutation: \"\",\r\n    initialVariables: {},\r\n    changeHistory: []\r\n};\r\n\r\nfunction generate (mintSeed, mutationArray, palette = []) {\r\n    pixelDensity(1);\r\n    if (palette.length > 0) {\r\n        originalPalette = palette;\r\n    }\r\n\r\n    mutate(mintSeed);\r\n    variablesGenerated = true;\r\n    canvasHistory.push(structuredClone(pixels));\r\n\r\n    for (let i=0; i<mutationArray.length; i++) {\r\n        seedpoints = [];\r\n        matchingPixels = [];\r\n        borderPixels = [];\r\n        previousLines = [];\r\n        maxCurvature = 100;\r\n        canvasArray = [];\r\n        shapeArray = [];\r\n        weightsArray = [];\r\n        linesToRightArray = [];\r\n\r\n        setupVariables.mutation = mutationArray[i][1];\r\n        mutate(mutationArray[i][0])\r\n        canvasHistory.push(structuredClone(pixels));\r\n    };\r\n    \r\n    updatePixels();\r\n\r\n    var el = document.getElementsByTagName(\"canvas\")[0];\r\n    el.addEventListener(\"touchstart\", mouseClicked, false);\r\n}\r\n\r\nfunction mouseClicked() {\r\n    for (let i = 0; i <pixels.length; i++) {\r\n        pixels[i] = canvasHistory[historicalIndex][i];\r\n    }\r\n\r\n    updatePixels();\r\n\r\n    historicalIndex++;\r\n    if(historicalIndex == (canvasHistory.length)) { historicalIndex = 0;};\r\n}\r\n\r\nfunction mutate(seed) {\r\n    // Set the seed based on the current date and time\r\n    randomSeed(seed);\r\n    console.log(seed);\r\n\r\n    let initalVariablesObj = {};\r\n    if(variablesGenerated) {\r\n        initalVariablesObj = setupVariablesCopy = structuredClone(setupVariables);\r\n    }\r\n\r\n    \r\n    if(variablesGenerated && setupVariables.mutation == \"undoMutation\") {\r\n        setupVariables = reconstructOriginal(setupVariables, setupVariables.changeHistory[setupVariables.changeHistory.length-1]);\r\n    }\r\n\r\n    if(variablesGenerated && setupVariables.mutation == \"returnToPreviousVersion\") {\r\n        let stepsBack = ceil(random(setupVariables.changeHistory.length));\r\n\r\n        for(let i = 1; i<=stepsBack; i++) {\r\n            setupVariables = reconstructOriginal(setupVariables, setupVariables.changeHistory[setupVariables.changeHistory.length-i]);\r\n        }\r\n    }\r\n\r\n    if(!variablesGenerated){\r\n        let aspectRatioRoll = floor(random(11));\r\n        let possibleRatios = [0.5,9/16,16/9,0.75,1.25,1,3/2,2/3,2,9/21,21/9];\r\n        setupVariables.aspectRatio = possibleRatios[aspectRatioRoll];\r\n    } else if (setupVariables.mutation == \"aspectRatioChange\") {\r\n        let possibleRatios = [0.5,9/16,16/9,0.75,1.25,1,3/2,2/3,2,9/21,21/9];\r\n        possibleRatios = possibleRatios.filter(item => item !== setupVariables.aspectRatio);\r\n        let aspectRatioRoll = floor(random(10));\r\n        setupVariables.aspectRatio = possibleRatios[aspectRatioRoll];\r\n    }\r\n\r\n    canvasWidth = setupVariables.canvasWidth;\r\n    canvasHeight = canvasWidth * setupVariables.aspectRatio;\r\n    maxCurvature = canvasWidth / 12;\r\n    \r\n    createCanvas(canvasWidth, canvasHeight);\r\n    background(255, 255, 255);\r\n\r\n    let maxBaseRadius = 20/900;\r\n    let minBaseRadius = 5/900;\r\n    let meanBaseRadius = 12/900;\r\n\r\n    if(!variablesGenerated){\r\n        setupVariables.baseRadius = constrain(floor(randomGaussian(meanBaseRadius, sqrt(10))), minBaseRadius, maxBaseRadius);\r\n    } else if (setupVariables.mutation == \"baseRadiusIncrease\" || setupVariables.mutation == \"baseRadiusDecrease\") {\r\n        let startingRadius = setupVariables.baseRadius;\r\n        let changeRange = 0;\r\n\r\n        if (setupVariables.mutation == \"baseRadiusIncrease\") {\r\n            changeRange = max(maxBaseRadius - startingRadius,0);\r\n            newMeanBaseRadius = startingRadius + changeRange * (meanBaseRadius - minBaseRadius) / (maxBaseRadius - minBaseRadius);\r\n            setupVariables.baseRadius = constrain(floor(randomGaussian(newMeanBaseRadius, sqrt(10))), startingRadius, startingRadius + changeRange);\r\n        } else {\r\n            changeRange = max(startingRadius - minBaseRadius,0);\r\n            newMeanBaseRadius = minBaseRadius + changeRange * (meanBaseRadius - minBaseRadius) / (maxBaseRadius - minBaseRadius);\r\n            setupVariables.baseRadius = constrain(floor(randomGaussian(newMeanBaseRadius, sqrt(10))), minBaseRadius, minBaseRadius + changeRange);\r\n        }   \r\n    }\r\n\r\n    let baseRadius = setupVariables.baseRadius * min(canvasWidth,canvasHeight);\r\n\r\n    if(!variablesGenerated){\r\n        let gradientRoll = random(9);\r\n        setupVariables.gradientType = 0;\r\n        if (gradientRoll < 3) {\r\n            setupVariables.gradientType = 1;\r\n        } else if (gradientRoll < 6) {\r\n            setupVariables.gradientType = 2;          \r\n        }\r\n    } else if (setupVariables.mutation == \"gradientTypeChange\") {\r\n        let possibleGradients = [0,1,2];\r\n        possibleGradients = possibleGradients.filter(item => item !== setupVariables.gradientType);\r\n        let gradientRoll = random(6);\r\n        if (gradientRoll < 3) {\r\n            setupVariables.gradientType = possibleGradients[0];\r\n        } else {\r\n            setupVariables.gradientType = possibleGradients[1];\r\n        }\r\n    }\r\n\r\n    let gradientType = setupVariables.gradientType;\r\n\r\n    let chance4 = 0.6529;\r\n    let chance0 = 6;\r\n    let chance3 = 20;\r\n    let chance1 = 50;\r\n    let chance2 = 100;\r\n    let missingDividers = 0;\r\n    let chosenDividerIndex = -1;\r\n    \r\n    if(!variablesGenerated){\r\n        let dividerRoll = random(100);\r\n        setupVariables.dividerCount = 2;\r\n        if (dividerRoll < chance4) {\r\n            setupVariables.dividerCount = 4;\r\n        } else if (dividerRoll < chance0) {\r\n            setupVariables.dividerCount = 0;\r\n        } else if (dividerRoll < chance3) {\r\n            setupVariables.dividerCount = 3;\r\n        } else if (dividerRoll < chance1) {\r\n            setupVariables.dividerCount = 1;\r\n        }\r\n    } else if (setupVariables.mutation == \"dividerCountChange\") {\r\n        let probabilities = [\r\n            (chance0-chance4)/100,\r\n            (chance1-chance3)/100,\r\n            (chance2-chance1)/100,\r\n            (chance3-chance0)/100,\r\n            chance4/100\r\n        ];\r\n        let probabilityOrder = [4,0,3,1,2];\r\n\r\n        let oldCount = setupVariables.dividerCount; \r\n        probabilityOrder = probabilityOrder.filter(item => item !== oldCount);\r\n\r\n        let dividerRoll = random(100);\r\n        setupVariables.dividerCount = probabilityOrder[probabilityOrder.length-1];\r\n        if (dividerRoll < 100*probabilities[probabilityOrder[0]]/(1-probabilities[oldCount])) {\r\n            setupVariables.dividerCount = probabilityOrder[0];\r\n        } else if (dividerRoll < 100*probabilities[probabilityOrder[1]]/(1-probabilities[oldCount])) {\r\n            setupVariables.dividerCount = probabilityOrder[1];\r\n        } else if (dividerRoll < 100*probabilities[probabilityOrder[2]]/(1-probabilities[oldCount])) {\r\n            setupVariables.dividerCount = probabilityOrder[2];\r\n        }\r\n\r\n        if (setupVariables.dividerCount<oldCount) {\r\n            let difference = oldCount - setupVariables.dividerCount;\r\n\r\n            let dividerRemovalRoll = floor(random(setupVariables.dividers.length));\r\n            let colorRemovalRoll = floor(random(setupVariables.dividers.length));\r\n\r\n            setupVariables.dividers.splice(dividerRemovalRoll,1);\r\n            setupVariables.selectedcolors.splice(colorRemovalRoll,1);\r\n        } else if (setupVariables.dividerCount>oldCount) {\r\n            let difference = setupVariables.dividerCount - oldCount;\r\n\r\n            missingDividers = difference;\r\n        }\r\n    } else if (setupVariables.mutation == \"dividerMove\" || setupVariables.mutation == \"dividerRotate\") { \r\n        chosenDividerIndex = floor(random(setupVariables.dividers.length));\r\n    }\r\n\r\n    let dividerCount = setupVariables.dividerCount;\r\n    \r\n\r\n    chance0 = 3;\r\n    chance3 = 10;\r\n    chance1 = 40;\r\n    chance2 = 100;\r\n    let missingCircles = 0;\r\n\r\n    if(!variablesGenerated){\r\n        let circleRoll = random(100);\r\n        setupVariables.circleCount = 2;\r\n        if (circleRoll < chance0) {\r\n            setupVariables.circleCount = 0;\r\n        } else if (circleRoll < chance3) {\r\n            setupVariables.circleCount = 3;\r\n        } else if (circleRoll < chance1) {\r\n            setupVariables.circleCount = 1;\r\n        }\r\n    } else if (setupVariables.mutation == \"circleCountChange\") {\r\n        let probabilities = [\r\n            chance0/100,\r\n            (chance1-chance3)/100,\r\n            (chance2-chance1)/100,\r\n            (chance3-chance0)/100,\r\n        ];\r\n        let probabilityOrder = [0,3,1,2];\r\n\r\n        let oldCount = setupVariables.circleCount; \r\n        probabilityOrder = probabilityOrder.filter(item => item !== oldCount);\r\n\r\n        let circleRoll = random(100);\r\n        setupVariables.circleCount = probabilityOrder[probabilityOrder.length-1];\r\n        if (circleRoll < 100*probabilities[probabilityOrder[0]]/(1-probabilities[oldCount])) {\r\n            setupVariables.circleCount = probabilityOrder[0];\r\n        } else if (circleRoll < 100*probabilities[probabilityOrder[1]]/(1-probabilities[oldCount])) {\r\n            setupVariables.circleCount = probabilityOrder[1];\r\n        }\r\n\r\n        if (setupVariables.circleCount<oldCount) {\r\n            let difference = oldCount - setupVariables.circleCount;\r\n            \r\n            for (let i=0; i<difference; i++) {\r\n                let circleRemovalRoll = floor(random(setupVariables.circles.length));\r\n                setupVariables.circles.splice(circleRemovalRoll,1);\r\n            }\r\n        } else if (setupVariables.circleCount>oldCount) {\r\n            let difference = setupVariables.circleCount - oldCount;\r\n\r\n            missingCircles = difference;\r\n        }\r\n        \r\n    }\r\n    \r\n    let circleCount = setupVariables.circleCount;\r\n\r\n    chance0 = 40;\r\n    chance3 = 3;\r\n    chance1 = 100;\r\n    chance2 = 10;\r\n    let missingLines = 0;\r\n\r\n    if(!variablesGenerated){\r\n        let lineRoll = random(100);\r\n        setupVariables.lineCount = 1;\r\n        if (lineRoll < chance3) {\r\n            setupVariables.lineCount = 3;\r\n        } else if (lineRoll < chance2) {\r\n            setupVariables.lineCount = 2;\r\n        } else if (lineRoll < chance0) {\r\n            setupVariables.lineCount = 0;\r\n        }\r\n    } else if (setupVariables.mutation == \"lineCountChange\") {\r\n        let probabilities = [\r\n            (chance0-chance2)/100,\r\n            (chance1-chance0)/100,\r\n            (chance2-chance3)/100,\r\n            chance3/100,\r\n        ];\r\n        let probabilityOrder = [3,2,0,1];\r\n\r\n        let oldCount = setupVariables.lineCount; \r\n        probabilityOrder = probabilityOrder.filter(item => item !== oldCount);\r\n\r\n        let lineRoll = random(100);\r\n        setupVariables.lineCount = probabilityOrder[probabilityOrder.length-1];\r\n        if (lineRoll < 100*probabilities[probabilityOrder[0]]/(1-probabilities[oldCount])) {\r\n            setupVariables.lineCount = probabilityOrder[0];\r\n        } else if (lineRoll < 100*probabilities[probabilityOrder[1]]/(1-probabilities[oldCount])) {\r\n            setupVariables.lineCount = probabilityOrder[1];\r\n        }\r\n\r\n        if (setupVariables.lineCount<oldCount) {\r\n            let difference = oldCount - setupVariables.lineCount;\r\n\r\n            for (let i=0; i<difference; i++){\r\n                let lineRemovalRoll = floor(random(setupVariables.lines.length));\r\n                setupVariables.lines.splice(lineRemovalRoll,1);\r\n            }\r\n        } else if (setupVariables.lineCount>oldCount) {\r\n            let difference = setupVariables.lineCount - oldCount;\r\n\r\n            missingLines = difference;\r\n        }\r\n        \r\n    }\r\n\r\n    let lineCount = setupVariables.lineCount;\r\n    let stdevParam = 1.96;\r\n\r\n    if(!variablesGenerated){\r\n        for (let i=0; i<circleCount;i++) {\r\n            setupVariables.circles.push({\r\n                radius: max(0.1,min(0.9,randomGaussian(0.6, 0.6/stdevParam))),\r\n            });\r\n        }\r\n    } else {\r\n        if (missingCircles > 0) {\r\n            for (let i=0; i<missingCircles;i++) {\r\n                setupVariables.circles.push({\r\n                    radius: max(0.1,min(0.9,randomGaussian(0.6, 0.6/stdevParam))),\r\n                });\r\n            }\r\n        }\r\n        if (setupVariables.mutation == \"circleSizeIncrease\"){\r\n            let chosenIndex = floor(random(0,setupVariables.circles.length));\r\n            setupVariables.circles[chosenIndex].radius = \r\n            min(\r\n                1,\r\n                max(\r\n                    setupVariables.circles[chosenIndex].radius,\r\n                    min(0.9,randomGaussian(0.6, 0.6/stdevParam))\r\n                )+max(0.05,min(0.1,randomGaussian(0.05, 0.05/stdevParam)))\r\n            );\r\n        }\r\n        if (setupVariables.mutation == \"circleSizeDecrease\"){\r\n            let chosenIndex = floor(random(0,setupVariables.circles.length));\r\n            setupVariables.circles[chosenIndex].radius = \r\n            max(\r\n                0,\r\n                min(\r\n                    setupVariables.circles[chosenIndex].radius,\r\n                    max(0.1,randomGaussian(0.6, 0.6/stdevParam))\r\n                )-max(0.05,min(0.1,randomGaussian(0.05, 0.05/stdevParam)))\r\n            );\r\n        }\r\n    }\r\n    \r\n\r\n    let circles = setupVariables.circles;\r\n    \r\n\r\n    if(!variablesGenerated){\r\n        for (let i=0; i<lineCount;i++) {\r\n            setupVariables.lines.push({\r\n                // Minimum line should be 2x2 square, equivalent to circle with radius of 1\r\n                ancho: floor(random(2, baseRadius)),\r\n                angle: random(0, PI),\r\n                // Maybe with a Poisson distribution centered around 30%\r\n                length: max(0.1,min(0.9,randomGaussian(0.6, 0.6/stdevParam))),\r\n            });\r\n        }\r\n    } else {\r\n        if (missingLines > 0) {\r\n            for (let i=0; i<missingLines;i++) {\r\n                setupVariables.lines.push({\r\n                    // Minimum line should be 2x2 square, equivalent to circle with radius of 1\r\n                    ancho: floor(random(2, baseRadius)),\r\n                    angle: random(0, PI),\r\n                    // Maybe with a Poisson distribution centered around 30%\r\n                    length: max(0.1,min(0.9,randomGaussian(0.6, 0.6/stdevParam))),\r\n                });\r\n            }\r\n        }\r\n        if (setupVariables.mutation == \"lineWidthIncrease\"){\r\n            let chosenIndex = floor(random(0,setupVariables.lines.length));\r\n            setupVariables.lines[chosenIndex].ancho = floor(random(setupVariables.lines[chosenIndex].ancho, baseRadius));\r\n        }\r\n        if (setupVariables.mutation == \"lineWidthDecrease\"){\r\n            let chosenIndex = floor(random(0,setupVariables.lines.length));\r\n            setupVariables.lines[chosenIndex].ancho = floor(random(1, setupVariables.lines[chosenIndex].ancho));\r\n        }\r\n        if (setupVariables.mutation == \"lineAngleChange\"){\r\n            let chosenIndex = floor(random(0,setupVariables.lines.length));\r\n            let oldAngle = setupVariables.lines[chosenIndex].angle\r\n            let newAngle = random(0, PI);\r\n            // To make sure we at least try to show a meaningful rotation\r\n            while (abs((newAngle-oldAngle)/PI)<0.1) {\r\n                newAngle = random(0, PI);\r\n            }\r\n            setupVariables.lines[chosenIndex].angle = newAngle;\r\n        }\r\n        if (setupVariables.mutation == \"lineLengthIncrease\"){\r\n            let chosenIndex = floor(random(0,setupVariables.lines.length));\r\n            setupVariables.lines[chosenIndex].length = \r\n            min(\r\n                1,\r\n                max(\r\n                    setupVariables.lines[chosenIndex].length,\r\n                    min(0.9,randomGaussian(0.6, 0.6/stdevParam))\r\n                )+max(0.05,min(0.1,randomGaussian(0.05, 0.05/stdevParam)))\r\n            );\r\n        }\r\n        if (setupVariables.mutation == \"lineLengthDecrease\"){\r\n            let chosenIndex = floor(random(0,setupVariables.lines.length));\r\n            setupVariables.lines[chosenIndex].length = \r\n            max(\r\n                0,\r\n                min(\r\n                    setupVariables.lines[chosenIndex].length,\r\n                    max(0.1,randomGaussian(0.6, 0.6/stdevParam))\r\n                )-max(0.05,min(0.1,randomGaussian(0.05, 0.05/stdevParam)))\r\n            );\r\n        }\r\n    }\r\n\r\n    let lines = setupVariables.lines;\r\n\r\n    // Generate 3 to 20 seedpoints based on an approximation of a Poisson distribution\r\n    generateSeedpoints(baseRadius);\r\n\r\n    if(variablesGenerated && setupVariables.mutation.includes(\"shape\")) {\r\n        switch (setupVariables.mutation) {\r\n            case \"shapeExpand\": {\r\n                let seedpoints = findConvexHull(setupVariables.seedpoints);\r\n                let centralPoint = findCentralPoint(seedpoints);\r\n                let minDist = Infinity;\r\n\r\n                for(let i=0; i<seedpoints.length;i++) {\r\n                    let minDistance = findMinDistanceToBoundary(\r\n                        seedpoints[i].x, seedpoints[i].y,\r\n                        centralPoint.x, centralPoint.y,\r\n                        canvasWidth, canvasHeight\r\n                    );\r\n                    minDist = max(0,min(minDistance-seedpoints[i].radiusIncrease*baseRadius, minDist));\r\n                }\r\n\r\n                let expansionDistance = random(0.1,0.9)*minDist;\r\n\r\n                for(let i=0; i<seedpoints.length;i++) {\r\n                    movePointAlongLine(\r\n                        setupVariables.seedpoints[i].x*canvasWidth,\r\n                        setupVariables.seedpoints[i].y*canvasHeight,\r\n                        centralPoint.x, centralPoint.y,\r\n                        expansionDistance, i,\r\n                        canvasWidth, canvasHeight,1\r\n                    );\r\n                }\r\n                \r\n                for(let i=0; i<setupVariables.circleCount;i++) {\r\n                    movePointAlongLine(\r\n                        setupVariables.circles[i].centerX*canvasWidth,\r\n                        setupVariables.circles[i].centerY*canvasHeight,\r\n                        centralPoint.x, centralPoint.y,\r\n                        expansionDistance, i,\r\n                        canvasWidth, canvasHeight,1,\"circle\"\r\n                    );\r\n                }\r\n\r\n                for(let i=0; i<setupVariables.lineCount;i++) {\r\n                    movePointAlongLine(\r\n                        setupVariables.lines[i].centerX*canvasWidth,\r\n                        setupVariables.lines[i].centerY*canvasHeight,\r\n                        centralPoint.x, centralPoint.y,\r\n                        expansionDistance, i,\r\n                        canvasWidth, canvasHeight,1,\"line\"\r\n                    );\r\n                }\r\n\r\n                break;\r\n            }\r\n            case \"shapeShrink\": {\r\n                let seedpointsShrink = findConvexHull(setupVariables.seedpoints);\r\n                let centralPoint = findCentralPoint(seedpointsShrink);\r\n                let maxDist = Infinity;\r\n\r\n                for(let i=0; i<seedpointsShrink.length;i++) {\r\n                    let maxDistance = dist(\r\n                        seedpointsShrink[i].x, seedpointsShrink[i].y,\r\n                        centralPoint.x, centralPoint.y\r\n                    );\r\n                    maxDist = min(maxDistance, maxDist);\r\n                }\r\n\r\n                let shrinkDistance = random(0.05,0.25)*maxDist;\r\n                for(let i=0; i<seedpointsShrink.length;i++) {\r\n                    movePointAlongLine(\r\n                        setupVariables.seedpoints[i].x*canvasWidth,\r\n                        setupVariables.seedpoints[i].y*canvasHeight,\r\n                        centralPoint.x, centralPoint.y,\r\n                        shrinkDistance, i,\r\n                        canvasWidth, canvasHeight,-1\r\n                    );\r\n                }\r\n\r\n                for(let i=0; i<setupVariables.circleCount;i++) {\r\n                    movePointAlongLine(\r\n                        setupVariables.circles[i].centerX*canvasWidth,\r\n                        setupVariables.circles[i].centerY*canvasHeight,\r\n                        centralPoint.x, centralPoint.y,\r\n                        shrinkDistance, i,\r\n                        canvasWidth, canvasHeight,-1,\"circle\"\r\n                    );\r\n                }\r\n\r\n                for(let i=0; i<setupVariables.lineCount;i++) {\r\n                    movePointAlongLine(\r\n                        setupVariables.lines[i].centerX*canvasWidth,\r\n                        setupVariables.lines[i].centerY*canvasHeight,\r\n                        centralPoint.x, centralPoint.y,\r\n                        shrinkDistance, i,\r\n                        canvasWidth, canvasHeight,-1,\"line\"\r\n                    );\r\n                }\r\n                break;\r\n            }\r\n            case \"shapeMakeWider\": {\r\n                let seedpoints = findConvexHull(setupVariables.seedpoints);\r\n                let centralX = seedpoints.reduce((acc, obj) => acc + obj.x, 0)/seedpoints.length/canvasWidth;\r\n                let minDist = Infinity;\r\n\r\n                for(let i=0; i<seedpoints.length;i++) {\r\n                    if(setupVariables.seedpoints[i].x > centralX) {\r\n                        let minDistance = 1 - setupVariables.seedpoints[i].x;\r\n                        minDist = max(0,min((minDistance*canvasWidth-setupVariables.seedpoints[i].radiusIncrease*baseRadius)/canvasWidth/(setupVariables.seedpoints[i].x - centralX), minDist));\r\n                    } else {\r\n                        let minDistance = setupVariables.seedpoints[i].x;\r\n                        minDist = max(0,min((minDistance*canvasWidth-setupVariables.seedpoints[i].radiusIncrease*baseRadius)/canvasWidth/(centralX - setupVariables.seedpoints[i].x), minDist));\r\n                    }\r\n                }\r\n\r\n                let expansionDistance = random(0.1,0.9)*minDist;\r\n\r\n                for(let i=0; i<seedpoints.length;i++) {\r\n                    if(setupVariables.seedpoints[i].x > centralX) {\r\n                        setupVariables.seedpoints[i].x = (setupVariables.seedpoints[i].x - centralX)*(1 + expansionDistance)+centralX;\r\n                    } else {\r\n                        setupVariables.seedpoints[i].x = centralX - (centralX - setupVariables.seedpoints[i].x)*(1 + expansionDistance);\r\n                    }\r\n                }\r\n                \r\n                for(let i=0; i<setupVariables.circleCount;i++) {\r\n                    if(setupVariables.circles[i].centerX > centralX) {\r\n                        setupVariable",
    "s.circles[i].centerX = (setupVariables.circles[i].centerX - centralX)*(1 + expansionDistance)+centralX;\r\n                    } else {\r\n                        setupVariables.circles[i].centerX = centralX - (centralX - setupVariables.circles[i].centerX)*(1 + expansionDistance);\r\n                    }\r\n                }\r\n\r\n                for(let i=0; i<setupVariables.lineCount;i++) {\r\n                    if(setupVariables.lines[i].centerX > centralX) {\r\n                        setupVariables.lines[i].centerX = (setupVariables.lines[i].centerX - centralX)*(1 + expansionDistance)+centralX;\r\n                    } else {\r\n                        setupVariables.lines[i].centerX = centralX - (centralX - setupVariables.lines[i].centerX)*(1 + expansionDistance);\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case \"shapeMakeNarrower\":{\r\n                let seedpoints = findConvexHull(setupVariables.seedpoints);\r\n                let centralX = seedpoints.reduce((acc, obj) => acc + obj.x, 0)/seedpoints.length/canvasWidth;\r\n                let minDist = Infinity;\r\n\r\n                let shrinkFactor = random(0.75,0.95);\r\n\r\n                for(let i=0; i<seedpoints.length;i++) {\r\n                    if(setupVariables.seedpoints[i].x  > centralX) {\r\n                        setupVariables.seedpoints[i].x = (setupVariables.seedpoints[i].x - centralX)*shrinkFactor+centralX;\r\n                    } else {\r\n                        setupVariables.seedpoints[i].x = centralX - (centralX - setupVariables.seedpoints[i].x)*shrinkFactor;\r\n                    }\r\n                }\r\n                \r\n                for(let i=0; i<setupVariables.circleCount;i++) {\r\n                    if(setupVariables.circles[i].centerX > centralX) {\r\n                        setupVariables.circles[i].centerX = (setupVariables.circles[i].centerX - centralX)*shrinkFactor+centralX;\r\n                    } else {\r\n                        setupVariables.circles[i].centerX =  centralX - (centralX - setupVariables.circles[i].centerX)*shrinkFactor;\r\n                    }\r\n                }\r\n\r\n                for(let i=0; i<setupVariables.lineCount;i++) {\r\n                    if(setupVariables.lines[i].centerX > centralX) {\r\n                        setupVariables.lines[i].centerX = (setupVariables.lines[i].centerX - centralX)*shrinkFactor+centralX;\r\n                    } else {\r\n                        setupVariables.lines[i].centerX = centralX - (centralX - setupVariables.lines[i].centerX)*shrinkFactor;\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case \"shapeMakeHigher\":{\r\n                let seedpoints = findConvexHull(setupVariables.seedpoints);\r\n                let centralY = seedpoints.reduce((acc, obj) => acc + obj.y, 0)/seedpoints.length/canvasHeight;\r\n                let minDist = Infinity;\r\n\r\n                for(let i=0; i<seedpoints.length;i++) {\r\n                    if(setupVariables.seedpoints[i].y > centralY) {\r\n                        let minDistance = 1 - setupVariables.seedpoints[i].y;\r\n                        minDist = max(0,min((minDistance*canvasHeight-setupVariables.seedpoints[i].radiusIncrease*baseRadius)/canvasHeight/(setupVariables.seedpoints[i].y - centralY), minDist));\r\n                    } else {\r\n                        let minDistance = setupVariables.seedpoints[i].y;\r\n                        minDist = max(0,min((minDistance*canvasHeight-setupVariables.seedpoints[i].radiusIncrease*baseRadius)/canvasHeight/(centralY - setupVariables.seedpoints[i].y), minDist));\r\n                    }\r\n                }\r\n\r\n                let expansionDistance = random(0.1,0.9)*minDist;\r\n\r\n                for(let i=0; i<seedpoints.length;i++) {\r\n                    if(setupVariables.seedpoints[i].y > centralY) {\r\n                        setupVariables.seedpoints[i].y = (setupVariables.seedpoints[i].y - centralY)*(1 + expansionDistance)+centralY;\r\n                    } else {\r\n                        setupVariables.seedpoints[i].y = centralY - (centralY - setupVariables.seedpoints[i].y)*(1 + expansionDistance);\r\n                    }\r\n                }\r\n                \r\n                for(let i=0; i<setupVariables.circleCount;i++) {\r\n                    if(setupVariables.circles[i].centerY > centralY) {\r\n                        setupVariables.circles[i].centerY = (setupVariables.circles[i].centerY - centralY)*(1 + expansionDistance)+centralY;\r\n                    } else {\r\n                        setupVariables.circles[i].centerY = centralY - (centralY - setupVariables.circles[i].centerY)*(1 + expansionDistance);\r\n                    }\r\n                }\r\n\r\n                for(let i=0; i<setupVariables.lineCount;i++) {\r\n                    if(setupVariables.lines[i].centerY > centralY) {\r\n                        setupVariables.lines[i].centerY = (setupVariables.lines[i].centerY - centralY)*(1 + expansionDistance)+centralY;\r\n                    } else {\r\n                        setupVariables.lines[i].centerY = centralY - (centralY - setupVariables.lines[i].centerY)*(1 + expansionDistance);\r\n                    }\r\n                }\r\n                break;\r\n            }\r\n            case \"shapeMakeShorter\":{\r\n                let seedpoints = findConvexHull(setupVariables.seedpoints);\r\n                let centralY = seedpoints.reduce((acc, obj) => acc + obj.y, 0)/seedpoints.length/canvasHeight;\r\n                let minDist = Infinity;\r\n\r\n                let shrinkFactor = random(0.75,0.95);\r\n\r\n                for(let i=0; i<seedpoints.length;i++) {\r\n                    if(setupVariables.seedpoints[i].y  > centralY) {\r\n                        setupVariables.seedpoints[i].y = (setupVariables.seedpoints[i].y - centralY)*shrinkFactor+centralY;\r\n                    } else {\r\n                        setupVariables.seedpoints[i].y = centralY - (centralY - setupVariables.seedpoints[i].y)*shrinkFactor;\r\n                    }\r\n                }\r\n                \r\n                for(let i=0; i<setupVariables.circleCount;i++) {\r\n                    if(setupVariables.circles[i].centerY > centralY) {\r\n                        setupVariables.circles[i].centerY = (setupVariables.circles[i].centerY - centralY)*shrinkFactor+centralY;\r\n                    } else {\r\n                        setupVariables.circles[i].centerY =  centralY - (centralY - setupVariables.circles[i].centerY)*shrinkFactor;\r\n                    }\r\n                }\r\n\r\n                for(let i=0; i<setupVariables.lineCount;i++) {\r\n                    if(setupVariables.lines[i].centerY > centralY) {\r\n                        setupVariables.lines[i].centerY = (setupVariables.lines[i].centerY - centralY)*shrinkFactor+centralY;\r\n                    } else {\r\n                        setupVariables.lines[i].centerY = centralY - (centralY - setupVariables.lines[i].centerY)*shrinkFactor;\r\n                    }\r\n                }\r\n                break;\r\n                }\r\n            case \"shapeChangeCurveCenters\":{\r\n                for(let i=0; i<setupVariables.seedpoints.length;i++) {\r\n                    setupVariables.seedpoints[i].percentageDistance = round(random(0, 1), 7);\r\n                }\r\n                break;\r\n                }\r\n            case \"shapeIncreaseConcavity\":{\r\n                for(let i=0; i<setupVariables.seedpoints.length;i++) {\r\n                    setupVariables.seedpoints[i].curvature = min(2,random(setupVariables.seedpoints[i].curvature*1.1, 1.5));\r\n                }\r\n                break;\r\n                }\r\n            case \"shapeReduceConcavity\":{\r\n                for(let i=0; i<setupVariables.seedpoints.length;i++) {\r\n                    setupVariables.seedpoints[i].curvature = max(0.375,random(0.5, setupVariables.seedpoints[i].curvature/1.1));\r\n                }\r\n                break;\r\n                }\r\n            case \"shapeChangeRadiuses\":{\r\n                // 50/50 chance to increase or decrease for each seedpoint, then use same code as for individual seedpoints\r\n                // TBD - could be refactored so code to increase or decrease individual seedpoints is a separate functions since this is now duplicated\r\n                for(let i=0; i<setupVariables.seedpoints.length;i++) {\r\n                    let bigOrSmall = random();\r\n\r\n                    if(bigOrSmall<0.5) {\r\n                        setupVariables.seedpoints[i].radiusIncrease = random(setupVariables.seedpoints[i].radiusIncrease*1.1,PI);\r\n                        //an increase might push us out of the canvas, we need to double check. A decrease never will.\r\n                        radius = baseRadius * setupVariables.seedpoints[i].radiusIncrease;\r\n                        if((setupVariables.seedpoints[i].x*canvasWidth + radius) > canvasWidth) {\r\n                            setupVariables.seedpoints[i].radiusIncrease = (canvasWidth - setupVariables.seedpoints[i].x*canvasWidth)/baseRadius;\r\n                        };\r\n                        if((setupVariables.seedpoints[i].x*canvasWidth - radius) < 0) {\r\n                            setupVariables.seedpoints[i].radiusIncrease = (setupVariables.seedpoints[i].x*canvasWidth)/baseRadius;\r\n                        };\r\n                        if((setupVariables.seedpoints[i].y*canvasHeight + radius) > canvasHeight) {\r\n                            setupVariables.seedpoints[i].radiusIncrease = (canvasHeight - setupVariables.seedpoints[i].y*canvasHeight)/baseRadius;\r\n                        };\r\n                        if((setupVariables.seedpoints[i].y*canvasHeight - radius) < 0) {\r\n                            setupVariables.seedpoints[i].radiusIncrease = (setupVariables.seedpoints[i].y*canvasHeight)/baseRadius;\r\n                        };\r\n                    } else {\r\n                        setupVariables.seedpoints[i].radiusIncrease = random(1,setupVariables.seedpoints[i].radiusIncrease/1.1);\r\n                    }\r\n                }\r\n                break;\r\n                }\r\n            case \"shapeMove\":{\r\n                let maxNegX = 1;\r\n                let maxPosX = 1;\r\n                let maxNegY = 1;\r\n                let maxPosY = 1;\r\n                for(let i=0; i<setupVariables.seedpoints.length;i++) {\r\n                    radius = baseRadius * setupVariables.seedpoints[i].radiusIncrease;\r\n                    maxNegX = min(maxNegX,(setupVariables.seedpoints[i].x*canvasWidth - radius)/canvasWidth);\r\n                    maxPosX = min(maxPosX,(canvasWidth - radius - setupVariables.seedpoints[i].x*canvasWidth)/canvasWidth);\r\n                    maxNegY = min(maxNegY,(setupVariables.seedpoints[i].y*canvasHeight - radius)/canvasHeight);\r\n                    maxPosY = min(maxPosY,(canvasHeight - radius - setupVariables.seedpoints[i].y*canvasHeight)/canvasHeight);\r\n                }\r\n\r\n                let xRange = maxNegX + maxPosX;\r\n                let xOffset = random(-maxNegX+xRange*0.1,maxPosX-xRange*0.1);\r\n                let yRange = maxNegY + maxPosY;\r\n                let yOffset = random(-maxNegY+yRange*0.1,maxPosY-yRange*0.1);\r\n\r\n                \r\n                for(let i=0; i<setupVariables.seedpoints.length;i++) {\r\n                    setupVariables.seedpoints[i].x += xOffset;\r\n                    setupVariables.seedpoints[i].y += yOffset;\r\n                }\r\n\r\n                for(let i=0; i<setupVariables.circles.length;i++) {\r\n                    setupVariables.circles[i].centerX += xOffset;\r\n                    setupVariables.circles[i].centerY += yOffset;\r\n                }\r\n\r\n                for(let i=0; i<setupVariables.lines.length;i++) {\r\n                    setupVariables.lines[i].centerX += xOffset;\r\n                    setupVariables.lines[i].centerY += yOffset;\r\n                }\r\n\r\n                for(let i=0; i<setupVariables.dividers.length;i++) {\r\n                    setupVariables.dividers[i].startPointX += xOffset;\r\n                }\r\n\r\n                break;\r\n                }\r\n        }\r\n    }\r\n\r\n    if(variablesGenerated && setupVariables.mutation == \"rotate\") {\r\n        setupVariables.seedpoints = rotateShape(setupVariables.seedpoints, baseRadius);\r\n    }\r\n\r\n    // Sort seedpoints based on their angle to the central point\r\n    let seedpoints = findConvexHull(setupVariables.seedpoints);\r\n\r\n    // Find the central point of the resulting shape\r\n    let centralPoint = findCentralPoint(seedpoints);\r\n\r\n    // Arrays to track whether the left and right edges of each seedpoint has been connected\r\n    let connectedLeftEdges = new Array(seedpoints.length).fill(false);\r\n    let connectedRightEdges = new Array(seedpoints.length).fill(false);\r\n\r\n    noStroke();\r\n    // Array of possible colors for each subsection\r\n\r\n    if(!variablesGenerated) {\r\n        setupVariables.colors = originalPalette;\r\n    } else if (setupVariables.mutation == \"paletteChangeOne\") {\r\n        let letters = '0123456789ABCDEF';\r\n        let newColor = '#';\r\n        for (let i = 0; i < 6; i++) {\r\n            newColor += letters[floor(random(16))];\r\n        }\r\n        let oldColorIndex = floor(random(setupVariables.colors.length));\r\n        let oldColor = setupVariables.colors[oldColorIndex];\r\n\r\n        let matchingSelectedColors = [];\r\n        for(let j=0; j<setupVariables.selectedcolors.length;j++) {\r\n            if(setupVariables.selectedcolors[j] == oldColor) {\r\n                matchingSelectedColors.push(j);\r\n            }\r\n        }\r\n\r\n        setupVariables.colors[oldColorIndex] = newColor;\r\n\r\n        if (matchingSelectedColors.length > 0) {\r\n            setupVariables.selectedcolors[matchingSelectedColors[floor(random(matchingSelectedColors.length))]] = newColor;\r\n        }\r\n    } else if (setupVariables.mutation == \"paletteChangeAll\") {\r\n        let selectedcolorsByIndex = [];\r\n        for(let j=0; j<setupVariables.selectedcolors.length; j++) {\r\n            selectedcolorsByIndex[j] = [];\r\n            for(let k=0; k<setupVariables.colors.length; k++) {\r\n                if(setupVariables.selectedcolors[j] == setupVariables.colors[k]) {\r\n                    selectedcolorsByIndex[j].push(k);\r\n                }\r\n            }\r\n        }\r\n\r\n        let letters = '0123456789ABCDEF';\r\n        for(let h = 0; h<setupVariables.colors.length; h++) {\r\n            let newColor = '#';\r\n            for (let i = 0; i < 6; i++) {\r\n                newColor += letters[floor(random(16))];\r\n            }\r\n            let oldColorIndex = h;\r\n            let oldColor = setupVariables.colors[oldColorIndex];\r\n            setupVariables.colors[oldColorIndex] = newColor;\r\n        }\r\n\r\n        for(let j=0; j<setupVariables.selectedcolors.length; j++) {\r\n            setupVariables.selectedcolors[j] = setupVariables.colors[selectedcolorsByIndex[j][floor(random(selectedcolorsByIndex[j].length))]];\r\n        }\r\n\r\n    } else if (setupVariables.mutation == \"paletteCombineOne\") {\r\n        let oldColorIndex = floor(random(setupVariables.colors.length));\r\n        let oldColor = setupVariables.colors[oldColorIndex];\r\n        let remainingIndices = [...Array(6).keys()];\r\n        remainingIndices.splice(oldColorIndex, 1);\r\n        let combinedColor = setupVariables.colors[remainingIndices[floor(random(remainingIndices.length))]];\r\n        let newColor = mixColors(oldColor, combinedColor);\r\n        \r\n        let matchingSelectedColors = [];\r\n        for(let j=0; j<setupVariables.selectedcolors.length;j++) {\r\n            if(setupVariables.selectedcolors[j] == oldColor) {\r\n                matchingSelectedColors.push(j);\r\n            }\r\n        }\r\n\r\n        setupVariables.colors[oldColorIndex] = newColor;\r\n\r\n        if (matchingSelectedColors.length > 0) {\r\n            setupVariables.selectedcolors[matchingSelectedColors[floor(random(matchingSelectedColors.length))]] = newColor;\r\n        }\r\n    } else if (setupVariables.mutation == \"paletteCombineAll\") {\r\n        let newColorPalette = [];\r\n        let newSelectedColors = [];\r\n        let selectedcolorsByIndex = [];\r\n        for(let j=0; j<setupVariables.selectedcolors.length; j++) {\r\n            selectedcolorsByIndex[j] = [];\r\n            for(let k=0; k<setupVariables.colors.length; k++) {\r\n                if(setupVariables.selectedcolors[j] == setupVariables.colors[k]) {\r\n                    selectedcolorsByIndex[j].push(k);\r\n                }\r\n            }\r\n        }\r\n\r\n        for(let h = 0; h<setupVariables.colors.length; h++) {\r\n            let oldColorIndex = h;\r\n            let oldColor = setupVariables.colors[oldColorIndex];\r\n            let remainingIndices = [...Array(6).keys()];\r\n            remainingIndices.splice(oldColorIndex, 1);\r\n            let combinedColor = setupVariables.colors[remainingIndices[floor(random(remainingIndices.length))]];\r\n            let newColor = mixColors(oldColor, combinedColor);\r\n\r\n            newColorPalette.push(newColor);\r\n        }\r\n\r\n        setupVariables.colors = newColorPalette;\r\n\r\n        for(let j=0; j<setupVariables.selectedcolors.length; j++) {\r\n            newSelectedColors.push(newColorPalette[selectedcolorsByIndex[j][floor(random(selectedcolorsByIndex[j].length))]]);\r\n        }\r\n\r\n        setupVariables.selectedcolors = newSelectedColors;            \r\n    } else if (setupVariables.mutation == \"paletteResetOne\") {\r\n        let oldColorIndex = floor(random(setupVariables.colors.length));\r\n        let oldColor = setupVariables.colors[oldColorIndex];\r\n\r\n        let matchingSelectedColors = [];\r\n        for(let j=0; j<setupVariables.selectedcolors.length;j++) {\r\n            if(setupVariables.selectedcolors[j] == oldColor) {\r\n                matchingSelectedColors.push(j);\r\n            }\r\n        }\r\n\r\n        let newColor = originalPalette[oldColorIndex];\r\n        setupVariables.colors[oldColorIndex] = newColor;\r\n\r\n        if (matchingSelectedColors.length > 0) {\r\n            setupVariables.selectedcolors[matchingSelectedColors[floor(random(matchingSelectedColors.length))]] = newColor;\r\n        }\r\n    } else if (setupVariables.mutation == \"paletteResetAll\") {\r\n        let selectedcolorsByIndex = [];\r\n        for(let j=0; j<setupVariables.selectedcolors.length; j++) {\r\n            selectedcolorsByIndex[j] = [];\r\n            for(let k=0; k<setupVariables.colors.length; k++) {\r\n                if(setupVariables.selectedcolors[j] == setupVariables.colors[k]) {\r\n                    selectedcolorsByIndex[j].push(k);\r\n                }\r\n            }\r\n        }\r\n\r\n        setupVariables.colors = originalPalette;\r\n\r\n        for(let j=0; j<setupVariables.selectedcolors.length; j++) {\r\n            setupVariables.selectedcolors[j] = originalPalette[selectedcolorsByIndex[j][floor(random(selectedcolorsByIndex[j].length))]];\r\n        }\r\n\r\n    } else if(setupVariables.mutation == \"paletteShuffle\") {\r\n        let shuffledArray = [...Array(setupVariables.colors.length).keys()];\r\n        for (let j = shuffledArray.length - 1; j > 0; j--) {\r\n            let k = floor(random() * (j + 1));\r\n            let temp = shuffledArray[j];\r\n            shuffledArray[j] = shuffledArray[k];\r\n            shuffledArray[k] = temp;\r\n        }\r\n\r\n        let newColorPalette = [];\r\n        let newSelectedColors = [];\r\n        let selectedcolorsByIndex = [];\r\n        for(let j=0; j<setupVariables.selectedcolors.length; j++) {\r\n            selectedcolorsByIndex[j] = [];\r\n            for(let k=0; k<setupVariables.colors.length; k++) {\r\n                if(setupVariables.selectedcolors[j] == setupVariables.colors[k]) {\r\n                    selectedcolorsByIndex[j].push(k);\r\n                }\r\n            }\r\n        }\r\n\r\n\r\n        for(let j = 0; j<shuffledArray.length; j++) {\r\n            let newColor = setupVariables.colors[shuffledArray[j]];\r\n            newColorPalette.push(newColor);\r\n        }\r\n\r\n        setupVariables.colors = newColorPalette;\r\n\r\n        for(let j=0; j<setupVariables.selectedcolors.length; j++) {\r\n            newSelectedColors.push(newColorPalette[selectedcolorsByIndex[j][floor(random(selectedcolorsByIndex[j].length))]]);\r\n        }\r\n\r\n        setupVariables.selectedcolors = newSelectedColors;\r\n    }\r\n\r\n    let colors = setupVariables.colors;\r\n\r\n    if(!variablesGenerated) {\r\n        setupVariables.selectedcolors = [colors[floor(random(colors.length))]];\r\n    }\r\n\r\n    let selectedcolors = setupVariables.selectedcolors;\r\n    fill(0,0,0);\r\n    \r\n    beginShape();\r\n    // Draw seedpoints and connect them\r\n    for (let i = 0; i < seedpoints.length; i++) {\r\n        let currentSeed = seedpoints[i];\r\n        connectedRightEdges[i] = true; // Mark the right edge as connected\r\n        let nextSeedIndex = findNextUnconnectedSeed(currentSeed, seedpoints, connectedLeftEdges, connectedRightEdges, i);\r\n    \r\n        // Draw seedpoint\r\n        //drawSemicircle(currentSeed.x, currentSeed.y, baseRadius, centralPoint);\r\n        let seedPointAngle = atan2(centralPoint.y - currentSeed.y, centralPoint.x - currentSeed.x) + PI / 2;\r\n        //Calculate the edges of the semicircle\r\n        let radius = baseRadius * currentSeed.radiusIncrease;\r\n        let startX = currentSeed.x + cos(seedPointAngle) * radius;\r\n        let startY = currentSeed.y + sin(seedPointAngle) * radius;\r\n        let endX = currentSeed.x - cos(seedPointAngle) * radius;\r\n        let endY = currentSeed.y - sin(seedPointAngle) * radius;\r\n        let midX = (startX + endX) / 2;\r\n        let midY = (startY + endY) / 2;\r\n        // Calculate the angle towards centralPoint\r\n            let controlAngle = atan2(centralPoint.y - midY, centralPoint.x - midX);\r\n        // Calculate control point position at a distance of curvature from the midpoint\r\n            let controlX = midX - cos(controlAngle) * radius * 2;\r\n            let controlY = midY - sin(controlAngle) * radius * 2;\r\n\r\n        // Draw the arc\r\n        drawArc(startX, startY, endX, endY, controlX, controlY);\r\n    \r\n        if (nextSeedIndex ==-1) {\r\n            nextSeedIndex = connectedLeftEdges.indexOf(false);\r\n        }\r\n    \r\n        if (nextSeedIndex !== -1) {\r\n            let nextSeed = seedpoints[nextSeedIndex];\r\n            connectedLeftEdges[nextSeedIndex] = true; // Mark the left edge as connected\r\n        \r\n            // Calculate the angle to face the edges of the canvas\r\n            let currentAngle = atan2(centralPoint.y - currentSeed.y, centralPoint.x - currentSeed.x) + PI / 2;\r\n            let nextAngle = atan2(centralPoint.y - nextSeed.y, centralPoint.x - nextSeed.x) + PI / 2;\r\n            let nextRadius = baseRadius * nextSeed.radiusIncrease;\r\n            //Calculate the edges of the arcs\r\n            let currentX = currentSeed.x - cos(currentAngle) * radius;\r\n            let currentY = currentSeed.y - sin(currentAngle) * radius;\r\n            let nextX = nextSeed.x + cos(nextAngle) * nextRadius;\r\n            let nextY = nextSeed.y + sin(nextAngle) * nextRadius;\r\n            \r\n            // Calculate control point for the Bezier curve\r\n            let midX = lerp(currentX, nextX, currentSeed.percentageDistance);\r\n            let midY = lerp(currentY, nextY, currentSeed.percentageDistance);\r\n            \r\n            // Calculate the angle towards centralPoint\r\n                let controlAngle = atan2(centralPoint.y - midY, centralPoint.x - midX);\r\n            \r\n            // Calculate control point position at a distance of curvature from the midpoint\r\n                let controlX = midX + cos(controlAngle) * currentSeed.curvature;\r\n                let controlY = midY + sin(controlAngle) * currentSeed.curvature;\r\n\r\n            // Draw the arc\r\n            drawArc(currentX, currentY, nextX, nextY, controlX,",
    " controlY);\r\n        }\r\n    }\r\n    endShape();\r\n    \r\n    loadPixels(); // Load the pixel data from the canvas\r\n    \r\n    // Array to store pixel positions matching the target color\r\n    let minX = createVector(canvasWidth, 0);\r\n    let maxX = createVector(0, 0);\r\n\r\n    // Loop through each pixel in the canvas\r\n    //We don't need to do this for mutations that don't change the shape outline\r\n    if(![\r\n        \"gradientTypeChange\", \"dividerCountChange\", \"circleCountChange\",\r\n        \"lineCountChange\", \"circleSizeIncrease\", \"circleSizeDecrease\",\r\n        \"circlePositionChange\", \"circleMoveLeft\", \"circleMoveRight\",\r\n        \"circleMoveUp\", \"circleMoveDown\", \"lineWidthIncrease\",\r\n        \"lineWidthDecrease\", \"lineAngleChange\", \"lineLengthIncrease\",\r\n        \"lineLengthDecrease\", \"linePositionChange\", \"lineMoveLeft\",\r\n        \"lineMoveRight\", \"lineMoveUp\", \"lineMoveDown\",\r\n        \"paletteChangeOne\", \"paletteChangeAll\", \"paletteCombineOne\",\r\n        \"paletteCombineAll\", \"paletteResetOne\", \"paletteResetAll\",\r\n        \"paletteShuffle\", \"dividerMove\", \"dividerRotate\"\r\n    ].includes(setupVariables.mutation)){\r\n        blankShapeBackgroundArray = [];\r\n        blankShapeMatchingPixels = [];\r\n        for (let x = 0; x < width; x++) {\r\n            canvasArray[x] = [];\r\n            shapeArray[x] = [];\r\n            weightsArray[x] = [];\r\n            linesToRightArray[x] = [];\r\n            for (let y = 0; y < height; y++) {\r\n                let pixelIndex = (x + y * width) * 4; // Calculate the pixel index in the pixel array\r\n\r\n                // Check if the current pixel color matches the target color\r\n                if (\r\n                    pixels[pixelIndex] === 0 &&\r\n                    pixels[pixelIndex + 1] === 0 &&\r\n                    pixels[pixelIndex + 2] === 0\r\n                ) {\r\n                    // If it matches, store the pixel position in the array\r\n                    matchingPixels.push(createVector(x, y));\r\n                    //instead of creating a copy of matching pixels, we push at the same time because vectors can't be copied with structuredClone with p5js1.0.0\r\n                    blankShapeMatchingPixels.push(createVector(x, y));\r\n            \r\n                    canvasArray[x][y] = {\r\n                        r: pixels[pixelIndex],\r\n                        g: pixels[pixelIndex+1],\r\n                        b: pixels[pixelIndex+2],\r\n                    };\r\n                \r\n                    shapeArray[x][y] = 1;\r\n\r\n                    weightsArray[x][y] = 0;\r\n                    linesToRightArray[x][y] = 0;\r\n\r\n                    if(x>maxX.x) {\r\n                        maxX = createVector(x, y);\r\n                    }\r\n                    if (x<minX.x) {\r\n                        minX = createVector(x, y);\r\n                    }\r\n                } else {\r\n                    //otherwise check if it is border and not background\r\n                    if (\r\n                        pixels[pixelIndex] !== 255 &&\r\n                        pixels[pixelIndex +1] !== 255 &&\r\n                        pixels[pixelIndex +2] !== 255\r\n                    ) {\r\n                        // If does not match, store the pixel position in the array\r\n                        borderPixels.push({\r\n                            x: x,\r\n                            y: y,\r\n                            r: pixels[pixelIndex],\r\n                            g: pixels[pixelIndex+1],\r\n                            b: pixels[pixelIndex+2],\r\n                        });\r\n                        shapeArray[x][y] = 0;\r\n                    } else{\r\n                        //this means it is background\r\n                        shapeArray[x][y] = 0;\r\n                        blankShapeBackgroundArray.push({x:x,y:y});\r\n                        setPixelColor(x,y,\"#EBE5D9\");\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        blankShapeCanvasArray = structuredClone(canvasArray);\r\n        blankShapeShapeArray = structuredClone(shapeArray);\r\n        blankShapeWeightsArray = structuredClone(weightsArray);\r\n        blankShapeLinesToRightArrray = structuredClone(linesToRightArray);\r\n        blankShapeBorderPixels = structuredClone(borderPixels);\r\n        blankShapeMaxX = createVector(maxX.x, maxX.y);\r\n        blankShapeMinX = createVector(minX.x, minX.y);\r\n    } else {\r\n        canvasArray = blankShapeCanvasArray;\r\n        shapeArray = blankShapeShapeArray;\r\n        weightsArray = blankShapeWeightsArray;\r\n        linesToRightArray = blankShapeLinesToRightArrray;\r\n        matchingPixels = blankShapeMatchingPixels;\r\n        maxX = blankShapeMaxX;\r\n        minX = blankShapeMinX;\r\n        borderPixels = blankShapeBorderPixels;\r\n        for(let i=0; i<blankShapeBackgroundArray.length; i++){\r\n            setPixelColor(blankShapeBackgroundArray[i].x,blankShapeBackgroundArray[i].y,\"#EBE5D9\");\r\n        }\r\n    }\r\n\r\n    // Now, 'matchingPixels' array contains the positions of all pixels with RGB(0, 0, 0)\r\n    //minX is the left edge of the shape and maxX is the right side of the shape\r\n\r\n    //Now we will draw lines to split the area in 1-4 subareas\r\n    for (let i = 0; i < dividerCount; i++){\r\n        //add a color for the new subsection\r\n\r\n        if(!variablesGenerated || missingDividers>i){\r\n\r\n            if(missingDividers>i) {\r\n                let randomIndex = floor(random(setupVariables.selectedcolors.length+1));\r\n                setupVariables.selectedcolors.splice(randomIndex,0,colors[floor(random(colors.length))]);\r\n            } else {\r\n                setupVariables.selectedcolors.push(colors[floor(random(colors.length))]);\r\n            };\r\n\r\n            selectedcolors = setupVariables.selectedcolors;\r\n\r\n            // Select a random point on the top edge\r\n            let startPointX = floor(random(width));\r\n            let angle = random(); // Random angle in radians (180 degrees) as % of range between min and max angle\r\n\r\n            setupVariables.dividers[setupVariables.dividers.length] = {\r\n                startPointX: startPointX / canvasWidth,\r\n                angle: angle\r\n            }\r\n        }\r\n        \r\n        let startPointX = setupVariables.dividers[i].startPointX * canvasWidth;\r\n\r\n        let minAngle = atan2(minX.y, minX.x - startPointX);\r\n        let maxAngle = atan2(maxX.y, maxX.x - startPointX);\r\n        \r\n        // Ensure angles are positive\r\n        minAngle = (minAngle + TWO_PI);\r\n        maxAngle = (maxAngle + TWO_PI);\r\n        \r\n        // Ensure minAngle is smaller than maxAngle\r\n        if (minAngle > maxAngle) {\r\n            let temp = minAngle;\r\n            minAngle = maxAngle;\r\n            maxAngle = temp;\r\n        }\r\n\r\n        let angle = setupVariables.dividers[i].angle * (maxAngle - minAngle) + minAngle;\r\n\r\n        if(chosenDividerIndex == i && setupVariables.mutation == \"dividerMove\") {\r\n            let chosenDivider = setupVariables.dividers[chosenDividerIndex];\r\n\r\n            let x0 = minX.x; // x-coordinate of the point\r\n            let y0 = minX.y; // y-coordinate of the point\r\n            let m = tan(angle);\r\n            let minTopX = x0 - (y0 / m);\r\n\r\n            let x1 = maxX.x; // x-coordinate of the point\r\n            let y1 = maxX.y; // y-coordinate of the point\r\n            let maxTopX = x1 - (y1 / m);\r\n\r\n            if(minTopX>maxTopX) {\r\n                let temp = maxTopX;\r\n                maxTopX = minTopX;\r\n                minTopX = temp;\r\n            }\r\n\r\n            setupVariables.dividers[i].startPointX = floor(random(max(0,minTopX),min(canvasWidth,maxTopX+1)))/canvasWidth;\r\n\r\n            startPointX = setupVariables.dividers[i].startPointX * canvasWidth;\r\n        } else if(chosenDividerIndex == i && setupVariables.mutation == \"dividerRotate\") {\r\n            let newRand = random();\r\n            setupVariables.dividers[i].angle = newRand;\r\n            angle = newRand * (maxAngle - minAngle) + minAngle;\r\n        }\r\n\r\n\r\n        drawLine(startPointX, angle, minAngle, maxAngle);\r\n    }\r\n    \r\n\r\n\r\n    //Now that we have the lines, we will divide the matchingPixels array into subareas and paint each one a different color\r\n    \r\n    //Create a first empty array because sometimes we have a shape with 0 pixels with 0 lines to its right\r\n    let subArrays = [[]];\r\n    let borderArrays = [];\r\n\r\n    // Loop through each pixel in the matchingPixels array\r\n    for (let i = 0; i < matchingPixels.length; i++) {\r\n        let pixel = matchingPixels[i];\r\n\r\n        // Count the number of lines to the right of the pixel\r\n        let lineCountResult = countLinesToRight(pixel);\r\n    \r\n        let linesToRight = lineCountResult[0];\r\n        let borderWeight = lineCountResult[1];\r\n\r\n        // Color in the pixel correspondingly\r\n        let pixelColor = color(selectedcolors[linesToRight]);\r\n\r\n        // Instead of setting the color directly, we will just store it in the canvasArray for now - since we now have to do antialiasing\r\n        canvasArray[pixel.x][pixel.y] = {\r\n            r: red(pixelColor),\r\n            g: green(pixelColor),\r\n            b: blue(pixelColor),\r\n        };\r\n    \r\n        // If the sub-array for the count doesn't exist, create it\r\n        if (!subArrays[linesToRight]) {\r\n            subArrays[linesToRight] = [];\r\n        }\r\n\r\n        // Add the pixel to the corresponding sub-array\r\n        subArrays[linesToRight].push(pixel);\r\n        // Also add the linesToRight to the corresponding array where we track it\r\n        linesToRightArray[pixel.x][pixel.y] = linesToRight;\r\n    \r\n        // If the borderArray for the count doesn't exist, create it\r\n        if (!borderArrays[linesToRight]) {\r\n            borderArrays[linesToRight] = [];\r\n        }\r\n\r\n        // If the pixel is a border, add it to the corresponding borderArray and to weightsArray\r\n        if(borderWeight !== 0 ) {\r\n            borderArrays[linesToRight].push({\r\n                x: pixel.x,\r\n                y: pixel.y,\r\n                weight: borderWeight\r\n            });\r\n\r\n            weightsArray[pixel.x][pixel.y] = borderWeight;\r\n        }\r\n    }\r\n    \r\n    // Add gradient to the shape if it has more than one color\r\n    if (subArrays.length == 1 || gradientType == 0){    \r\n        // Apply antialiasing to the pixel colors stored in canvasArray and modifies these colors accordingly\r\n        applyAntialiasing(10);\r\n    } else if (gradientType == 1) {\r\n        // As an alternative, color the pixels in each subsection of the shape using a gradient that goes either from the rightmost or leftmost edge of the shape towards the next closest line and from each line to the middle line between it and each adjacent line. We should write a function that recalculates the color of each pixel inside the shape (as defined by those with a value of 1 for their coordinates in shapeArray) such that we get these gradients\r\n        let distancesArray = [];\r\n        let maxDistances = [];\r\n        let splitArray = false;\r\n        let splitFlagsArray = [];\r\n        let reverseDistancesArray = [];\r\n        //deletable I think\r\n        let maxReverseDistances = [];\r\n        let maxIntermediateDistances = [];\r\n        let maxIntermediateReverseDistances = [];\r\n        let maxDistances2 = [];\r\n        let lineIndex = 0;\r\n        let reverseLineIndex = 0;\r\n        let maxIntermediateLineIndices = [];\r\n        let maxIntermediateReverseLineIndices = [];\r\n        // For each point in each subarray, calculate the distance to the first line that we cross when ray tracing to the right.\r\n        // Store this information in the distancesArray, that should have values only for points inside the shape.\r\n        // We need to treat subArrays[0] separately, there we will have to ray trace backwards and do the opposite gradient to achieve the desired effect.\r\n        // For subArrays that are not subArrays[0] or subArrays[subArrays.length-1] we need to ray trace both ways, compare the two distances and store this information in subArrayHalf\r\n\r\n        for (let i = 0;i<subArrays.length; i++) {\r\n            maxDistances [i] = 0;\r\n            maxDistances2 [i] = [];\r\n            //deletable I think\r\n            maxReverseDistances[i] = 0;\r\n            distancesArray[i] = [];\r\n            reverseDistancesArray [i] = [];\r\n            splitFlagsArray[i] = [];\r\n            maxIntermediateDistances[i] = [];\r\n            maxIntermediateReverseDistances[i] = [];\r\n            maxIntermediateLineIndices[i] = [];\r\n            maxIntermediateReverseLineIndices[i] = [];\r\n            if(i == 0 || i == (subArrays.length -1)){\r\n                splitArray = false;\r\n            }else {\r\n                splitArray = true;\r\n            }\r\n\r\n            for(let j = 0; j < subArrays[i].length; j++) {\r\n                let pixel = subArrays[i][j];\r\n                let direction = 1;\r\n                \r\n                if (!maxIntermediateDistances[i][pixel.y]) {\r\n                    maxIntermediateDistances[i][pixel.y] = 0;\r\n                }\r\n                if (!maxIntermediateReverseDistances[i][pixel.y]) {\r\n                    maxIntermediateReverseDistances[i][pixel.y] = 0;\r\n                }\r\n                if (!maxDistances2[i][pixel.y]) {\r\n                    maxDistances2[i][pixel.y] = 0;\r\n                }\r\n                \r\n                if( i == 0) {\r\n                    direction = -1;\r\n                }\r\n                \r\n                let distance = Infinity;\r\n                let reverseDistance = Infinity;\r\n\r\n                [distance, lineIndex] = findFirstLineToRightDistance (pixel, direction);\r\n            \r\n                [reverseDistance, reverseLineIndex] =  findFirstLineToRightDistance (pixel, direction * -1);\r\n\r\n                if(distance < Infinity) {\r\n                    maxIntermediateLineIndices[i][pixel.y] = lineIndex;\r\n                \r\n                    if (reverseDistance < Infinity && splitArray) {\r\n                        // These splits are in reverse order since selectedcolors is colors ordered from right to left\r\n                        if(distance > reverseDistance) {\r\n                            //this is the left side of the subarray\r\n                            splitFlagsArray[i][j] = 1;\r\n                        } else {\r\n                            //this is the right side of the subarray\r\n                            splitFlagsArray[i][j] = -1;\r\n                        }\r\n                        maxIntermediateReverseLineIndices[i][pixel.y] = reverseLineIndex;\r\n                    } else {\r\n                        splitFlagsArray[i][j] = 0;\r\n                    }\r\n                \r\n                    distancesArray[i][j] = distance;\r\n                \r\n                    if (distance > maxDistances[i] && splitFlagsArray[i][j] == 0) {\r\n                        maxDistances[i] = distance;\r\n                    }\r\n\r\n                    if (distance > maxDistances2[i][pixel.y] && splitFlagsArray[i][j] == 0) {\r\n                        maxDistances2[i][pixel.y] = distance;\r\n                    }\r\n                            \r\n                    if (distance > maxIntermediateDistances[i][pixel.y] && splitFlagsArray[i][j] == -1) {\r\n                        maxIntermediateDistances[i][pixel.y] = distance;\r\n                    }\r\n                } else {\r\n                    maxIntermediateReverseLineIndices[i] = reverseLineIndex;\r\n                }\r\n            \r\n                if(reverseDistance < Infinity && splitFlagsArray[i][j] == 1) {\r\n                    distancesArray[i][j] = reverseDistance;\r\n                \r\n                    if (reverseDistance > maxIntermediateReverseDistances[i][pixel.y]) {\r\n                        maxIntermediateReverseDistances[i][pixel.y] = reverseDistance;\r\n                    }\r\n                }\r\n            \r\n            }  \r\n        \r\n            // Now we loop through the maxIntermediateDistances[i] and maxIntermediateReverseDistances[i] array and fix it up so that we don't have the gradient bordering the edge of the shape.\r\n            // We should skip this for the leftmost and rightmost subareas for a bit of extra efficiency\r\n            if(!splitArray) {\r\n                continue;\r\n            }\r\n\r\n            // Each of these array's indexes signify the y value for that maxium, and the value stored at that index is the x value relative to the line that limits this area of the shape\r\n            // This Y value should be increasing linearly for the whole array, but X may not always be linear as well.\r\n            // We should figure out if there is a part of the array where it is not increasing linearly, and if so make it linear / maintain the last prior value where it increased linearly\r\n            // The first step to do this is figuring out which half of the boundary is linear\r\n            // Assumption: linear part will always reach one of the two shape edges - I think this is always the case but could not prove it 100%\r\n            // We calculate the total number of values in each array of max distances - we have to do this because these two arrays do not start at 0.\r\n        \r\n            for (let j = 1; j < maxIntermediateReverseDistances[i].length; j++) {\r\n                if(maxIntermediateLineIndices[i][j] !== undefined && maxIntermediateReverseLineIndices[i][j] !== undefined){\r\n                        //this should only happen if at this y coordinate, the line that divides the two halves of the subarray is outside of the shape\r\n                        //the whole linear regression above tries to find this line but does not seem to be working\r\n                        //we can maybe instead try to find the midpoint between the two points that cross this y on the bordering divider lines\r\n                        //todo: try this approach - we need a way to figure out which two lines to use\r\n                        //we should have this in the following arrays: maxIntermediateLineIndices[i][j] and maxIntermediateReverseLineIndices[i][j]\r\n                        //we should use these indices to get lines from previousLines[j]\r\n                        let rightLine = previousLines[maxIntermediateLineIndices[i][j]];\r\n                        let leftLine = previousLines[maxIntermediateReverseLineIndices[i][j]];\r\n                        //then we find on each of those lines what point corresponds to the y coordinate we are looking for\r\n                        let rightPoint = getPointOnLineFromY(rightLine,j);\r\n                        let leftPoint = getPointOnLineFromY(leftLine,j);\r\n                        let halfWidth = abs((rightPoint.x - leftPoint.x) / 2);\r\n                        \r\n                        maxIntermediateReverseDistances[i][j] = halfWidth;\r\n                        maxIntermediateDistances[i][j] = halfWidth;\r\n\r\n                        //we calculate the mid x between those two points, and with that X and the Y coordinate we are working on, we check if the closest point to that (round down or up) is in shapeArray\r\n                        //if it is, we do nothing. If it is not, we use the max distance between this and the previous Y (as below) -> actually this would give us a vertical reference point rather than one that follows the line, I don't think this is the right approach\r\n                        //actually, in all cases I think max distance should just be half the distance between those two points. We don't even need to calculate the midpoint, just the distance between those two points\r\n                        //half that should be the max distance both for one direction and the other. In cases where this midpoint is in the shape it will already be the case, if not we will set it.\r\n                        //so we actually just loop through y coordinates, find the two crossing points with that y coordinate's LineIndex and ReverseLineIndex, calculate the distance between those 2 and then half that. Use the result of this as BOTH maxIntermediateDistances[i][j] and maxIntermediateReverseDistances[i][j].\r\n                        //that should work in all cases\r\n                        //all of the section between exclamations should be able to be substituted by this\r\n                        //and the line immediately below this one may not be needed (and this loop through y values of maxIntermediateDistances and maxIntermediateReverseDistances yes though)\r\n                }\r\n            }\r\n        }\r\n\r\n        // For each point in each subarray, calculate its interpolation factor as this distance divided by the maximum distance obtained by a point in that subarray\r\n        let interpolationFactorsArrays = [];\r\n    \r\n        for (let i=0;i<distancesArray.length;i++) {\r\n            interpolationFactorsArrays[i] = [];\r\n            for(let j=0; j<distancesArray[i].length;j++) {\r\n                if(splitFlagsArray[i][j] == 1){\r\n                    // Check if the value is not empty before dividing\r\n                    if (maxIntermediateReverseDistances[i][subArrays[i][j].y] === 0 || maxIntermediateReverseDistances[i][subArrays[i][j].y] == undefined){\r\n                        interpolationFactorsArrays[i][j] = 0;\r\n                    } else {\r\n                        interpolationFactorsArrays[i][j] = distancesArray[i][j] / maxIntermediateReverseDistances[i][subArrays[i][j].y];\r\n                    }\r\n                } else if(splitFlagsArray[i][j] == -1) {\r\n                    // Check if the value is not empty before dividing\r\n                    if (maxIntermediateDistances[i][subArrays[i][j].y] === 0 || maxIntermediateDistances[i][subArrays[i][j].y] == undefined){\r\n                        interpolationFactorsArrays[i][j] = 0;\r\n                    } else {\r\n                        interpolationFactorsArrays[i][j] = distancesArray[i][j] / maxIntermediateDistances[i][subArrays[i][j].y];\r\n                    }\r\n                } else {\r\n                    // Check if the value is not empty before dividing, we have two alternative approaches here, I like second best\r\n                    if (maxDistances[i] === 0 || maxDistances[i] == undefined){\r\n                        interpolationFactorsArrays[i][j] = 0;\r\n                    } else {\r\n                        interpolationFactorsArrays[i][j] = distancesArray[i][j] / maxDistances[i];\r\n                    }\r\n                }\r\n            }\r\n        }\r\n\r\n        // Interpolate between that subarray's color and the next/previous one depending on gradient direction, and apply that color to that point in the canvasArray\r\n    \r\n        // We need to subdivide each central subArray into two\r\n        // Then, for each subdivided subarray, the first half has to be the midpoint color between this subarray and the previous one, and the second half's color has to be this subarray's original color\r\n        // The gradient will either go:\r\n        // From this section's color to the intermediate color between this section and the next, if it is an odd section\r\n        // From the intermediate color between this section and the previous to this section's color, if it is an even section\r\n        let newSelectedColors = [];\r\n    \r\n        // Code to subdivide the central selectedColors array:\r\n        // we need to add an intermediate color between every two colors\r\n        // two subarrays -> 3 selectedcolors\r\n        // three subarrays -> 5 selectedcolors\r\n        // newSelectedColors should always have a length of one more item than subArrays\r\n    \r\n        for (let i=0; i< selectedcolors.length; i++) {\r\n            if (i != (selectedcolors.length -1) ){\r\n                newSelectedColors.push(color(selectedcolors[i]));",
    "\r\n                newSelectedColors.push(lerpColor(color(selectedcolors[i]),color(selectedcolors[i+1]),0.5));\r\n            } else {\r\n                // add  just the current selectedColor and nothing else\r\n                newSelectedColors.push(color(selectedcolors[i]));\r\n            }\r\n        }\r\n        applyGradients(subArrays,interpolationFactorsArrays,newSelectedColors,splitFlagsArray);\r\n        applyAntialiasing(10);\r\n    } else {\r\n        // Apply antialiasing to the pixel colors stored in canvasArray and modifies these colors accordingly\r\n        applyAntialiasing(0);\r\n        \r\n        for (let i=1; i<borderArrays.length;i++){\r\n            if (borderArrays[i] == undefined){\r\n            continue;\r\n            }\r\n            for (let j=0;j<borderArrays[i].length;j++) {\r\n                let targetPixel = borderArrays[i][j];\r\n                let newColor = lerpColor(\r\n                    color(selectedcolors[i-1]),\r\n                    color(selectedcolors[i]),\r\n                    targetPixel.weight\r\n                );\r\n                canvasArray[targetPixel.x][targetPixel.y] = {\r\n                    r: red(newColor),\r\n                    g: green(newColor),\r\n                    b: blue(newColor),\r\n                };\r\n            }    \r\n        }\r\n    }\r\n    \r\n    // after antialiasing, fix up borders\r\n    \r\n    //We now need to loop through the borderPixels array and change its color\r\n    //The color that each of these pixels currently has is the result of having a combination of black and white pixels surrounding it\r\n    //The white pixels that used to surround this pixel are now of color \"#EBE5D9\"\r\n    //The black pixels are now one of the following colors: \"#ED3A49\", \"#70D794\", \"#3479B4\", \"#F2C946\", \"#000000\", \"#FFFFFF\"\r\n    //We need to apply to the new colors the same interpolation that had been applied to black and white to get the pixel's current color.\r\n    //This will give us the pixel's new color, which we will apply using the setPixelColor() function\r\n    \r\n    // Loop through the borderPixels array\r\n    for (let i = 0; i < borderPixels.length; i++) {\r\n        let pixel = borderPixels[i];\r\n        \r\n        // Calculate the interpolation factor based on the pixel position between minX and maxX\r\n        let redInterpolationFactor = pixel.r/255;\r\n        let greenInterpolationFactor = pixel.g/255;\r\n        let blueInterpolationFactor = pixel.b/255;\r\n        \r\n        // Find all of this pixel's surrounding pixels in the matchingPixels array\r\n        let surroundingPixels = findSurroundingPixels(pixel, canvasArray);\r\n\r\n        // Calculate the average values for red, green, and blue\r\n        let avgRed = calculateAverageColorComponent(surroundingPixels, 'r');\r\n        let avgGreen = calculateAverageColorComponent(surroundingPixels, 'g');\r\n        let avgBlue = calculateAverageColorComponent(surroundingPixels, 'b');\r\n        \r\n        // Apply the interpolation factor to the difference between 255 and each color component\r\n        let interpolatedRed = avgRed + (235 - avgRed) * (redInterpolationFactor || 0);\r\n        let interpolatedGreen = avgGreen + (229 - avgGreen) * (greenInterpolationFactor || 0);\r\n        let interpolatedBlue = avgBlue + (217 - avgBlue) * (blueInterpolationFactor ||0);\r\n        \r\n        \r\n        // Set the new color for the pixel using the setPixelColor function\r\n        setPixelColor(pixel.x, pixel.y, color(interpolatedRed, interpolatedGreen, interpolatedBlue));\r\n    }\r\n    \r\n    \r\n    \r\n    \r\n    // Finally, here we will add circles and lines\r\n    \r\n    let bordersArray = structuredClone(shapeArray);\r\n    let preShapesCanvasArray = structuredClone(canvasArray);\r\n    let circleMoveIndex = setupVariables.circleCount;\r\n    let circleOrder = [];\r\n    let shuffledArrayIndex = 0;\r\n    let circlePixelsArray = [];\r\n    let circleRetryArray = new Array(circles.length).fill(0);\r\n\r\n    if(variablesGenerated && setupVariables.mutation == \"circlePositionChange\"){\r\n        circleMoveIndex = floor(random(setupVariables.circleCount));\r\n    }\r\n\r\n    if(variablesGenerated && (setupVariables.mutation == \"circleMoveLeft\" || setupVariables.mutation == \"circleMoveRight\" || setupVariables.mutation == \"circleMoveUp\" || setupVariables.mutation == \"circleMoveDown\")){\r\n        let shuffledArray = [...Array(setupVariables.circleCount).keys()];\r\n        for (let j = shuffledArray.length - 1; j > 0; j--) {\r\n            let k = floor(random() * (j + 1));\r\n            let temp = shuffledArray[j];\r\n            shuffledArray[j] = shuffledArray[k];\r\n            shuffledArray[k] = temp;\r\n        }\r\n        circleOrder = shuffledArray;\r\n    }\r\n\r\n    // Since mutations that affect seedpoints or the actual contour of the shape may make it so a circle no longer fits, even it variables have been generated we double check that all circles' centers are inside the shape, if not, we will regenerate\r\n    let excludedCircleIndices = [];\r\n\r\n    if(variablesGenerated) {\r\n        for(let i=0; i<circles.length;i++){\r\n            let finished = false;\r\n            let x = round(setupVariables.circles[i].centerX * canvasWidth,0);\r\n            let y = round(setupVariables.circles[i].centerY * canvasHeight,0);\r\n\r\n            // Define the range of offsets to check (+/- 2 positions)\r\n            let offsets = [-2, -1, 0, 1, 2];\r\n\r\n            // Loop through all possible offsets\r\n            for (let offsetX of offsets) {\r\n                for (let offsetY of offsets) {\r\n                    // Calculate the neighbor's coordinates\r\n                    let neighborX = x + offsetX;\r\n                    let neighborY = y + offsetY;\r\n\r\n                    // Check if the neighbor is within shape\r\n                    if(neighborX >=0 &&\r\n                        neighborY >= 0 &&\r\n                        neighborX < shapeArray.length &&\r\n                        neighborY < shapeArray[neighborX].length &&\r\n                        shapeArray[neighborX][neighborY] == 0\r\n                    ) {\r\n                        excludedCircleIndices.push(i);\r\n                        finished = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if(finished) break;\r\n            }\r\n        }\r\n    }\r\n\r\n    // We retry this loop up to 3 times searching for a circle that fits\r\n    for(let i=0; i<circles.length;i++){\r\n        circleRetryArray[i]++;\r\n        circlePixelsArray[i] = [];\r\n        // Pick a random point inside the shape\r\n        // TBD: maybe we don't need to add/subtract baseRadius when generating center\r\n        if(!variablesGenerated || missingCircles > i || circleMoveIndex == i || excludedCircleIndices.includes(i)){\r\n            if(missingCircles > i) {\r\n                // This works because we have pushed new circles to the end of the array\r\n                setupVariables.circles[setupVariables.circles.length-1-i].centerX = floor(random(minX.x+baseRadius,maxX.x-baseRadius+1))/canvasWidth;\r\n            } else {\r\n                setupVariables.circles[i].centerX = floor(random(minX.x+baseRadius,maxX.x-baseRadius+1))/canvasWidth;\r\n            }\r\n            \r\n            let centerX = round(setupVariables.circles[i].centerX * canvasWidth,0);\r\n            let minY = shapeArray[centerX].indexOf(1);\r\n            //Rethink this: it assumes we have an array where all of the 1s are together\r\n            //but we could have an array like [0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0]\r\n            //then, instead of having one single interval of minY and maxY, we would need to have a discontinuous range\r\n            //maybe we can leave this as is and draw a random number in a single range with size equal to the number of 1s in the array\r\n            //but then we need to check for several brekapoints, i.e. if the number is bigger than the size of the first set of 1s\r\n            //then we add the number of 0s in between the two ranges of 1s to the selected number to get the final centerY we need to use\r\n            let maxY = minY - 1 + shapeArray[centerX].reduce((acc, currentValue) => acc + currentValue, 0);\r\n            //To do this, now we need to get an array of breakpoints\r\n            let breakPointArray = [];\r\n            for (let j = 1; j < shapeArray[centerX].length; j++) {\r\n                if (shapeArray[centerX][j] !== shapeArray[centerX][j - 1]) {\r\n                    breakPointArray.push(j);\r\n                }\r\n            }\r\n\r\n            if(missingCircles > i) {\r\n                centerX = round(setupVariables.circles[setupVariables.circles.length-1-i].centerX * canvasWidth,0);\r\n                minY = shapeArray[centerX].indexOf(1);\r\n                maxY = minY - 1 + shapeArray[centerX].reduce((acc, currentValue) => acc + currentValue, 0);\r\n                breakPointArray = [];\r\n                for (let j = 1; j < shapeArray[centerX].length; j++) {\r\n                    if (shapeArray[centerX][j] !== shapeArray[centerX][j - 1]) {\r\n                        breakPointArray.push(j);\r\n                    }\r\n                }\r\n                let centerY = floor(random(minY+baseRadius,maxY-baseRadius+1));\r\n                // Here we check if centerY is above more than 1 breakpoint, if soo we increase it\r\n                if(breakPointArray.length > 2) {\r\n                    for (let j = 1; j < breakPointArray.length-1; j++) {\r\n                        if (centerY > breakPointArray[j]) {\r\n                            centerY += breakPointArray[j+1]-breakPointArray[j];\r\n                        }\r\n                        j++;\r\n                    }\r\n                }\r\n                setupVariables.circles[setupVariables.circles.length-1-i].centerY = centerY / canvasHeight;     \r\n            } else {\r\n                let centerY = floor(random(minY+baseRadius,maxY-baseRadius+1));\r\n                // Here we check if centerY is above more than 1 breakpoint, if soo we increase it\r\n                if(breakPointArray.length > 2) {\r\n                    for (let j = 1; j < breakPointArray.length-1; j++) {\r\n                        if (centerY > breakPointArray[j]) {\r\n                            centerY += breakPointArray[j+1]-breakPointArray[j];\r\n                        }\r\n                        j++;\r\n                    }\r\n                }\r\n                setupVariables.circles[i].centerY = centerY / canvasHeight;\r\n            }\r\n        }\r\n\r\n        let centerY = round(setupVariables.circles[i].centerY * canvasHeight,0);\r\n        //We redefine these outside the closure for circle number i, which is not necessarily the circle for which we just generated values\r\n        //If we are mutating, it will not be the same\r\n        let centerX = round(setupVariables.circles[i].centerX * canvasWidth,0);\r\n        let minY = shapeArray[centerX].indexOf(1);\r\n        let maxY = minY - 1 + shapeArray[centerX].reduce((acc, currentValue) => acc + currentValue, 0);\r\n        //We need to adjust maxY to give us the actual maximum Y including the length of any gaps in between\r\n        let breakPointArray = [];\r\n        for (let j = 1; j < shapeArray[centerX].length; j++) {\r\n            if (shapeArray[centerX][j] !== shapeArray[centerX][j - 1]) {\r\n                breakPointArray.push(j);\r\n            }\r\n        }\r\n        if(breakPointArray.length > 2) {\r\n            for (let j = 1; j < breakPointArray.length-1; j++) {\r\n                if (maxY > breakPointArray[j]) {\r\n                    maxY += breakPointArray[j+1]-breakPointArray[j];\r\n                }\r\n                j++;\r\n            }\r\n        }\r\n    \r\n        let circleMinX = minX.x;\r\n        let circleMaxX = maxX.x;\r\n\r\n        //These loops give us the minX and maxX at a specific Y\r\n        for (let j = 0; j < shapeArray.length; j++) {\r\n            if (shapeArray[j][centerY] === 1) {\r\n                circleMinX = j;\r\n                break;\r\n            }\r\n        }\r\n    \r\n        for (let j = shapeArray.length-1; j >= 0; j--) {\r\n            if (shapeArray[j][centerY] === 1) {\r\n                circleMaxX = j;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // To avoid errors, we need to check if we have pixels outside the shape betwwen minX and maxX\r\n        if(variablesGenerated && setupVariables.mutation == \"circleMoveLeft\" && circleOrder[shuffledArrayIndex] == i){\r\n            let XBreakPointArray = [];\r\n            let eligibleXs = 0;\r\n            for (let j = 1; j < centerX+1; j++) {\r\n                if(shapeArray[j][centerY] == 1) {\r\n                    eligibleXs++;\r\n                }\r\n                if (shapeArray[j][centerY] !== shapeArray[j-1][centerY]) {\r\n                    XBreakPointArray.push(j);\r\n                }\r\n            }\r\n            //Since we are not going until the end of the canvas we add a final beakpoint at centerX to ensure we have an even number of breakpoints\r\n            XBreakPointArray.push(centerX);\r\n            // We subtract 1 to not double count the first possible pixel\r\n            centerX = floor(random(circleMinX,circleMinX+eligibleXs-1));\r\n            if(XBreakPointArray.length > 2) {\r\n                for (let j = 1; j < XBreakPointArray.length-1; j++) {\r\n                    if (centerX > XBreakPointArray[j]) {\r\n                        centerX += XBreakPointArray[j+1]-XBreakPointArray[j];\r\n                    }\r\n                    j++;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(variablesGenerated && setupVariables.mutation == \"circleMoveRight\" && circleOrder[shuffledArrayIndex] == i){\r\n            //Since we are not starting at the beginning of the canvas we add a first beakpoint at centerX to ensure we have an even number of breakpoints\r\n            let XBreakPointArray = [centerX];\r\n            let eligibleXs = 1;\r\n            for (let j = centerX+1; j < shapeArray.length; j++) {\r\n                if(shapeArray[j][centerY] == 1) {\r\n                    eligibleXs++;\r\n                }\r\n                if (shapeArray[j][centerY] !== shapeArray[j-1][centerY]) {\r\n                    XBreakPointArray.push(j);\r\n                }\r\n            }\r\n            // We add 1 to guarantee a move to the right, don't need to subtract 1 from eligibleXs because we are flooring\r\n            centerX = floor(random(centerX+1,centerX+eligibleXs+1));\r\n            if(XBreakPointArray.length > 2) {\r\n                for (let j = 1; j < XBreakPointArray.length-1; j++) {\r\n                    if (centerX > XBreakPointArray[j]) {\r\n                        centerX += XBreakPointArray[j+1]-XBreakPointArray[j];\r\n                    }\r\n                    j++;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(variablesGenerated && setupVariables.mutation == \"circleMoveUp\" && circleOrder[shuffledArrayIndex] == i){\r\n            let adjustment = 0;\r\n            if(breakPointArray.length > 2) {\r\n                for (let j = 1; j < breakPointArray.length-1; j++) {\r\n                    if (centerY > breakPointArray[j]) {\r\n                        adjustment += breakPointArray[j+1]-breakPointArray[j];\r\n                    }\r\n                    j++;\r\n                }\r\n            }\r\n            //Since we are flooring, this will never be centerY, and might be minY\r\n            centerY = floor(random(minY,centerY-adjustment));\r\n            if(breakPointArray.length > 2) {\r\n                for (let j = 1; j < breakPointArray.length-1; j++) {\r\n                    if (centerY > breakPointArray[j]) {\r\n                        centerY += breakPointArray[j+1]-breakPointArray[j];\r\n                    }\r\n                    j++;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(variablesGenerated && setupVariables.mutation == \"circleMoveDown\" && circleOrder[shuffledArrayIndex] == i){\r\n            let adjustment = 0;\r\n            if(breakPointArray.length > 2) {\r\n                for (let j = 1; j < breakPointArray.length-1; j++) {\r\n                    if (centerY > breakPointArray[j]) {\r\n                        adjustment += breakPointArray[j+1]-breakPointArray[j];\r\n                    }\r\n                    j++;\r\n                }\r\n            }\r\n            let eligibleYs = shapeArray[centerX].reduce((acc, currentValue) => acc + currentValue, 0);\r\n            // We add 1 so that we can never get centerY again\r\n            centerY = floor(random(centerY-adjustment+1,minY-1+eligibleYs));\r\n            if(breakPointArray.length > 2) {\r\n                for (let j = 1; j < breakPointArray.length-1; j++) {\r\n                    if (centerY > breakPointArray[j]) {\r\n                        centerY += breakPointArray[j+1]-breakPointArray[j];\r\n                    }\r\n                    j++;\r\n                }\r\n            }\r\n        }\r\n\r\n        // We want radius of at least 2 so that it does not look like a square\r\n        let radius = max(2,ceil(circles[i].radius*Math.min((min(canvasHeight,canvasWidth)/12),abs(circleMaxX-centerX),abs(centerX-circleMinX),abs(maxY-centerY),abs(centerY-minY))));\r\n\r\n        // Calculate pixels inside circle\r\n        let circlePixels = calculatePixelsInsideCircle(centerX,centerY,radius);\r\n\r\n        while (circlePixels == null) {\r\n            radius--;\r\n            circlePixels = calculatePixelsInsideCircle(centerX,centerY,radius);\r\n        }\r\n    \r\n        // We don't want to draw individual pixels, circles should have at least radius 2. If we can't draw that, hide this circle.\r\n        if(radius<2) {\r\n            // We do this to try to guarantee that a circle moves left/right whenever any of them could\r\n            if(variablesGenerated && (setupVariables.mutation == \"circleMoveLeft\" || setupVariables.mutation == \"circleMoveRight\" || setupVariables.mutation == \"circleMoveUp\" || setupVariables.mutation == \"circleMoveDown\") && circleOrder[shuffledArrayIndex] == i && circleRetryArray[i] > 2){\r\n                shuffledArrayIndex++;\r\n                if(shuffledArrayIndex<circleOrder.length) {\r\n                    if(circleOrder[shuffledArrayIndex]>i) {\r\n                        i--;\r\n                    } else {\r\n                        i = circleOrder[shuffledArrayIndex]-1;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if((!variablesGenerated || setupVariables.mutation == \"circlePositionChange\" || setupVariables.mutation == \"circleMoveLeft\" || setupVariables.mutation == \"circleMoveRight\" || setupVariables.mutation == \"circleMoveUp\" || setupVariables.mutation == \"circleMoveDown\") && circleRetryArray[i] < 3){\r\n                i--;\r\n            }\r\n            continue;\r\n        }\r\n\r\n        // If we have successfully moved a circle left/right, we persist the change\r\n        if(variablesGenerated && (setupVariables.mutation == \"circleMoveLeft\" || setupVariables.mutation == \"circleMoveRight\") && circleOrder[shuffledArrayIndex] == i){\r\n            setupVariables.circles[i].centerX = centerX/canvasWidth;\r\n        }\r\n\r\n        if(variablesGenerated && (setupVariables.mutation == \"circleMoveUp\" || setupVariables.mutation == \"circleMoveDown\") && circleOrder[shuffledArrayIndex] == i){\r\n            setupVariables.circles[i].centerY = centerY/canvasHeight;\r\n        }\r\n\r\n        circlePixelsArray[i][0] = circlePixels[0];\r\n        circlePixelsArray[i][1] = circlePixels[1];\r\n    }\r\n\r\n\r\n    for(let i=0; i<circles.length;i++){\r\n        if (!circlePixelsArray[i] || circlePixelsArray[i].length === 0) continue;\r\n        let pixelsInside = circlePixelsArray[i][0];\r\n        let pixelsBorder = circlePixelsArray[i][1];\r\n\r\n        // Draw a black circle\r\n        // Make all pixelsInside black or white depending on their background\r\n        // If we change something to white, or if it is black but part of another shape's border, change it to gray instead\r\n        let antialiasThreshold = 75;\r\n        let antialiasThresholdDenominator = 75;\r\n        let antialiasSlope = 10;\r\n        if (gradientType==1){\r\n            antialiasThreshold = 110;\r\n            antialiasThresholdDenominator = 5500;\r\n            antialiasSlope = 1;\r\n        } else if (gradientType==2) {\r\n            antialiasThreshold = 220;    \r\n            antialiasThresholdDenominator = 220;\r\n            antialiasSlope = 0.5;\r\n        }\r\n    \r\n        for(let j=0; j<pixelsInside.length; j++) {\r\n            let targetPixel = pixelsInside[j];\r\n            let currentColor = color(\r\n                canvasArray[targetPixel.x][targetPixel.y].r,\r\n                canvasArray[targetPixel.x][targetPixel.y].g,\r\n                canvasArray[targetPixel.x][targetPixel.y].b,\r\n            );\r\n            \r\n            let colorDifference = dist(\r\n                red(currentColor),green(currentColor),blue(currentColor),\r\n                0,0,0\r\n            );\r\n\r\n            let prevColorCloseToBlack = false;\r\n            let nextColorCloseToBlack = false;\r\n            \r\n            if(\r\n                gradientType == 2 && \r\n                //This line below means we are at a border between two colors\r\n                weightsArray[targetPixel.x][targetPixel.y] != 0\r\n            ) {\r\n\r\n                let linesToRight = linesToRightArray[targetPixel.x][targetPixel.y];\r\n\r\n                // assuming 25 pixels should be enough to find a non-border\r\n                let nonBorderX = targetPixel.x;\r\n                for(let k=1; k<26; k++) {\r\n                    nonBorderX++;\r\n                    if(linesToRightArray[nonBorderX][targetPixel.y] == 0 || linesToRightArray[nonBorderX][targetPixel.y] != linesToRight) {\r\n                        continue;\r\n                    }\r\n                }\r\n\r\n                if (linesToRight == 0 || linesToRight == linesToRightArray[nonBorderX][targetPixel.y]) {\r\n                    let prevColorDifference = dist(\r\n                        red(color(selectedcolors[linesToRight])),green(color(selectedcolors[linesToRight])),blue(color(selectedcolors[linesToRight])),\r\n                        0,0,0\r\n                    );\r\n\r\n                    let nextColorDifference = dist(\r\n                        red(color(selectedcolors[linesToRight+1])),green(color(selectedcolors[linesToRight+1])),blue(color(selectedcolors[linesToRight+1])),\r\n                        0,0,0\r\n                    );\r\n\r\n                    if (prevColorDifference<antialiasThreshold){\r\n                        prevColorCloseToBlack = true;\r\n                    }\r\n                    if (nextColorDifference<antialiasThreshold){\r\n                        nextColorCloseToBlack = true;\r\n                    }\r\n                } else {\r\n                    let prevColorDifference = dist(\r\n                        red(color(selectedcolors[linesToRight-1])),green(color(selectedcolors[linesToRight-1])),blue(color(selectedcolors[linesToRight-1])),\r\n                        0,0,0\r\n                    );\r\n                    let nextColorDifference = dist(\r\n                        red(color(selectedcolors[linesToRight])),green(color(selectedcolors[linesToRight])),blue(color(selectedcolors[linesToRight])),\r\n                        0,0,0\r\n                    );\r\n\r\n                    if (prevColorDifference<antialiasThreshold){\r\n                        prevColorCloseToBlack = true;\r\n                    }\r\n                    if (nextColorDifference<antialiasThreshold){\r\n                        nextColorCloseToBlack = true;\r\n                    }\r\n                }\r\n\r\n                if (prevColorCloseToBlack !== nextColorCloseToBlack) {\r\n                    let newWhiteColor = lerpColor(color(255,255,255),color(0,0,0),weightsArray[targetPixel.x][targetPixel.y]);\r\n\r\n                    if (nextColorCloseToBlack) {\r\n                        newWhiteColor = le",
    "rpColor(color(0,0,0),color(255,255,255),weightsArray[targetPixel.x][targetPixel.y]);\r\n                    }\r\n                \r\n                    // Now we invert the weight so that if another shape is then drawn on top of this, the weight will work in reverse\r\n                    weightsArray[targetPixel.x][targetPixel.y] = 1-weightsArray[targetPixel.x][targetPixel.y];\r\n\r\n                    canvasArray[targetPixel.x][targetPixel.y] = {\r\n                        r: red(newWhiteColor),\r\n                        g: green(newWhiteColor),\r\n                        b: blue(newWhiteColor),\r\n                    };\r\n                    continue;\r\n                }\r\n\r\n            }\r\n\r\n\r\n            if (\r\n                // If we have previously drawn another circle and this pixel is inside the current circle but on the border of that one\r\n                bordersArray[targetPixel.x][targetPixel.y] !== 1  \r\n            ) {\r\n                let originalColor = color(\r\n                    preShapesCanvasArray[targetPixel.x][targetPixel.y].r,\r\n                    preShapesCanvasArray[targetPixel.x][targetPixel.y].g,\r\n                    preShapesCanvasArray[targetPixel.x][targetPixel.y].b\r\n                );\r\n                let originalColorDifference = dist(\r\n                    red(originalColor),green(originalColor),blue(originalColor),\r\n                    0,0,0\r\n                );\r\n\r\n                let newColor = lerpColor(\r\n                    color(255,255,255),\r\n                    color(0,0,0),\r\n                    bordersArray[targetPixel.x][targetPixel.y]\r\n                );\r\n\r\n                if (originalColorDifference<antialiasThreshold) {\r\n                    let midThreshold = antialiasThreshold-antialiasSlope*2;\r\n\r\n                    let newWhiteColor = lerpColor(color(255,255,255),color(0,0,0),\r\n                        (Math.exp((originalColorDifference - midThreshold) / antialiasSlope) - Math.exp(-(originalColorDifference - midThreshold) / antialiasSlope)) /\r\n                        (Math.exp((originalColorDifference - midThreshold) / antialiasSlope) + Math.exp(-(originalColorDifference - midThreshold) / antialiasSlope))\r\n                        * 0.5 + 0.5\r\n                    );\r\n\r\n                    newColor = lerpColor(\r\n                        color(0,0,0),\r\n                        color(red(newWhiteColor),green(newWhiteColor),blue(newWhiteColor)),\r\n                        bordersArray[targetPixel.x][targetPixel.y]\r\n                    );\r\n                }\r\n            \r\n                canvasArray[targetPixel.x][targetPixel.y] = {\r\n                    r: red(newColor),\r\n                    g: green(newColor),\r\n                    b: blue(newColor),\r\n                };\r\n            } else if (colorDifference<antialiasThreshold && (weightsArray[targetPixel.x][targetPixel.y] === 0 || (gradientType != 2 || setupVariables.dividerCount === 0 || prevColorCloseToBlack !== nextColorCloseToBlack || (prevColorCloseToBlack && nextColorCloseToBlack)))) {\r\n                let midThreshold = antialiasThreshold-antialiasSlope*2;\r\n\r\n                let newWhiteColor = lerpColor(color(255,255,255),color(0,0,0),\r\n                    (Math.exp((colorDifference - midThreshold) / antialiasSlope) - Math.exp(-(colorDifference - midThreshold) / antialiasSlope)) /\r\n                    (Math.exp((colorDifference - midThreshold) / antialiasSlope) + Math.exp(-(colorDifference - midThreshold) / antialiasSlope))\r\n                    * 0.5 + 0.5\r\n                );\r\n\r\n                canvasArray[targetPixel.x][targetPixel.y] = {\r\n                    r: red(newWhiteColor),\r\n                    g: green(newWhiteColor),\r\n                    b: blue(newWhiteColor),\r\n                };\r\n\r\n            } else {\r\n                canvasArray[targetPixel.x][targetPixel.y] = {\r\n                    r: 0,\r\n                    g: 0,\r\n                    b: 0,\r\n                };\r\n            }\r\n        }\r\n            \r\n        // Once circle is full and we have colored borders, we need to smooth out jagged lines\r\n\r\n        // If the fill has no gradients, we use weightsArray, otherwise we will antialias with radius 1\r\n        \r\n        if(gradientType != 2){\r\n            //antiAliasShapeFill(pixelsInside);            \r\n        }\r\n\r\n        // Make all pixelsBorder the average between black and their previous color, weighted by the percentage occupation by the circle - each pixelsBorder is an object with props x,y,weight\r\n        \r\n        for(let j=0; j<pixelsBorder.length; j++) {\r\n            let targetPixel = pixelsBorder[j];\r\n            let currentRed = canvasArray[targetPixel.x][targetPixel.y].r;\r\n            let currentGreen = canvasArray[targetPixel.x][targetPixel.y].g;\r\n            let currentBlue = canvasArray[targetPixel.x][targetPixel.y].b;\r\n            let previousBorder = 0.5;\r\n            \r\n            if(bordersArray[targetPixel.x][targetPixel.y] === 1 ) {\r\n                bordersArray[targetPixel.x][targetPixel.y] = targetPixel.weight;\r\n            } else {\r\n                bordersArray[targetPixel.x][targetPixel.y] = min(bordersArray[targetPixel.x][targetPixel.y],targetPixel.weight);\r\n            };\r\n\r\n            // If on gradient type 2 and a divider, we need to be stricter for borders that are part of a divider line\r\n            if (gradientType==2 && weightsArray[targetPixel.x][targetPixel.y] !== 0) {\r\n                previousBorder = 1;\r\n            }\r\n            \r\n            let colorDifference = dist(\r\n                currentRed,\r\n                currentGreen,\r\n                currentBlue,\r\n                0,0,0\r\n            );\r\n            \r\n            if (colorDifference< (antialiasThreshold/(2*previousBorder)) ) {\r\n                let midThreshold =  (antialiasThreshold/(2*previousBorder)) -antialiasSlope*2;\r\n                let newWhiteColor = lerpColor(color(255,255,255),color(0,0,0),\r\n                    (Math.exp((colorDifference - midThreshold) / antialiasSlope) - Math.exp(-(colorDifference - midThreshold) / antialiasSlope)) /\r\n                    (Math.exp((colorDifference - midThreshold) / antialiasSlope) + Math.exp(-(colorDifference - midThreshold) / antialiasSlope))\r\n                    * 0.5 + 0.5\r\n                );\r\n\r\n                let newColor = lerpColor(\r\n                    newWhiteColor,\r\n                    color(currentRed,currentGreen,currentBlue),\r\n                    targetPixel.weight\r\n                );\r\n                canvasArray[targetPixel.x][targetPixel.y] = {\r\n                    r: red(newColor),\r\n                    g: green(newColor),\r\n                    b: blue(newColor),\r\n                };\r\n            } else {\r\n                let newColor = lerpColor(\r\n                    color(0,0,0),\r\n                    color(currentRed,currentGreen,currentBlue),\r\n                    bordersArray[targetPixel.x][targetPixel.y]\r\n                );\r\n                canvasArray[targetPixel.x][targetPixel.y] = {\r\n                    r: red(newColor),\r\n                    g: green(newColor),\r\n                    b: blue(newColor),\r\n                };\r\n            }\r\n        }\r\n    }\r\n\r\n    let lineMoveIndex = setupVariables.lineCount;\r\n    let lineRetryArray = new Array(lines.length).fill(0);\r\n    let lineOrder = [];\r\n    \r\n    if(variablesGenerated && setupVariables.mutation == \"linePositionChange\"){\r\n        lineMoveIndex = floor(random(setupVariables.lineCount));\r\n    }\r\n\r\n    if(variablesGenerated && (setupVariables.mutation == \"lineMoveLeft\" || setupVariables.mutation == \"lineMoveRight\" || setupVariables.mutation == \"lineMoveUp\" || setupVariables.mutation == \"lineMoveDown\")){\r\n        let shuffledArray = [...Array(setupVariables.lineCount).keys()];\r\n        for (let j = shuffledArray.length - 1; j > 0; j--) {\r\n            let k = floor(random() * (j + 1));\r\n            let temp = shuffledArray[j];\r\n            shuffledArray[j] = shuffledArray[k];\r\n            shuffledArray[k] = temp;\r\n        }\r\n        lineOrder = shuffledArray;\r\n    }\r\n\r\n    // Since mutations that affect seedpoints or the actual contour of the shape may make it so a circle no longer fits, even it variables have been generated we double check that all circles' centers are inside the shape, if not, we will regenerate\r\n    let excludedLineIndices = [];\r\n\r\n    if(variablesGenerated) {\r\n        for(let i=0; i<lines.length;i++){\r\n            let finished = false;\r\n            let x = round(setupVariables.lines[i].centerX * canvasWidth,0);\r\n            let y = round(setupVariables.lines[i].centerY * canvasHeight,0);\r\n\r\n            // Define the range of offsets to check (+/- 2 positions)\r\n            let offsets = [-2, -1, 0, 1, 2];\r\n\r\n            // Loop through all possible offsets\r\n            for (let offsetX of offsets) {\r\n                for (let offsetY of offsets) {\r\n                    // Calculate the neighbor's coordinates\r\n                    let neighborX = x + offsetX;\r\n                    let neighborY = y + offsetY;\r\n\r\n                    // Check if the neighbor is within shape\r\n                    if(neighborX >=0 &&\r\n                    neighborY >= 0 &&\r\n                    neighborX < shapeArray.length &&\r\n                    neighborY < shapeArray[neighborX].length &&\r\n                    shapeArray[neighborX][neighborY] == 0\r\n                    ) {\r\n                        excludedLineIndices.push(i);\r\n                        finished = true;\r\n                        break;\r\n                    }\r\n                }\r\n                if(finished) break;\r\n            }\r\n        }\r\n    }\r\n\r\n\r\n    for(let i=0; i<lines.length;i++){\r\n        lineRetryArray[i]++;\r\n\r\n        let halfWidth = lines[i].ancho/2;\r\n        let angle = lines[i].angle;\r\n        // Pick a random point\r\n        if (!variablesGenerated || missingLines > i || lineMoveIndex == i || excludedLineIndices.includes(i)) {\r\n            if(missingLines > i) {\r\n                // This works because we have pushed new lines to the end of the array\r\n                setupVariables.lines[setupVariables.lines.length-1-i].centerX = floor(random(minX.x+halfWidth,maxX.x-halfWidth+1)) / canvasWidth;     \r\n            } else {\r\n                setupVariables.lines[i].centerX = floor(random(minX.x+halfWidth,maxX.x-halfWidth+1)) / canvasWidth;\r\n            }\r\n        \r\n            let centerX = round(setupVariables.lines[i].centerX * canvasWidth, 0);\r\n            let minY = shapeArray[centerX].indexOf(1);\r\n            let maxY = minY - 1 + shapeArray[centerX].reduce((acc, currentValue) => acc + currentValue, 0);           \r\n            //follow same logic as for circles\r\n            let breakPointArray = [];\r\n            for (let j = 1; j < shapeArray[centerX].length; j++) {\r\n                if (shapeArray[centerX][j] !== shapeArray[centerX][j - 1]) {\r\n                    breakPointArray.push(j);\r\n                }\r\n            }\r\n\r\n            if(missingLines > i) {\r\n                centerX = round(setupVariables.lines[setupVariables.lines.length-1-i].centerX * canvasWidth,0);\r\n                minY = shapeArray[centerX].indexOf(1);\r\n                maxY = minY - 1 + shapeArray[centerX].reduce((acc, currentValue) => acc + currentValue, 0);\r\n                breakPointArray = [];\r\n                for (let j = 1; j < shapeArray[centerX].length; j++) {\r\n                    if (shapeArray[centerX][j] !== shapeArray[centerX][j - 1]) {\r\n                        breakPointArray.push(j);\r\n                    }\r\n                }\r\n                let centerY = floor(random(minY+halfWidth,maxY-halfWidth+1));\r\n                // Here we check if centerY is above more than 1 breakpoint, if soo we increase it\r\n                if(breakPointArray.length > 2) {\r\n                    for (let j = 1; j < breakPointArray.length-1; j++) {\r\n                        if (centerY > breakPointArray[j]) {\r\n                            centerY += breakPointArray[j+1]-breakPointArray[j];\r\n                        }\r\n                        j++;\r\n                    }\r\n                }\r\n                setupVariables.lines[setupVariables.lines.length-1-i].centerY = centerY / canvasHeight;     \r\n            } else {\r\n                let centerY = floor(random(minY+halfWidth,maxY-halfWidth+1));\r\n                // Here we check if centerY is above more than 1 breakpoint, if soo we increase it\r\n                if(breakPointArray.length > 2) {\r\n                    for (let j = 1; j < breakPointArray.length-1; j++) {\r\n                        if (centerY > breakPointArray[j]) {\r\n                            centerY += breakPointArray[j+1]-breakPointArray[j];\r\n                        }\r\n                        j++;\r\n                    }\r\n                }\r\n                setupVariables.lines[i].centerY = centerY / canvasHeight;\r\n            }\r\n        \r\n        }\r\n\r\n        let centerY = round(setupVariables.lines[i].centerY * canvasHeight,0);\r\n        //We redefine these outside the closure for circle number i, which is not necessarily the circle for which we just generated values\r\n        //If we are mutating, it will not be the same\r\n        let centerX = round(setupVariables.lines[i].centerX * canvasWidth,0);\r\n        //I think the two lines below can be deleted but maybe we need them for the move line right/left/up/down mutations\r\n        let minY = shapeArray[centerX].indexOf(1);\r\n        let maxY = minY - 1 + shapeArray[centerX].reduce((acc, currentValue) => acc + currentValue, 0);\r\n        //We need to adjust maxY to give us the actual maximum Y including the length of any gaps in between\r\n        let breakPointArray = [];\r\n        for (let j = 1; j < shapeArray[centerX].length; j++) {\r\n            if (shapeArray[centerX][j] !== shapeArray[centerX][j - 1]) {\r\n                breakPointArray.push(j);\r\n            }\r\n        }\r\n        if(breakPointArray.length > 2) {\r\n            for (let j = 1; j < breakPointArray.length-1; j++) {\r\n                if (maxY > breakPointArray[j]) {\r\n                    maxY += breakPointArray[j+1]-breakPointArray[j];\r\n                }\r\n                j++;\r\n            }\r\n        }\r\n\r\n        let lineMinX = minX.x;\r\n        let lineMaxX = maxX.x;\r\n\r\n        //These loops give us the minX and maxX at a specific Y\r\n        for (let j = 0; j < shapeArray.length; j++) {\r\n            if (shapeArray[j][centerY] === 1) {\r\n                lineMinX = j;\r\n                break;\r\n            }\r\n        }\r\n    \r\n        for (let j = shapeArray.length-1; j >= 0; j--) {\r\n            if (shapeArray[j][centerY] === 1) {\r\n                lineMaxX = j;\r\n                break;\r\n            }\r\n        }\r\n\r\n        // To avoid errors, we need to check if we have pixels outside the shape betwwen minX and maxX\r\n        if(variablesGenerated && setupVariables.mutation == \"lineMoveLeft\" && lineOrder[shuffledArrayIndex] == i){\r\n            let XBreakPointArray = [];\r\n            let eligibleXs = 0;\r\n            for (let j = 1; j < centerX+1; j++) {\r\n                if(shapeArray[j][centerY] == 1) {\r\n                    eligibleXs++;\r\n                }\r\n                if (shapeArray[j][centerY] !== shapeArray[j-1][centerY]) {\r\n                    XBreakPointArray.push(j);\r\n                }\r\n            }\r\n            //Since we are not going until the end of the canvas we add a final beakpoint at centerX to ensure we have an even number of breakpoints\r\n            XBreakPointArray.push(centerX);\r\n            // We subtract 1 to not double count the first possible pixel\r\n            centerX = floor(random(lineMinX,lineMinX+eligibleXs-1));\r\n            if(XBreakPointArray.length > 2) {\r\n                for (let j = 1; j < XBreakPointArray.length-1; j++) {\r\n                    if (centerX > XBreakPointArray[j]) {\r\n                        centerX += XBreakPointArray[j+1]-XBreakPointArray[j];\r\n                    }\r\n                    j++;\r\n                }\r\n            }\r\n        }            \r\n\r\n\r\n        if(variablesGenerated && setupVariables.mutation == \"lineMoveRight\" && lineOrder[shuffledArrayIndex] == i){\r\n            //Since we are not starting at the beginning of the canvas we add a first beakpoint at centerX to ensure we have an even number of breakpoints\r\n            let XBreakPointArray = [centerX];\r\n            let eligibleXs = 1;\r\n            for (let j = centerX+1; j < shapeArray.length; j++) {\r\n                if(shapeArray[j][centerY] == 1) {\r\n                    eligibleXs++;\r\n                }\r\n                if (shapeArray[j][centerY] !== shapeArray[j-1][centerY]) {\r\n                    XBreakPointArray.push(j);\r\n                }\r\n            }\r\n            // We add 1 to guarantee a move to the right, don't need to subtract 1 from eligibleXs because we are flooring\r\n            centerX = floor(random(centerX+1,centerX+eligibleXs+1));\r\n            if(XBreakPointArray.length > 2) {\r\n                for (let j = 1; j < XBreakPointArray.length-1; j++) {\r\n                    if (centerX > XBreakPointArray[j]) {\r\n                        centerX += XBreakPointArray[j+1]-XBreakPointArray[j];\r\n                    }\r\n                    j++;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(variablesGenerated && setupVariables.mutation == \"lineMoveUp\" && lineOrder[shuffledArrayIndex] == i){\r\n            let adjustment = 0;\r\n            if(breakPointArray.length > 2) {\r\n                for (let j = 1; j < breakPointArray.length-1; j++) {\r\n                    if (centerY > breakPointArray[j]) {\r\n                        adjustment += breakPointArray[j+1]-breakPointArray[j];\r\n                    }\r\n                    j++;\r\n                }\r\n            }\r\n            //Since we are flooring, this will never be centerY, and might be minY\r\n            centerY = floor(random(minY,centerY-adjustment));\r\n            if(breakPointArray.length > 2) {\r\n                for (let j = 1; j < breakPointArray.length-1; j++) {\r\n                    if (centerY > breakPointArray[j]) {\r\n                        centerY += breakPointArray[j+1]-breakPointArray[j];\r\n                    }\r\n                    j++;\r\n                }\r\n            }\r\n        }\r\n\r\n        if(variablesGenerated && setupVariables.mutation == \"lineMoveDown\" && lineOrder[shuffledArrayIndex] == i){\r\n            let adjustment = 0;\r\n            if(breakPointArray.length > 2) {\r\n                for (let j = 1; j < breakPointArray.length-1; j++) {\r\n                    if (centerY > breakPointArray[j]) {\r\n                        adjustment += breakPointArray[j+1]-breakPointArray[j];\r\n                    }\r\n                    j++;\r\n                }\r\n            }\r\n            let eligibleYs = shapeArray[centerX].reduce((acc, currentValue) => acc + currentValue, 0);\r\n            // We add 1 so that we can never get centerY again\r\n            centerY = floor(random(centerY-adjustment+1,minY-1+eligibleYs));\r\n            if(breakPointArray.length > 2) {\r\n                for (let j = 1; j < breakPointArray.length-1; j++) {\r\n                    if (centerY > breakPointArray[j]) {\r\n                        centerY += breakPointArray[j+1]-breakPointArray[j];\r\n                    }\r\n                    j++;\r\n                }\r\n            }\r\n        }\r\n\r\n        // Follow the line angle with increasing length in both senses until we reach a pixel that is not in shapeArray\r\n        // Consider repeating this if it gives us a maxLength of less than 2 but trying to rotate the angle instead, maybe in increments of 5-10\r\n        let lineMin = createVector(centerX,centerY);\r\n        let lineMax = lineMin;\r\n        let maxLength = 0;\r\n        let maxLineDist = sqrt(canvasHeight**2+(maxX.x-minX.x)**2);\r\n        let lastPositivePixel = lineMin;\r\n        let lastNegativePixel = lineMin;\r\n        let rotationAngle = 0;\r\n        let widthFits = false;\r\n\r\n        while (!widthFits && rotationAngle <= PI && maxLength<2){\r\n            for (let j = 1; j < maxLineDist; j++) {\r\n                let positivePixel = findPointOnLine(centerX, centerY, angle, j);\r\n                let negativePixel = findPointOnLine(centerX, centerY, angle + PI, j);\r\n                if (shapeArray[floor(positivePixel.x)] == undefined || shapeArray[floor(positivePixel.x)][floor(positivePixel.y)] !== 1) {\r\n                    lastPositivePixel = positivePixel;\r\n                    lastNegativePixel = negativePixel;\r\n                    maxLength = j-1;\r\n                    break;\r\n                }\r\n                \r\n                if (shapeArray[floor(negativePixel.x)] == undefined || shapeArray[floor(negativePixel.x)][floor(negativePixel.y)] !== 1) {\r\n                    lastPositivePixel = positivePixel;\r\n                    lastNegativePixel = negativePixel;\r\n                    maxLength = j-1;\r\n                    break;\r\n                }\r\n            }\r\n        \r\n            // Check if the full width of the line can fit in each of the line's extremes and still be inside shapeArray by calculating both points at a distance of ancho/2 from these two last points in a perpendicular direction from angle\r\n            // While it does not fit, shorten the max length and repeat\r\n            // When it fits or max length is 0, stop doing it and use this value as max length\r\n        \r\n            widthFits = false;\r\n        \r\n            let positivePositivePixel;\r\n            let positiveNegativePixel;\r\n            let negativePositivePixel;\r\n            let negativeNegativePixel;\r\n        \r\n            while (!widthFits && maxLength > 0){\r\n                positivePositivePixel = findPointOnLine(lastPositivePixel.x, lastPositivePixel.y, angle+PI/2, halfWidth);\r\n                positiveNegativePixel = findPointOnLine(lastPositivePixel.x, lastPositivePixel.y, angle-PI/2, halfWidth);\r\n                negativePositivePixel = findPointOnLine(lastNegativePixel.x, lastNegativePixel.y, angle+PI/2, halfWidth);\r\n                negativeNegativePixel = findPointOnLine(lastNegativePixel.x, lastNegativePixel.y, angle-PI/2, halfWidth);\r\n                \r\n                if (\r\n                    (shapeArray[floor(positivePositivePixel.x)] == undefined || shapeArray[floor(positivePositivePixel.x)][floor(positivePositivePixel.y)] !== 1) ||\r\n                    (shapeArray[floor(positiveNegativePixel.x)] == undefined || shapeArray[floor(positiveNegativePixel.x)][floor(positiveNegativePixel.y)] !== 1) ||\r\n                    (shapeArray[floor(negativePositivePixel.x)] == undefined || shapeArray[floor(negativePositivePixel.x)][floor(negativePositivePixel.y)] !== 1) ||\r\n                    (shapeArray[floor(negativeNegativePixel.x)] == undefined || shapeArray[floor(negativeNegativePixel.x)][floor(negativeNegativePixel.y)] !== 1)\r\n                ) {\r\n                    // Shorten maxLength and then recalculate lastPixels\r\n                    maxLength--;\r\n                    lastPositivePixel = findPointOnLine(centerX, centerY, angle, maxLength);\r\n                    lastNegativePixel = findPointOnLine(centerX, centerY, angle + PI, maxLength);\r\n                } else {\r\n                    widthFits = true;\r\n                }\r\n            }\r\n            // I added this if to debug something way after I originally wrote this, I think it is fine but not sure why I did not do this in the first place\r\n            if(!widthFits){\r\n                rotationAngle += PI/180;\r\n                angle += PI/180;\r\n            }\r\n        }\r\n\r\n        // We don't want points instead of lines\r\n        // We will retry this up to 3 times\r\n        if(maxLength<2) {\r\n            // We do t",
    "his to try to guarantee that a line moves left/right whenever any of them could\r\n            if(variablesGenerated && (setupVariables.mutation == \"lineMoveLeft\" || setupVariables.mutation == \"lineMoveRight\" || setupVariables.mutation == \"lineMoveUp\" || setupVariables.mutation == \"lineMoveDown\") && lineOrder[shuffledArrayIndex] == i && lineRetryArray[i] > 2){\r\n                shuffledArrayIndex++;\r\n                if(shuffledArrayIndex<lineOrder.length) {\r\n                    if(lineOrder[shuffledArrayIndex]>i) {\r\n                        i--;\r\n                    } else {\r\n                        i = lineOrder[shuffledArrayIndex]-1;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if((!variablesGenerated || setupVariables.mutation == \"linePositionChange\" || setupVariables.mutation == \"lineMoveLeft\" || setupVariables.mutation == \"lineMoveRight\" || setupVariables.mutation == \"lineMoveUp\" || setupVariables.mutation == \"lineMoveDown\") && lineRetryArray[i] < 3) {\r\n                i--;\r\n            }\r\n            continue;\r\n        }\r\n\r\n        // We normalize angle back to be > 0 and < PI and store the updated angle\r\n        angle = angle%PI;\r\n        setupVariables.lines[i].angle= angle;\r\n\r\n        // Pick a random length of the line lower than maxLength with a cap TBD and a floor because we don't want points instead of lines\r\n        let length = max(2,floor(lines[i].length*min(min(canvasHeight,canvasWidth)/6,maxLength)));\r\n\r\n        lastPositivePixel = findPointOnLine(centerX, centerY, angle, length);\r\n        lastNegativePixel = findPointOnLine(centerX, centerY, angle + PI, length);\r\n        positivePositivePixel = findPointOnLine(lastPositivePixel.x, lastPositivePixel.y, angle+PI/2, halfWidth);\r\n        positiveNegativePixel = findPointOnLine(lastPositivePixel.x, lastPositivePixel.y, angle-PI/2, halfWidth);\r\n        negativePositivePixel = findPointOnLine(lastNegativePixel.x, lastNegativePixel.y, angle+PI/2, halfWidth);\r\n        negativeNegativePixel = findPointOnLine(lastNegativePixel.x, lastNegativePixel.y, angle-PI/2, halfWidth);\r\n    \r\n        // Calculate all of the pixels in the line considering its width (\"ancho\") in pixels and that it will go half its length in either sense starting at the random point we picked following its angle.\r\n        // To do this, we will add to a lineBorder array all points that are on one of the line's 4 borders\r\n        let fullCorners = [\r\n        positivePositivePixel,\r\n        negativePositivePixel,\r\n        negativeNegativePixel,\r\n        positiveNegativePixel\r\n        ];\r\n        let northBorder = {\r\n        x1: positivePositivePixel.x,\r\n        y1: positivePositivePixel.y,\r\n        x2: negativePositivePixel.x,\r\n        y2: negativePositivePixel.y,\r\n        name: \"north\"\r\n        };\r\n        let southBorder = {\r\n        x1: positiveNegativePixel.x,\r\n        y1: positiveNegativePixel.y,\r\n        x2: negativeNegativePixel.x,\r\n        y2: negativeNegativePixel.y,\r\n        name: \"south\"\r\n        };\r\n        let leftBorder = {\r\n        x1: positiveNegativePixel.x,\r\n        y1: positiveNegativePixel.y,\r\n        x2: positivePositivePixel.x,\r\n        y2: positivePositivePixel.y,\r\n        name: \"left\"\r\n        };\r\n        let rightBorder = {\r\n        x1: negativeNegativePixel.x,\r\n        y1: negativeNegativePixel.y,\r\n        x2: negativePositivePixel.x,\r\n        y2: negativePositivePixel.y,\r\n        name: \"right\"\r\n        };\r\n        // When adding the pixels along each of these 4 borders, include their weight\r\n        let borders = [northBorder,rightBorder,southBorder,leftBorder];\r\n        let lineBorder = [];\r\n        let Pixels = [];\r\n        let borderOutsideShape = false;\r\n    \r\n        for (let j=0; j<borders.length;j++) {\r\n            let points = getPointsOnLine(borders[j],angle);\r\n            let pointsToPush = [];\r\n            for (let k = 0; k< points.length; k++){\r\n                let foundPoint = false;\r\n                for(let l = 0; l<lineBorder.length; l++) {\r\n                    if(\r\n                    lineBorder[l].x == points[k].x &&\r\n                    lineBorder[l].y == points[k].y\r\n                    ){\r\n                    foundPoint = true;\r\n                    let centerPoint = {};\r\n                    for (let m=0;m<fullCorners.length;m++){\r\n                        if(\r\n                            lineBorder[l].x == floor(fullCorners[m].x) &&\r\n                            lineBorder[l].y == floor(fullCorners[m].y)\r\n                        ){\r\n                        centerPoint = fullCorners[m];\r\n                        }\r\n                    }\r\n                    lineBorder[l].weight = calculateAreas(\r\n                        lineBorder[l].crossingPoints,\r\n                        points[k].crossingPoints,\r\n                        centerPoint)[0];\r\n                    }\r\n                    lineBorder[l].borderName = lineBorder[l].borderName+points[k].crossingPoints;\r\n                }\r\n                if(!foundPoint){\r\n                    if(shapeArray[points[k].x] == undefined ||\r\n                    shapeArray [points[k].x][points[k].y] != 1) {\r\n                        borderOutsideShape = true;\r\n                        continue;  \r\n                    }\r\n                    pointsToPush.push(points[k]);\r\n                }\r\n            }\r\n            lineBorder.push(...pointsToPush);\r\n        }\r\n        \r\n        // We don't want the shape border to overlap with the line - can happen if there is a big concavity with a peak right in the middle of the line\r\n        // However this should not happen because we started extending the line from the center, which must be inside the shape\r\n\r\n        // If this happens, we retry up to 3 times\r\n        if (borderOutsideShape) {\r\n            // We do this to try to guarantee that a line moves left/right whenever any of them could\r\n            if(variablesGenerated && (setupVariables.mutation == \"lineMoveLeft\" || setupVariables.mutation == \"lineMoveRight\" || setupVariables.mutation == \"lineMoveUp\" || setupVariables.mutation == \"lineMoveDown\") && lineOrder[shuffledArrayIndex] == i && lineRetryArray[i] > 2){\r\n                shuffledArrayIndex++;\r\n                if(shuffledArrayIndex<lineOrder.length) {\r\n                    if(lineOrder[shuffledArrayIndex]>i) {\r\n                        i--;\r\n                    } else {\r\n                        i = lineOrder[shuffledArrayIndex]-1;\r\n                    }\r\n                }\r\n            }\r\n\r\n            if((!variablesGenerated || setupVariables.mutation == \"linePositionChange\" || setupVariables.mutation == \"lineMoveLeft\" || setupVariables.mutation == \"lineMoveRight\" || setupVariables.mutation == \"lineMoveUp\" || setupVariables.mutation == \"lineMoveDown\") && lineRetryArray[i] < 3) {\r\n                i--;\r\n            }\r\n            continue;\r\n        }\r\n\r\n        // If we have successfully moved a line left/right, we persist the change\r\n        if(variablesGenerated && (setupVariables.mutation == \"lineMoveLeft\" || setupVariables.mutation == \"lineMoveRight\") && lineOrder[shuffledArrayIndex] == i){\r\n            setupVariables.lines[i].centerX = centerX/canvasWidth;\r\n        }\r\n\r\n        if(variablesGenerated && (setupVariables.mutation == \"lineMoveUp\" || setupVariables.mutation == \"lineMoveDown\") && lineOrder[shuffledArrayIndex] == i){\r\n            setupVariables.lines[i].centerY = centerY/canvasHeight;\r\n        }                      \r\n    \r\n        // Now we need to calculate an array of linePixels that are fully inside these borders\r\n        // We consider all points with a min and max X and min and max Y from the four corners that we calculated above\r\n        // We loop through these points and check if they are inside our line \"rectangle\"\r\n        let maxBorderX = ceil(Math.max(positivePositivePixel.x,negativePositivePixel.x,negativeNegativePixel.x,positiveNegativePixel.x));\r\n        let minBorderX = floor(Math.min(positivePositivePixel.x,negativePositivePixel.x,negativeNegativePixel.x,positiveNegativePixel.x));\r\n        let maxBorderY = ceil(Math.max(positivePositivePixel.y,negativePositivePixel.y,negativeNegativePixel.y,positiveNegativePixel.y));\r\n        let minBorderY = floor(Math.min(positivePositivePixel.y,negativePositivePixel.y,negativeNegativePixel.y,positiveNegativePixel.y));\r\n    \r\n        let linePixels = [];\r\n    \r\n        for (let j=minBorderX;j<=maxBorderX;j++) {\r\n            for (let k=minBorderY;k<=maxBorderY;k++) {\r\n                if(isPointInsidePolygon(j, k, borders)){\r\n                if(!lineBorder.some(\r\n                    point => isEqual(point, { x: j, y: k }\r\n                ))){\r\n                    linePixels.push({x:j,y:k});  \r\n                }\r\n                }\r\n            }\r\n        }\r\n        // We now have a linePixels array with pixels inside the line\r\n        // and a lineBorder array with pixels along the border\r\n        // Set the color of those pixels to black or gray/white just like for the circle\r\n        // TBD if we need different thresholds for lines\r\n        let antialiasThreshold = 75;\r\n        let antialiasThresholdDenominator = 75;\r\n        let antialiasSlope = 10;\r\n        if (gradientType==1){\r\n            antialiasThreshold = 110;\r\n            antialiasThresholdDenominator = 5500;\r\n            antialiasSlope = 1;\r\n        } else if (gradientType==2) {\r\n            antialiasThreshold = 220;    \r\n            antialiasThresholdDenominator = 220;\r\n            antialiasSlope = 0.5;\r\n        }\r\n    \r\n        for(let j=0; j<linePixels.length; j++) {\r\n        let targetPixel = linePixels[j];\r\n        let currentColor = color(\r\n            canvasArray[targetPixel.x][targetPixel.y].r,\r\n            canvasArray[targetPixel.x][targetPixel.y].g,\r\n            canvasArray[targetPixel.x][targetPixel.y].b,\r\n        );\r\n        \r\n        let colorDifference = dist(\r\n            red(currentColor),green(currentColor),blue(currentColor),\r\n            0,0,0\r\n        );\r\n        \r\n        let prevColorCloseToBlack = false;\r\n        let nextColorCloseToBlack = false;\r\n\r\n        if(\r\n            gradientType == 2 && \r\n            weightsArray[targetPixel.x][targetPixel.y] != 0\r\n        ){\r\n            let linesToRight = linesToRightArray[targetPixel.x][targetPixel.y];\r\n\r\n            // assuming 25 pixels should be enough to find a non-border\r\n            let nonBorderX = targetPixel.x;\r\n            for(let k=1; k<26; k++) {\r\n                nonBorderX++;\r\n                if(linesToRightArray[nonBorderX][targetPixel.y] == 0) {\r\n                    continue;\r\n                }\r\n            }\r\n\r\n\r\n            if (linesToRight == 0 || linesToRight == linesToRightArray[nonBorderX][targetPixel.y]) {\r\n                let prevColorDifference = dist(\r\n                    red(color(selectedcolors[linesToRight])),green(color(selectedcolors[linesToRight])),blue(color(selectedcolors[linesToRight])),\r\n                    0,0,0\r\n                );\r\n                let nextColorDifference = dist(\r\n                    red(color(selectedcolors[linesToRight+1])),green(color(selectedcolors[linesToRight+1])),blue(color(selectedcolors[linesToRight+1])),\r\n                    0,0,0\r\n                );\r\n\r\n                if (prevColorDifference<antialiasThreshold){\r\n                    prevColorCloseToBlack = true;\r\n                }\r\n                if (nextColorDifference<antialiasThreshold){\r\n                    nextColorCloseToBlack = true;\r\n                }\r\n            } else {\r\n                let prevColorDifference = dist(\r\n                    red(color(selectedcolors[linesToRight-1])),green(color(selectedcolors[linesToRight-1])),blue(color(selectedcolors[linesToRight-1])),\r\n                    0,0,0\r\n                );\r\n                let nextColorDifference = dist(\r\n                    red(color(selectedcolors[linesToRight])),green(color(selectedcolors[linesToRight])),blue(color(selectedcolors[linesToRight])),\r\n                    0,0,0\r\n                );\r\n\r\n                if (prevColorDifference<antialiasThreshold){\r\n                    prevColorCloseToBlack = true;\r\n                }\r\n                if (nextColorDifference<antialiasThreshold){\r\n                    nextColorCloseToBlack = true;\r\n                }\r\n            }\r\n\r\n            if (prevColorCloseToBlack != nextColorCloseToBlack) {\r\n                let newWhiteColor = lerpColor(color(255,255,255),color(0,0,0),weightsArray[targetPixel.x][targetPixel.y]);\r\n\r\n                if (nextColorCloseToBlack) {\r\n                    newWhiteColor = lerpColor(color(0,0,0),color(255,255,255),weightsArray[targetPixel.x][targetPixel.y]);\r\n                }\r\n            \r\n                canvasArray[targetPixel.x][targetPixel.y] = {\r\n                    r: red(newWhiteColor),\r\n                    g: green(newWhiteColor),\r\n                    b: blue(newWhiteColor),\r\n                };\r\n                continue;\r\n            }\r\n\r\n        }\r\n\r\n        if (\r\n            bordersArray[targetPixel.x][targetPixel.y] !== 1\r\n        ) {\r\n\r\n            let originalColor = color(\r\n                preShapesCanvasArray[targetPixel.x][targetPixel.y].r,\r\n                preShapesCanvasArray[targetPixel.x][targetPixel.y].g,\r\n                preShapesCanvasArray[targetPixel.x][targetPixel.y].b\r\n            );\r\n            let originalColorDifference = dist(\r\n                red(originalColor),green(originalColor),blue(originalColor),\r\n                0,0,0\r\n            );\r\n        \r\n            let newColor = lerpColor(\r\n                    color(255,255,255),\r\n                    color(0,0,0),\r\n                    bordersArray[targetPixel.x][targetPixel.y]\r\n            );\r\n\r\n            if (originalColorDifference<antialiasThreshold) {\r\n                let midThreshold = antialiasThreshold-antialiasSlope*2;\r\n\r\n                let newWhiteColor = lerpColor(color(255,255,255),color(0,0,0),\r\n                    (Math.exp((originalColorDifference - midThreshold) / antialiasSlope) - Math.exp(-(originalColorDifference - midThreshold) / antialiasSlope)) /\r\n                    (Math.exp((originalColorDifference - midThreshold) / antialiasSlope) + Math.exp(-(originalColorDifference - midThreshold) / antialiasSlope))\r\n                    * 0.5 + 0.5\r\n                );\r\n\r\n                newColor = lerpColor(\r\n                    color(0,0,0),\r\n                    color(red(newWhiteColor),green(newWhiteColor),blue(newWhiteColor)),\r\n                    bordersArray[targetPixel.x][targetPixel.y]\r\n                );\r\n            }\r\n        \r\n            canvasArray[targetPixel.x][targetPixel.y] = {\r\n                r: red(newColor),\r\n                g: green(newColor),\r\n                b: blue(newColor),\r\n            };\r\n        } else if (colorDifference<antialiasThreshold && (weightsArray[targetPixel.x][targetPixel.y] === 0 || (gradientType != 2 || setupVariables.dividerCount === 0 || prevColorCloseToBlack !== nextColorCloseToBlack || (prevColorCloseToBlack && nextColorCloseToBlack)))) {\r\n            let midThreshold = antialiasThreshold-antialiasSlope*2;\r\n\r\n            let newWhiteColor = lerpColor(color(255,255,255),color(0,0,0),\r\n                (Math.exp((colorDifference - midThreshold) / antialiasSlope) - Math.exp(-(colorDifference - midThreshold) / antialiasSlope)) /\r\n                (Math.exp((colorDifference - midThreshold) / antialiasSlope) + Math.exp(-(colorDifference - midThreshold) / antialiasSlope))\r\n                * 0.5 + 0.5\r\n            );\r\n        \r\n            canvasArray[targetPixel.x][targetPixel.y] = {\r\n                r: red(newWhiteColor),\r\n                g: green(newWhiteColor),\r\n                b: blue(newWhiteColor),\r\n            };\r\n        } else {\r\n            canvasArray[targetPixel.x][targetPixel.y] = {\r\n                r: 0,\r\n                g: 0,\r\n                b: 0,\r\n            };\r\n        }\r\n        }\r\n    \r\n        // Once line is full, we need to smooth out jagged lines\r\n        if(gradientType != 2){\r\n            //antiAliasShapeFill(linePixels);\r\n        }\r\n    \r\n        // Set the color of the border pixels by antialiasing just like for the circles\r\n\r\n        for(let j=0; j<lineBorder.length; j++) {\r\n            let targetPixel = lineBorder[j];\r\n            let previousBorder = 0.5;\r\n            \r\n            if(canvasArray[targetPixel.x] == undefined ||\r\n                canvasArray[targetPixel.x][targetPixel.y] == undefined\r\n            ) {continue;}\r\n            \r\n            let currentRed = canvasArray[targetPixel.x][targetPixel.y].r;\r\n            let currentGreen = canvasArray[targetPixel.x][targetPixel.y].g;\r\n            let currentBlue = canvasArray[targetPixel.x][targetPixel.y].b;\r\n            \r\n            if(bordersArray[targetPixel.x][targetPixel.y] === 1 ) {\r\n                bordersArray[targetPixel.x][targetPixel.y] = targetPixel.weight;\r\n            } else {\r\n                bordersArray[targetPixel.x][targetPixel.y] = min(bordersArray[targetPixel.x][targetPixel.y],targetPixel.weight);\r\n            }\r\n\r\n            // If on gradient type 2 and a divider, we need to be stricter for borders that are part of a divider line\r\n            if (gradientType==2 && weightsArray[targetPixel.x][targetPixel.y] !== 0) {\r\n                previousBorder = 1;\r\n            }\r\n\r\n            let colorDifference = dist(\r\n                currentRed,\r\n                currentGreen,\r\n                currentBlue,\r\n                0,0,0\r\n            );\r\n        \r\n        if (colorDifference<(antialiasThreshold/(2*previousBorder))) {\r\n            let midThreshold = (antialiasThreshold/(2*previousBorder))-antialiasSlope*2;\r\n\r\n            let newWhiteColor = lerpColor(color(255,255,255),color(0,0,0),\r\n                (Math.exp((colorDifference - midThreshold) / antialiasSlope) - Math.exp(-(colorDifference - midThreshold) / antialiasSlope)) /\r\n                (Math.exp((colorDifference - midThreshold) / antialiasSlope) + Math.exp(-(colorDifference - midThreshold) / antialiasSlope))\r\n                * 0.5 + 0.5\r\n            );\r\n\r\n            let newColor = lerpColor(\r\n                newWhiteColor,\r\n                color(currentRed,currentGreen,currentBlue),\r\n                bordersArray[targetPixel.x][targetPixel.y]\r\n            );\r\n\r\n            canvasArray[targetPixel.x][targetPixel.y] = {\r\n                r: red(newColor),\r\n                g: green(newColor),\r\n                b: blue(newColor),\r\n            };\r\n        } else {\r\n            let newColor = lerpColor(\r\n                color(0,0,0),\r\n                color(currentRed,currentGreen,currentBlue),\r\n                bordersArray[targetPixel.x][targetPixel.y]\r\n            );\r\n\r\n            canvasArray[targetPixel.x][targetPixel.y] = {\r\n                r: red(newColor),\r\n                g: green(newColor),\r\n                b: blue(newColor),\r\n            };\r\n        }\r\n        }\r\n    }\r\n    \r\n    \r\n    // Loop through each pixel in the matchingPixels array this time to set adjusted colors and setPixelColor on the canvas\r\n    for (let i = 0; i < matchingPixels.length; i++) {\r\n        let pixel = matchingPixels[i];\r\n        let pixelData = canvasArray[pixel.x][pixel.y];\r\n        let pixelColor = color(pixelData.r,pixelData.g,pixelData.b);\r\n\r\n        setPixelColor(pixel.x, pixel.y, pixelColor);\r\n    }\r\n    \r\n    updatePixels();\r\n    if(variablesGenerated) {\r\n        setupVariables.changeHistory.push(getOriginalValues(initalVariablesObj,setupVariables));\r\n    } else {\r\n        setupVariablesCopy = structuredClone(setupVariables);\r\n        setupVariables.initialVariables = setupVariablesCopy;\r\n    }\r\n    console.log(setupVariables);\r\n}\r\n\r\n// Function to calculate the distance from a point (x, y) to a line\r\nfunction distToLine(x, y, line) {\r\n    let x1 = line.x1;\r\n    let y1 = line.y1;\r\n    let x2 = line.x2;\r\n    let y2 = line.y2;\r\n\r\n    let numer = abs((y2 - y1) * x - (x2 - x1) * y + x2 * y1 - y2 * x1);\r\n    let denom = dist(x1, y1, x2, y2);\r\n    return numer / denom;\r\n}\r\n\r\n// Function to find surrounding pixels within a certain radius\r\nfunction findSurroundingPixels(pixel, pixelArray, radius = 1, withinShape = 0, maskArray = shapeArray) {\r\n    let result = [];\r\n    for(let i = -radius;i<=radius;i++){\r\n        for (let j = -radius; j<=radius;j++){\r\n            if(pixelArray &&\r\n            pixelArray[i+pixel.x] &&\r\n            pixelArray[i+pixel.x][j+pixel.y] &&\r\n                (i+j)!=0 &&\r\n                i+pixel.x>=0 &&\r\n                j+pixel.y>=0 &&\r\n                j+pixel.y<pixelArray[i+pixel.x].length)\r\n            {\r\n                if (withinShape === 0 || maskArray[i+pixel.x][j+pixel.y] === 1){\r\n                result.push(pixelArray[i+pixel.x][j+pixel.y]);    \r\n                }\r\n            }\r\n        }\r\n    }\r\n    return result;\r\n}\r\n\r\n// Function to calculate the average color component (r, g, or b) of an array of pixels\r\nfunction calculateAverageColorComponent(pixels, component) {\r\n    if ( pixels.length == 0) {\r\n        return 0;  \r\n    }\r\n    \r\n    let total = 0;\r\n    for (let i = 0; i < pixels.length; i++) {\r\n        total += pixels[i][component];\r\n    }\r\n    return total / pixels.length;\r\n}\r\n\r\n\r\nfunction setPixelColor(x, y, color) {\r\n    let pixelIndex = (x + y * width) * 4; // Calculate the pixel index in the pixel array\r\n\r\n    // Set the color of the pixel\r\n    pixels[pixelIndex] = red(color);\r\n    pixels[pixelIndex + 1] = green(color);\r\n    pixels[pixelIndex + 2] = blue(color);\r\n    pixels[pixelIndex + 3] = 255; // Alpha value (fully opaque)\r\n\r\n    canvasArray[x][y] = {\r\n        r: red(color),\r\n        g: green(color),\r\n        b: blue(color),\r\n    };\r\n}\r\n\r\nfunction findFirstLineToRightDistance(pixel, direction) {\r\n    let minDist = Infinity;\r\n    let maximumX = canvasWidth;\r\n    let lineIndex = 0;\r\n    if (direction == -1){\r\n        maximumX = 0;\r\n    }\r\n    // Loop through each line in previousLines and find the intersection point with a ray cast from our point to the right end of the canvas (or left, if we reverse directions)\r\n    // If there is an intersection point and it is the smallest so far, update minDist\r\n    for (let j = 0; j < previousLines.length; j++) {\r\n        let line = previousLines[j];\r\n        let intersectionPoint = findIntersectionAnywhere(pixel.x, pixel.y, maximumX, pixel.y, line.x1, line.y1, line.x2, line.y2,direction);\r\n\r\n        if (intersectionPoint) {\r\n            //We do not want the shortest distance to the line, just the horizontal distance to the line\r\n            let dist = abs(pixel.x - intersectionPoint.x);\r\n            if (dist < minDist) {\r\n                minDist = dist;\r\n                lineIndex = j;\r\n            }\r\n        }\r\n    }\r\n\r\n    return [minDist,lineIndex];\r\n}\r\n\r\nfunction countLinesToRight(pixel) {\r\n    let linesToRight = 0;\r\n    let borderWeight = 0;\r\n\r\n    // Loop through each line in previousLines\r\n    for (let j = 0; j < previousLines.length; j++) {\r\n        let line = previousLines[j];\r\n\r\n        // Check if the pixel is to the left of the line\r\n        if (\r\n        pixel.x < line.x1 + (pixel.y - line.y1) / (line.y2-line.y1) * (line.x2 - line.x1)\r\n        ) {\r\n        linesToRight++;\r\n        // Check if next pixel is at less than 1 pixel away from the line\r\n            if (distToLine(pixel.x, pixel.y, line)<1) {\r\n                //If so, that means we are a border\r\n                borderWeight = distToLine(pixel.x, pixel.y, line);\r\n            }\r\n        }\r\n    }\r\n\r\n    return [linesToRight,borderWeight];\r\n}\r\n\r\n\r\nfunction checkIfRight(pixel,line) {\r\n    let isPixelRight = true;\r\n\r\n        // Check if the pixel is to the le",
    "ft of the line\r\n        if (\r\n        pixel.x < line.x1 + (pixel.y - line.y1) / (line.y2-line.y1) * (line.x2 - line.x1)\r\n        ) {\r\n        isPixelRight = false;\r\n        }\r\n\r\n    return isPixelRight;\r\n}\r\n\r\nfunction drawLine(startX, initialAngle, minAngle, maxAngle) {\r\n    let diagonal = ceil((canvasHeight**2+canvasWidth**2)**0.5);\r\n    let angle = adjustAngle(startX,initialAngle,minAngle,maxAngle,diagonal);\r\n\r\n    if(angle == null) {\r\n        return;\r\n    }\r\n\r\n    let endX = startX + cos(angle) * diagonal;\r\n    let endY = sin(angle) * diagonal;\r\n    \r\n    // If there are no intersections with previous lines, draw the line and store it in previousLines\r\n    //line(startX, 0, endX, endY);\r\n    previousLines.push({ x1: startX, y1: 0, x2: endX, y2: endY });\r\n}\r\n\r\n\r\nfunction adjustAngle(startX,initialAngle,minAngle,maxAngle,diagonal){\r\n    let lineLength = diagonal; // Adjust the length as needed, should be at least canvas diagonal\r\n    let angle = initialAngle;\r\n    let intersection = 0;\r\n    let minReached = false;\r\n    \r\n    while (intersection == 0){\r\n        intersection = 1;\r\n        let endX = startX + cos(angle) * lineLength;\r\n        let endY = sin(angle) * lineLength;\r\n        // Check for intersections with previously drawn lines\r\n        for (let i = 0; i < previousLines.length; i++) {\r\n            let existingLine = previousLines[i];\r\n            let intersectionPoint = findIntersection(startX, 0, endX, endY, existingLine.x1, existingLine.y1, existingLine.x2, existingLine.y2);\r\n        \r\n            if (intersectionPoint && pointInMatchingPixels(intersectionPoint)) {\r\n                intersection = intersection * 0;\r\n            } else {\r\n                intersection = intersection * 1;\r\n            }\r\n        }\r\n        \r\n        if(intersection == 1){\r\n            break;\r\n        }\r\n        \r\n        if(angle > minAngle && !minReached){\r\n            angle -= 0.02;\r\n            angle = Math.max(angle,minAngle);\r\n        } else {\r\n            if (!minReached){\r\n                minReached = true;\r\n                angle = initialAngle + 0.02\r\n            } else {\r\n                angle += 0.02;\r\n                angle = Math.min(angle,maxAngle);\r\n            }\r\n        }\r\n        \r\n        if(angle > maxAngle){\r\n            //we did not manage to find a possible line\r\n            return null;\r\n        }\r\n    }\r\n    \r\n    return angle;\r\n}\r\n\r\nfunction pointInMatchingPixels(point) {\r\n    // Check if the point is within matchingPixels\r\n    for (let i = 0; i < matchingPixels.length; i++) {\r\n        let existingPoint = matchingPixels[i];\r\n        if (dist(point.x, point.y, existingPoint.x, existingPoint.y) < 1) {\r\n        return true;\r\n        }\r\n    }\r\n    return false;\r\n}\r\n\r\nfunction findIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {\r\n    // Calculate the intersection point of two lines\r\n    let denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\r\n\r\n    if (denominator === 0) {\r\n        return null; // Lines are parallel or coincident\r\n    }\r\n\r\n    // We round to avoid results like 63.00000000000001 instead of 63\r\n    let intersectionX = round(((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denominator,12);\r\n    let intersectionY = round(((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denominator,12);\r\n\r\n    // Check if the intersection point is on the line segments\r\n    if (\r\n        intersectionX >= Math.min(x1, x2) &&\r\n        intersectionX <= Math.max(x1, x2) &&\r\n        intersectionY >= Math.min(y1, y2) &&\r\n        intersectionY <= Math.max(y1, y2) &&\r\n        intersectionX >= Math.min(x3, x4) &&\r\n        intersectionX <= Math.max(x3, x4) &&\r\n        intersectionY >= Math.min(y3, y4) &&\r\n        intersectionY <= Math.max(y3, y4)\r\n    ) {\r\n        return createVector(intersectionX, intersectionY);\r\n    }\r\n\r\n    return null; // Intersection point is outside the line segments\r\n}\r\n\r\nfunction findIntersectionAnywhere(x1, y1, x2, y2, x3, y3, x4, y4,direction = 1) {\r\n    // Calculate the intersection point of two lines\r\n    let denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);\r\n\r\n    if (denominator === 0) {\r\n        return null; // Lines are parallel or coincident\r\n    }\r\n\r\n    let intersectionX = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denominator;\r\n    let intersectionY = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denominator;\r\n\r\n        // Check only if the intersection point is in the desired direction\r\n    if (\r\n        (direction == 1 && intersectionX >= x1) ||\r\n        (direction == -1 && intersectionX <= x1)\r\n    ) {\r\n        return createVector(intersectionX, intersectionY);\r\n    }\r\n\r\n    return null; // Intersection point is outside the line segments\r\n}\r\n\r\n\r\nfunction findNextUnconnectedSeed(currentSeed, seedpoints, connectedLeftEdges, connectedRightEdges, currentIndex) {\r\n    let nextSeedIndex = -1;\r\n\r\n    for (let i = 0; i < seedpoints.length; i++) {\r\n        let adjustedIndex = (currentIndex + i) % seedpoints.length;\r\n        if (!connectedLeftEdges[adjustedIndex] && adjustedIndex !== currentIndex && !connectedRightEdges[adjustedIndex]) {\r\n        nextSeedIndex = adjustedIndex;\r\n        return nextSeedIndex;\r\n        }\r\n    }\r\n    return nextSeedIndex;\r\n}\r\n\r\nfunction findCentralPoint(points) {\r\n    let centralX = 0;\r\n    let centralY = 0;\r\n\r\n    for (let point of points) {\r\n        centralX += point.x;\r\n        centralY += point.y;\r\n    }\r\n\r\n    return {\r\n        x: centralX / points.length,\r\n        y: centralY / points.length,\r\n    };\r\n}\r\n\r\nfunction generateSeedpoints(baseRadius) {\r\n    // Mean for the Poisson distribution\r\n    let mean = 8;\r\n\r\n    // Generate a random number of seedpoints from 5 to 20\r\n    if(!variablesGenerated){\r\n        setupVariables.numSeedpoints = constrain(floor(randomGaussian(mean, sqrt(mean))), 5, 20);\r\n    } else if(setupVariables.mutation == \"seedPointCountIncrease\" && setupVariables.numSeedpoints < 20){\r\n        setupVariables.numSeedpoints++;\r\n    } else if(setupVariables.mutation == \"seedPointCountDecrease\" && setupVariables.numSeedpoints > 5){\r\n        setupVariables.numSeedpoints--;\r\n        let randomIndex = floor(random(setupVariables.seedpoints.length));\r\n        setupVariables.seedpoints.splice(randomIndex,1);\r\n    }\r\n\r\n    numSeedpoints = setupVariables.numSeedpoints;\r\n\r\n    // Generate seedpoints\r\n    let radius = baseRadius;\r\n    let targetSeedpoint = -1;\r\n\r\n    if(variablesGenerated && setupVariables.mutation.includes(\"seedpoint\")) {\r\n        if (setupVariables.mutation.includes(\"-\")) {\r\n            let splitMutation = setupVariables.mutation.split(\"-\");\r\n            setupVariables.mutation = splitMutation[0];\r\n            let zone = splitMutation[1];\r\n            let classifiedPoints = {\r\n                \"top\": [],\r\n                \"bottom\": [],\r\n                \"left\": [],\r\n                \"right\": []\r\n            }\r\n\r\n            // Find the centroid of the points\r\n            let points =  setupVariables.seedpoints.map(item => ({\r\n                x: item.x,\r\n                y: item.y,\r\n            }));\r\n\r\n            const centroid = points.reduce((acc, point) => ({ x: acc.x + point.x, y: acc.y + point.y }), { x: 0, y: 0 });\r\n            centroid.x /= points.length;\r\n            centroid.y /= points.length;\r\n\r\n            for (let i=0; i<setupVariables.seedpoints.length; i++) {\r\n                if(setupVariables.seedpoints[i].x > centroid.x) {\r\n                    classifiedPoints.right.push(i);\r\n                } else { \r\n                    classifiedPoints.left.push(i);\r\n                }\r\n                \r\n                if(setupVariables.seedpoints[i].y > centroid.y) {\r\n                    classifiedPoints.bottom.push(i);\r\n                } else { \r\n                    classifiedPoints.top.push(i);\r\n                }\r\n            }\r\n\r\n            let possibleIndices = classifiedPoints[zone];\r\n\r\n            targetSeedpoint = possibleIndices[floor(random(possibleIndices.length))];\r\n        } else {\r\n            targetSeedpoint = floor(random(setupVariables.numSeedpoints));\r\n        }\r\n    }\r\n\r\n    for (let i = 0; i < numSeedpoints; i++) {\r\n        if (!setupVariables.seedpoints[i]) {\r\n            let radiusIncrease = random(1,PI);\r\n            radius = baseRadius * radiusIncrease;\r\n            let x = random(radius, canvasWidth - radius)/canvasWidth;\r\n            let y = random(radius, canvasHeight - radius)/canvasHeight;\r\n        \r\n            // Generate two additional values\r\n            let curvature = random(0.5, 1.5);\r\n            let percentageDistance = round(random(0, 1), 7);\r\n            //setupVariables.seedpoints[i] = [];\r\n\r\n            setupVariables.seedpoints[i] = { x, y, curvature, percentageDistance, radiusIncrease };\r\n        } else if (i == targetSeedpoint) {\r\n            switch (setupVariables.mutation) {\r\n                case \"seedpointMoveRight\":\r\n                    radius = baseRadius * setupVariables.seedpoints[i].radiusIncrease;\r\n                    setupVariables.seedpoints[i].x = random(setupVariables.seedpoints[i].x*canvasWidth, canvasWidth - radius)/canvasWidth;\r\n                    break;\r\n                case \"seedpointMoveLeft\":\r\n                    radius = baseRadius * setupVariables.seedpoints[i].radiusIncrease;\r\n                    setupVariables.seedpoints[i].x = random(radius, setupVariables.seedpoints[i].x*canvasWidth)/canvasWidth;\r\n                    break;\r\n                case \"seedpointMoveUp\":\r\n                    radius = baseRadius * setupVariables.seedpoints[i].radiusIncrease;\r\n                    setupVariables.seedpoints[i].y = random(radius, setupVariables.seedpoints[i].y*canvasHeight)/canvasHeight;\r\n                    break;\r\n                case \"seedpointMoveDown\":\r\n                    radius = baseRadius * setupVariables.seedpoints[i].radiusIncrease;\r\n                    setupVariables.seedpoints[i].y = random(setupVariables.seedpoints[i].y*canvasHeight, canvasHeight - radius)/canvasHeight;\r\n                    break;\r\n                case \"seedpointChangeCurveCenter\":\r\n                    setupVariables.seedpoints[i].percentageDistance = round(random(0, 1), 7);\r\n                    break;\r\n                case \"seedpointIncreaseConcavity\":\r\n                    setupVariables.seedpoints[i].curvature = min(2,random(setupVariables.seedpoints[i].curvature*1.1, 1.5));\r\n                    break;\r\n                case \"seedpointDecreaseConcavity\":\r\n                    setupVariables.seedpoints[i].curvature = max(0.375,random(0.5, setupVariables.seedpoints[i].curvature/1.1));\r\n                    break;\r\n                case \"seedpointIncreaseRadius\":\r\n                    setupVariables.seedpoints[i].radiusIncrease = random(setupVariables.seedpoints[i].radiusIncrease*1.1,PI);\r\n                    //an increase might push us out of the canvas, we need to double check. A decrease never will.\r\n                    radius = baseRadius * setupVariables.seedpoints[i].radiusIncrease;\r\n                    if((setupVariables.seedpoints[i].x*canvasWidth + radius) > canvasWidth) {\r\n                        setupVariables.seedpoints[i].radiusIncrease = (canvasWidth - setupVariables.seedpoints[i].x*canvasWidth)/baseRadius;\r\n                    };\r\n                    if((setupVariables.seedpoints[i].x*canvasWidth - radius) < 0) {\r\n                        setupVariables.seedpoints[i].radiusIncrease = (setupVariables.seedpoints[i].x*canvasWidth)/baseRadius;\r\n                    };\r\n                    if((setupVariables.seedpoints[i].y*canvasHeight + radius) > canvasHeight) {\r\n                        setupVariables.seedpoints[i].radiusIncrease = (canvasHeight - setupVariables.seedpoints[i].y*canvasHeight)/baseRadius;\r\n                    };\r\n                    if((setupVariables.seedpoints[i].y*canvasHeight - radius) < 0) {\r\n                        setupVariables.seedpoints[i].radiusIncrease = (setupVariables.seedpoints[i].y*canvasHeight)/baseRadius;\r\n                    };\r\n                    break;\r\n                case \"seedpointDecreaseRadius\":\r\n                    setupVariables.seedpoints[i].radiusIncrease = random(1,setupVariables.seedpoints[i].radiusIncrease/1.1);\r\n                    break;\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction drawSemicircle(x, y, radius, centralPoint) {\r\n    push();\r\n    translate(x, y);\r\n\r\n    // Calculate the angle to face the edges of the canvas\r\n    let angle = atan2(centralPoint.y - y, centralPoint.x - x) + PI / 2;\r\n\r\n    rotate(angle);\r\n\r\n    // Draw a half circle (180 degrees) using the arc function\r\n    arc(0, 0, radius * 2, radius * 2, 0, PI);\r\n    pop();\r\n}\r\n\r\nfunction findConvexHull(relativePoints) {\r\n    // Find the centroid of the points\r\n    let points =  relativePoints.map(item => ({\r\n        x: item.x * canvasWidth,\r\n        y: item.y * canvasHeight,\r\n        curvature: item.curvature * maxCurvature,\r\n        percentageDistance: item.percentageDistance,\r\n        radiusIncrease: item.radiusIncrease\r\n    }));\r\n\r\n    const centroid = points.reduce((acc, point) => ({ x: acc.x + point.x, y: acc.y + point.y }), { x: 0, y: 0 });\r\n    centroid.x /= points.length;\r\n    centroid.y /= points.length;\r\n\r\n    // Sort the points based on polar angle with respect to the centroid\r\n    points.sort((a, b) => {\r\n        const angleA = Math.atan2(a.y - centroid.y, a.x - centroid.x);\r\n        const angleB = Math.atan2(b.y - centroid.y, b.x - centroid.x);\r\n        return angleA - angleB;\r\n    });\r\n\r\n    return points;\r\n}\r\n\r\n// Function to draw an arc with a peak at a certain percentage of the distance between two points\r\nfunction drawArc(startX, startY, endX, endY, controlX, controlY) {\r\n    vertex(startX, startY);\r\n    quadraticVertex(controlX, controlY, endX, endY);\r\n}\r\n\r\n// Function to apply antialiasing to pixel colors stored in canvasArray\r\nfunction applyAntialiasing(radius,inShape = true,restrict = false, includedPoints=[]) {\r\n\r\n    if(floor(radius) == 0) {\r\n        return;\r\n    }\r\n\r\n    let tempCanvasArray = structuredClone(canvasArray); // Create a copy of the original canvasArray\r\n\r\n    // Loop through each pixel in the canvasArray\r\n    for (let x = 0; x < canvasWidth; x++) {\r\n        for (let y = 0; y < canvasHeight; y++) {\r\n            let pixel = canvasArray[x][y];\r\n            if(inShape && !shapeArray[x][y]){\r\n                continue;\r\n            }\r\n            if(restrict && !includedPoints.some(point => isEqual(point, { x: x, y: y }))) {\r\n                continue;  \r\n            }\r\n\r\n            if (pixel !== undefined) {\r\n                // Find surrounding pixels within a certain radius\r\n                let surroundingPixels = findSurroundingPixels({ x, y }, tempCanvasArray, radius, 1);\r\n\r\n                // Calculate the average values for red, green, and blue\r\n                let avgRed = calculateAverageColorComponent(surroundingPixels, 'r');\r\n                let avgGreen = calculateAverageColorComponent(surroundingPixels, 'g');\r\n                let avgBlue = calculateAverageColorComponent(surroundingPixels, 'b');\r\n\r\n                // Update the pixel color in canvasArray\r\n                canvasArray[x][y] = {\r\n                r: avgRed,\r\n                g: avgGreen,\r\n                b: avgBlue,\r\n                };\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction applyGradients(subArrays,interpolationFactorsArrays,selectedColors,splitFlagsArray) {\r\n    // We loop through each pixel in each subarray\r\n    for (let i = 0;i<subArrays.length; i++) {\r\n        // We calculate the start and end color that this subarray should have\r\n        let startColor = selectedColors[i];\r\n        let endColor = selectedColors[i+1];\r\n\r\n        for(let j = 0; j < subArrays[i].length; j++) {\r\n            let pixel = subArrays[i][j];\r\n            \r\n            if(i == (subArrays.length-1)) {\r\n            startColor = selectedColors[selectedColors.length-2];\r\n            endColor = selectedColors[selectedColors.length-1];\r\n            } else if (i > 0) {\r\n            if(splitFlagsArray[i][j] == -1){\r\n                startColor = selectedColors[i*2-1];\r\n                endColor = selectedColors[i*2];\r\n            } else if (splitFlagsArray[i][j] == 1) {\r\n                startColor = selectedColors[i*2];\r\n                endColor = selectedColors[i*2+1];    \r\n            } else {\r\n                startColor = selectedColors[i*2];\r\n                endColor = selectedColors[i*2];\r\n            }\r\n            }\r\n        \r\n            let lerpFactor = interpolationFactorsArrays[i][j];\r\n            // Calculate the r, g and b coponents of this pixel using its interpolationFactor\r\n            // if we are in the rightmost section we need to invert the factor because distances were calculated backwards so 100% is the end and not the start\r\n            if(i==0 || splitFlagsArray[i][j] == 1) { lerpFactor = 1-lerpFactor;}\r\n            \r\n        \r\n            let newColor = lerpColor(startColor,endColor,lerpFactor);\r\n            // Set the new canvasArray color\r\n            canvasArray[pixel.x][pixel.y] = {\r\n                r: red(newColor),\r\n                g: green(newColor),\r\n                b: blue(newColor),\r\n            }\r\n        }\r\n    }\r\n}\r\n\r\nfunction findLinearRegression(points) {\r\n    let sumX = 0;\r\n    let sumY = 0;\r\n    let sumXY = 0;\r\n    let sumX2 = 0;\r\n\r\n    for (let i = 0; i < points.length; i++) {\r\n        sumX += points[i].x;\r\n        sumY += points[i].y;\r\n        sumXY += points[i].x * points[i].y;\r\n        sumX2 += points[i].x ** 2;\r\n    }\r\n\r\n    let n = points.length;\r\n    let m = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX ** 2);\r\n    let b = (sumY - m * sumX) / n;\r\n\r\n    return { m, b };\r\n}\r\n\r\nfunction calculateGoodnessOfFit(points, linearRegression) {\r\n    let sumSquaredErrors = 0;\r\n\r\n    for (let i = 0; i < points.length; i++) {\r\n        let predictedY = linearRegression.m * points[i].x + linearRegression.b;\r\n        let error = points[i].y - predictedY;\r\n        sumSquaredErrors += error ** 2;\r\n    }\r\n\r\n    let meanY = points.reduce((sum, point) => sum + point.y, 0) / points.length;\r\n    let totalSumOfSquares = points.reduce((sum, point) => sum + (point.y - meanY) ** 2, 0);\r\n\r\n    // R-squared value\r\n    let rSquared = 1 - sumSquaredErrors / totalSumOfSquares;\r\n\r\n    return rSquared;\r\n}\r\n\r\nfunction calculatePixelsInsideCircle(cx, cy, r) {\r\n    let includedPixels = [];\r\n    let borderPixels = [];\r\n    let startX = max(0,cx-r-1);\r\n    let endX = min(width,cx+r+1);\r\n    let startY = max(0,cy-r-1);\r\n    let endY = min(height,cy+r+1);\r\n    \r\n    for (let x = startX; x <= endX; x++) {\r\n        for (let y = startY; y <= endY; y++) {\r\n        // Calculate distance from the center of the circle\r\n        let d = dist(x, y, cx, cy);\r\n        // If the distance is less than the radius, the pixel is inside the circle\r\n        if (d < r) {\r\n            if (canvasArray[x] == undefined || canvasArray[x][y] == undefined || shapeArray[x][y] != 1) {\r\n                return null;    \r\n            }\r\n                includedPixels.push({\r\n                x:x,\r\n                y:y\r\n            });\r\n        } else if (floor(d)<=r) {\r\n            if (canvasArray[x] == undefined || canvasArray[x][y] == undefined || shapeArray[x][y] != 1) {\r\n                return null;    \r\n            }\r\n            borderPixels.push({\r\n                x:x,\r\n                y:y,\r\n                weight: d-floor(d)\r\n            });  \r\n        }\r\n        }\r\n    }\r\n    return [includedPixels,borderPixels];\r\n}\r\n\r\nfunction isEqual(obj1, obj2) {\r\n    return obj1.x === obj2.x && obj1.y === obj2.y;\r\n}\r\n\r\nfunction findPointOnLine(x1, y1, angle, distance) {\r\n    let x2 = x1 + distance * cos(angle);\r\n    let y2 = y1 + distance * sin(angle);\r\n    return createVector(x2, y2);\r\n}\r\n\r\nfunction getPointsOnLine(line, angle) {\r\n    let points = [];\r\n    \r\n    let minimumX = floor(min(line.x1,line.x2));\r\n    let maximumX = ceil(max(line.x1,line.x2));\r\n    let minimumY = floor(min(line.y1,line.y2));\r\n    let maximumY = ceil(max(line.y1,line.y2));\r\n\r\n    for(let i = minimumX; i <= maximumX; i++) {\r\n        for(let j = minimumY; j <= maximumY; j++){\r\n        //Treat the pixel like a small square and check if the line crosses it\r\n        let pixelBorderLines = [\r\n            {x1: i, y1: j, x2: i+1, y2:j},\r\n            {x1: i+1, y1: j, x2: i+1, y2:j+1},\r\n            {x1: i+1, y1: j+1, x2: i, y2:j+1},\r\n            {x1: i, y1: j+1, x2: i, y2:j}\r\n        ];\r\n        let lineCrosses = false;\r\n        let intersections = [];\r\n        \r\n        for(let k=0; k< pixelBorderLines.length; k++) {\r\n            let intersection = findIntersection(\r\n            pixelBorderLines[k].x1, pixelBorderLines[k].y1,\r\n            pixelBorderLines[k].x2, pixelBorderLines[k].y2,\r\n            line.x1, line.y1,\r\n            line.x2, line.y2\r\n            )\r\n            if (intersection != null){\r\n            lineCrosses = true;\r\n            intersections.push({\r\n                x: intersection.x,\r\n                y: intersection.y,\r\n                x0: i,\r\n                y0: j,\r\n            });\r\n            }\r\n        }\r\n        \r\n        if(lineCrosses) {\r\n            // Calculate area of the pixel that is black assuming that only one line crosses it\r\n            let outsideArea = 1;\r\n            if(intersections.length == 2){\r\n            let topLeftCornerArea = calculateSimpleAreas(i,j,intersections[0],intersections[1],true)[0];\r\n            let topRightCornerArea = calculateSimpleAreas(i+1,j,intersections[0],intersections[1],false)[0];\r\n            \r\n            if(line.name == \"right\"){\r\n                if(angle < PI/2) {\r\n                outsideArea = topLeftCornerArea;\r\n                } else {\r\n                outsideArea = topRightCornerArea;\r\n                }\r\n            } else if (line.name == \"left\") {\r\n                if(angle < PI/2) {\r\n                outsideArea = 1-topLeftCornerArea;\r\n                } else {\r\n                outsideArea = 1-topRightCornerArea;\r\n                }\r\n            } else if (line.name == \"north\") {\r\n                if(angle < PI/2) {\r\n                outsideArea = 1-topRightCornerArea;\r\n                } else {\r\n                outsideArea = topLeftCornerArea;\r\n                }\r\n            } else if (line.name == \"south\") {\r\n                if(angle < PI/2) {\r\n                outsideArea = topRightCornerArea;\r\n                } else {\r\n                outsideArea = 1-topLeftCornerArea;\r\n                }\r\n            }\r\n            }\r\n\r\n            points.push({\r\n                x: i,\r\n                y: j,\r\n                weight: outsideArea,\r\n                crossingPoints: intersections,\r\n                borderName: line.name,\r\n            })  \r\n        }\r\n        }\r\n    }\r\n\r\n    return points;\r\n}\r\n\r\nfunction isPointInsidePolygon(x, y, lines) {\r\n    let count = 0;\r\n    for (let i = 0; i < lines.length; i++) {\r\n        let thisLine = lines[i];\r\n        if (\r\n        (y<thisLine.y1)!=(y<thisLine.y2) &&\r\n        x < thisLine.x1 + ((y-thisLine.y1)/(thisLine.y2-thisLine.y1)) * (thisLine.x2 - thisLine.x1)\r\n        ) {\r\n        count++;\r\n        }\r\n    }\r\n    return count % 2 === 1;\r\n}\r\n\r\nfunction calculateAreas(intersection1,intersection2,centerPoint) {\r\n    let area1 = 1;\r\n    let area2 = 0;\r\n    \r\n    if(intersection1.length>1 || intersection2.length >1){\r\n    // I think this should only happen if we have 4 intersections\r\n    let splitLine = intersection1;\r\n    \r\n    let splitLine1 = splitLine[0].x == floor(splitLine[0].x) ? \"x\" : \"y\";\r\n    let splitLine2 = splitLine[1].x == ",
    "floor(splitLine[1].x) ? \"x\" : \"y\";\r\n    \r\n    let thirdVertex = {};\r\n    \r\n    thirdVertex[splitLine1] = splitLine[0][splitLine1];\r\n    thirdVertex[splitLine2] = splitLine[1][splitLine2];\r\n    \r\n    let subArea1 = calculateArea(\r\n        splitLine[0].x, splitLine[0].y,\r\n        thirdVertex.x, thirdVertex.y,\r\n        splitLine[1].x, splitLine[1].y\r\n    );\r\n    \r\n    // If both are on the same axis, this means we have a trapeze\r\n    if(splitLine1 == splitLine2){\r\n        // In this case we have to divide into 2 triangles\r\n        // Both triangles will share one of the interesection points and the opposing vertex\r\n        // The third vertex of each triangle will be either the other intersection point or the other contiguous vertex\r\n        let firstCommonVertex = [splitLine[0].x, splitLine[0].y];\r\n        let otherIntersection = [splitLine[1].x, splitLine[1].y];\r\n        let otherLine = intersection2;\r\n        // To understand what area we need to calculate we need to check if the lower of intersection2's x/y coordinates is higher than the higher of intersecton1's x/y coordinate\r\n        let maxX1 = max(splitLine[0].x,splitLine[1].x);\r\n        let maxY1 = max(splitLine[0].y,splitLine[1].y);\r\n        let minX1 = min(splitLine[0].x,splitLine[1].x);\r\n        let minY1 = min(splitLine[0].y,splitLine[1].y);\r\n        let maxX2 = max(otherLine[0].x,otherLine[1].x);\r\n        let maxY2 = max(otherLine[0].y,otherLine[1].y);\r\n        let minX2 = min(otherLine[0].x,otherLine[1].x);\r\n        let minY2 = min(otherLine[0].y,otherLine[1].y);\r\n        \r\n        let secondCommonVertexX = 0;\r\n        let secondCommonVertexY = 0;\r\n        \r\n        let otherVertexX = 0;\r\n        let otherVertexY = 0;\r\n        \r\n        if (maxX1 < minX2) {\r\n        secondCommonVertexY = maxY1;\r\n        secondCommonVertexX = floor(splitLine[0].x);\r\n        if(maxY1 == splitLine[0].y) {\r\n            firstCommonVertex = [splitLine[1].x, splitLine[1].y];\r\n            otherIntersection = [splitLine[0].x, splitLine[0].y];\r\n        }\r\n        otherVertexX = secondCommonVertexX;\r\n        otherVertexY = secondCommonVertexY - 1;\r\n        }\r\n        \r\n        if (maxX2 < minX1) {\r\n        secondCommonVertexY = maxY1;\r\n        secondCommonVertexX = ceil(splitLine[0].x);\r\n        if(maxY1 == splitLine[0].y) {\r\n            firstCommonVertex = [splitLine[1].x, splitLine[1].y];\r\n            otherIntersection = [splitLine[0].x, splitLine[0].y];\r\n        }\r\n        otherVertexX = secondCommonVertexX;\r\n        otherVertexY = secondCommonVertexY - 1;\r\n        }\r\n        \r\n        if (maxY1 < minY2) {\r\n        secondCommonVertexX = maxX1;\r\n        secondCommonVertexY = floor(splitLine[0].y);\r\n        if(maxX1 == splitLine[0].x) {\r\n            firstCommonVertex = [splitLine[1].x, splitLine[1].y];\r\n            otherIntersection = [splitLine[0].x, splitLine[0].y];\r\n        }\r\n        otherVertexX = secondCommonVertexX - 1;\r\n        otherVertexY = secondCommonVertexY;\r\n        }\r\n        \r\n        if (maxY2 < minY1) {\r\n        secondCommonVertexX = maxX1;\r\n        secondCommonVertexY = ceil(splitLine[0].y);\r\n        if(maxX1 == splitLine[0].x) {\r\n            firstCommonVertex = [splitLine[1].x, splitLine[1].y];\r\n            otherIntersection = [splitLine[0].x, splitLine[0].y];\r\n        }\r\n        otherVertexX = secondCommonVertexX - 1;\r\n        otherVertexY = secondCommonVertexY;\r\n        }\r\n        \r\n        let secondCommonVertex = [secondCommonVertexX, secondCommonVertexY];\r\n        \r\n        let otherVertex = [otherVertexX, otherVertexY];\r\n        \r\n        let subSubArea1 = calculateArea(\r\n        firstCommonVertex[0], firstCommonVertex[1],\r\n        secondCommonVertex[0], secondCommonVertex[1],\r\n        otherIntersection[0], otherIntersection[1]\r\n        );\r\n        \r\n        let subSubArea2 = calculateArea(\r\n        firstCommonVertex[0], firstCommonVertex[1],\r\n        secondCommonVertex[0], secondCommonVertex[1],\r\n        otherVertex[0], otherVertex[1]\r\n        );\r\n        \r\n        subArea1 = subSubArea1 + subSubArea2;\r\n        \r\n    }\r\n    \r\n    splitLine = intersection2;\r\n    \r\n    splitLine1 = splitLine[0].x == floor(splitLine[0].x) ? \"x\" : \"y\";\r\n    splitLine2 = splitLine[1].x == floor(splitLine[1].x) ? \"x\" : \"y\";\r\n    \r\n    thirdVertex = {};\r\n    \r\n    thirdVertex[splitLine1] = splitLine[0][splitLine1];\r\n    thirdVertex[splitLine2] = splitLine[1][splitLine2];\r\n    \r\n    let subArea2 = calculateArea(\r\n        splitLine[0].x, splitLine[0].y,\r\n        thirdVertex.x, thirdVertex.y,\r\n        splitLine[1].x, splitLine[1].y\r\n    );\r\n    \r\n        // If both are on the same axis, this means we have a trapeze\r\n    if(splitLine1 == splitLine2){\r\n        // In this case we have to divide into 2 triangles\r\n        // Both triangles will share one of the interesection points and the opposing vertex\r\n        // The third vertex of each triangle will be either the other intersection point or the other contiguous vertex\r\n        let firstCommonVertex = [splitLine[0].x, splitLine[0].y];\r\n        let otherIntersection = [splitLine[1].x, splitLine[1].y];\r\n        let otherLine = intersection1;\r\n        // To understand what area we need to calculate we need to check if the lower of intersection2's x/y coordinates is higher than the higher of intersecton1's x/y coordinate\r\n        let maxX1 = max(splitLine[0].x,splitLine[1].x);\r\n        let maxY1 = max(splitLine[0].y,splitLine[1].y);\r\n        let minX1 = min(splitLine[0].x,splitLine[1].x);\r\n        let minY1 = min(splitLine[0].y,splitLine[1].y);\r\n        let maxX2 = max(otherLine[0].x,otherLine[1].x);\r\n        let maxY2 = max(otherLine[0].y,otherLine[1].y);\r\n        let minX2 = min(otherLine[0].x,otherLine[1].x);\r\n        let minY2 = min(otherLine[0].y,otherLine[1].y);\r\n        \r\n        let secondCommonVertexX = 0;\r\n        let secondCommonVertexY = 0;\r\n        \r\n        let otherVertexX = 0;\r\n        let otherVertexY = 0;\r\n        \r\n        if (maxX1 < minX2) {\r\n        secondCommonVertexY = maxY1;\r\n        secondCommonVertexX = floor(splitLine[0].x);\r\n        if(maxY1 == splitLine[0].y) {\r\n            firstCommonVertex = [splitLine[1].x, splitLine[1].y];\r\n            otherIntersection = [splitLine[0].x, splitLine[0].y];\r\n        }\r\n        otherVertexX = secondCommonVertexX;\r\n        otherVertexY = secondCommonVertexY - 1;\r\n        }\r\n        \r\n        if (maxX2 < minX1) {\r\n        secondCommonVertexY = maxY1;\r\n        secondCommonVertexX = ceil(splitLine[0].x);\r\n        if(maxY1 == splitLine[0].y) {\r\n            firstCommonVertex = [splitLine[1].x, splitLine[1].y];\r\n            otherIntersection = [splitLine[0].x, splitLine[0].y];\r\n        }\r\n        otherVertexX = secondCommonVertexX;\r\n        otherVertexY = secondCommonVertexY - 1;\r\n        }\r\n        \r\n        if (maxY1 < minY2) {\r\n        secondCommonVertexX = maxX1;\r\n        secondCommonVertexY = floor(splitLine[0].y);\r\n        if(maxX1 == splitLine[0].x) {\r\n            firstCommonVertex = [splitLine[1].x, splitLine[1].y];\r\n            otherIntersection = [splitLine[0].x, splitLine[0].y];\r\n        }\r\n        otherVertexX = secondCommonVertexX - 1;\r\n        otherVertexY = secondCommonVertexY;\r\n        }\r\n        \r\n        if (maxY2 < minY1) {\r\n        secondCommonVertexX = maxX1;\r\n        secondCommonVertexY = ceil(splitLine[0].y);\r\n        if(maxX1 == splitLine[0].x) {\r\n            firstCommonVertex = [splitLine[1].x, splitLine[1].y];\r\n            otherIntersection = [splitLine[0].x, splitLine[0].y];\r\n        }\r\n        otherVertexX = secondCommonVertexX - 1;\r\n        otherVertexY = secondCommonVertexY;\r\n        }\r\n        \r\n        let secondCommonVertex = [secondCommonVertexX, secondCommonVertexY];\r\n        \r\n        let otherVertex = [otherVertexX, otherVertexY];\r\n        \r\n        let subSubArea1 = calculateArea(\r\n        firstCommonVertex[0], firstCommonVertex[1],\r\n        secondCommonVertex[0], secondCommonVertex[1],\r\n        otherIntersection[0], otherIntersection[1]\r\n        );\r\n        \r\n        let subSubArea2 = calculateArea(\r\n        firstCommonVertex[0], firstCommonVertex[1],\r\n        secondCommonVertex[0], secondCommonVertex[1],\r\n        otherVertex[0], otherVertex[1]\r\n        );\r\n        \r\n        subArea2 = subSubArea1 + subSubArea2;\r\n        \r\n    }\r\n    \r\n    area1 = subArea1 + subArea2;\r\n    area2 = 1-area1;\r\n    \r\n    \r\n    return [area1, area2];\r\n    }\r\n    \r\n    //Check if the splitLine passes by two neighbouring or opposed sides\r\n    let splitLine = [intersection1[0], intersection2[0]];\r\n    \r\n    let splitLine1 = splitLine[0].x == floor(splitLine[0].x) ? \"x\" : \"y\";\r\n    let splitLine2 = splitLine[1].x == floor(splitLine[1].x) ? \"x\" : \"y\";\r\n\r\n    // If they are on the same edge, we just have to calculate the area of a triangle\r\n    if(splitLine1 == splitLine2 &&\r\n        splitLine[0][splitLine1] == splitLine[1][splitLine2]){\r\n        area2 = calculateArea(\r\n        splitLine[0].x, splitLine[0].y,\r\n        splitLine[1].x, splitLine[1].y,\r\n        centerPoint.x, centerPoint.y\r\n        );\r\n        area1 = 1 - area2;\r\n    } else {\r\n        // We have to caculate the area of a trapeze.\r\n        // We can split the trapeze into two triangles, sharing centerPoint and the vertex of the square that is in between the two intersectionpoints\r\n        // Summing these two up we get area1, and area2 will be the rest\r\n        // First we check which splitline shares a coordinate with the first vertex\r\n    \r\n        if( splitLine1 !== splitLine2){\r\n        // In this case we have 2 triangles\r\n        let chosenSquareVertex = {};\r\n        chosenSquareVertex[splitLine1] = splitLine[0][splitLine1];\r\n        chosenSquareVertex[splitLine2] = splitLine[1][splitLine2];\r\n    \r\n        let subArea1 = calculateArea(\r\n            centerPoint.x, centerPoint.y,\r\n            chosenSquareVertex.x, chosenSquareVertex.y,\r\n            splitLine[0].x, splitLine[0].y\r\n        );\r\n\r\n        let subArea2 = calculateArea(\r\n            centerPoint.x, centerPoint.y,\r\n            chosenSquareVertex.x, chosenSquareVertex.y,\r\n            splitLine[1].x, splitLine[1].y\r\n        );\r\n        area2 = subArea1 + subArea2;\r\n        } else {\r\n        // In this case we have 3 triangles\r\n        let chosenSquareVertex1 = {};\r\n        let chosenSquareVertex2 = {};\r\n        let otherComponent = splitLine1 == 'x' ? 'y' : 'x';\r\n        \r\n        chosenSquareVertex1[splitLine1] = splitLine[0][splitLine1];\r\n        chosenSquareVertex1[otherComponent] = floor(splitLine[0][otherComponent]);\r\n        \r\n        chosenSquareVertex2[splitLine2] = splitLine[1][splitLine2];\r\n        chosenSquareVertex2[otherComponent] = floor(splitLine[1][otherComponent]);\r\n        \r\n        let subArea1 = calculateArea(\r\n            centerPoint.x, centerPoint.y,\r\n            chosenSquareVertex1.x, chosenSquareVertex1.y,\r\n            splitLine[0].x, splitLine[0].y\r\n        );\r\n\r\n        let subArea2 = calculateArea(\r\n            centerPoint.x, centerPoint.y,\r\n            chosenSquareVertex1.x, chosenSquareVertex1.y,\r\n            chosenSquareVertex2.x, chosenSquareVertex2.y\r\n        );\r\n        \r\n        let subArea3 = calculateArea(\r\n            centerPoint.x, centerPoint.y,\r\n            chosenSquareVertex2.x, chosenSquareVertex2.y,\r\n            splitLine[1].x, splitLine[1].y\r\n        );\r\n        \r\n        area2 = subArea1 + subArea2 + subArea3;\r\n        \r\n        // Depending on where the centerpoint is, we will have calculated either inside or outside area, we have to check if we need to correct this or not\r\n        \r\n        if(centerPoint[otherComponent]-floor(centerPoint[otherComponent])<0.5) {\r\n            area2 = 1-area2;\r\n        }\r\n        \r\n        }\r\n\r\n        area1 = 1-area2;\r\n    }\r\n    \r\n    return [area1, area2];\r\n    }\r\n\r\n    function calculateArea(x1, y1, x2, y2, x3, y3) {\r\n    x1 = round(x1,5);\r\n    y1 = round(y1,5);\r\n    x2 = round(x2,5);\r\n    y2 = round(y2,5);\r\n    x3 = round(x3,5);\r\n    y3 = round(y3,5);\r\n    \r\n    return Math.abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) / 2);\r\n    }\r\n\r\n    function calculateSimpleAreas(x,y,intersection1,intersection2,topLeft) {\r\n    let area1 = 1;\r\n    let area2 = 0;\r\n    \r\n    //Check if the splitLine passes by two neighbouring or opposed vertices\r\n    let splitLine = [intersection1, intersection2];\r\n    \r\n    let splitLine1 = splitLine[0].x == floor(splitLine[0].x) ? \"x\" : \"y\";\r\n    let splitLine2 = splitLine[1].x == floor(splitLine[1].x) ? \"x\" : \"y\";\r\n\r\n    // If they are on contiguous edges, we just have to calculate the area of a triangle\r\n    if(splitLine1 != splitLine2){\r\n        let thirdVertex = {};\r\n        thirdVertex[splitLine1] = splitLine[0][splitLine1];\r\n        thirdVertex[splitLine2] = splitLine[1][splitLine2];\r\n    \r\n        area2 = calculateArea(\r\n        splitLine[0].x, splitLine[0].y,\r\n        splitLine[1].x, splitLine[1].y,\r\n        thirdVertex.x, thirdVertex.y\r\n        );\r\n    \r\n        area1 = 1 - area2;\r\n\r\n        if(thirdVertex.x == x && thirdVertex.y == y){\r\n        area2 = area1;\r\n        area1 = 1 - area2;\r\n        }\r\n    } else {\r\n        // We have to caculate the area of a trapeze.\r\n        // We can split the trapeze into two triangles, sharing the x,y vertex\r\n        // Summing these two up we get area1, and area2 will be the rest\r\n        // First we check which splitline shares a coordinate with the first vertex\r\n        let contigSplitLine;\r\n        let oppSplitLine;    \r\n        let otherSquareVertex = {};\r\n    \r\n        if(\r\n        (splitLine1 == 'x' && splitLine[0][splitLine1] == x) ||\r\n        (splitLine1 == 'y' && splitLine[0][splitLine1] == y)\r\n        ) {\r\n        contigSplitLine = splitLine[0];\r\n        oppSplitLine = splitLine[1];\r\n        otherSquareVertex[splitLine2] = splitLine[1][splitLine2];\r\n        //this should be floor or ceil depending on whether we are at topleft or topright vertex of the square\r\n        if(splitLine2 == 'x'){\r\n            otherSquareVertex.y = floor(splitLine[1].y);\r\n        } else {\r\n            if(topLeft){\r\n            otherSquareVertex.x = floor(splitLine[1].x);\r\n            } else {\r\n            otherSquareVertex.x = ceil(splitLine[1].x);\r\n            }\r\n        }\r\n        } else {\r\n        contigSplitLine = splitLine[1];\r\n        oppSplitLine = splitLine[0];\r\n        otherSquareVertex[splitLine1] = splitLine[0][splitLine1];\r\n        if(splitLine1 == 'x'){\r\n            otherSquareVertex.y = floor(splitLine[0].y);\r\n        } else {\r\n            if (topLeft) {\r\n            otherSquareVertex.x = floor(splitLine[0].x);\r\n            } else {\r\n            otherSquareVertex.x = ceil(splitLine[0].x);\r\n            }\r\n        }\r\n        }\r\n    \r\n        let subArea1 = calculateArea(\r\n        x, y,\r\n        contigSplitLine.x, contigSplitLine.y,\r\n        oppSplitLine.x, oppSplitLine.y\r\n        );\r\n    \r\n    \r\n        let subArea2 = calculateArea(\r\n        x, y,\r\n        oppSplitLine.x, oppSplitLine.y,\r\n        otherSquareVertex.x,otherSquareVertex.y\r\n        );\r\n    \r\n        area1 = subArea1+subArea2;\r\n    \r\n        area2 = 1-area1;\r\n    }\r\n    \r\n    return [area1, area2];\r\n}\r\n\r\nfunction convertToGrayscale(inputColor) {\r\n    // Extracting red, green, and blue components\r\n    let r = red(inputColor);\r\n    let g = green(inputColor);\r\n    let b = blue(inputColor);\r\n\r\n    // Calculating the grayscale value (average of RGB components)\r\n    let grayscaleValue = (r + g + b) / 3;\r\n\r\n    // Creating a grayscale color using the grayscale value\r\n    let grayscaleColor = color(grayscaleValue);\r\n\r\n    return grayscaleColor;\r\n}\r\n\r\n\r\nfunction antiAliasShapeFill(pixelSet,radius=1) {\r\n    // Create a copy of the original canvasArray\r\n    let tempCanvasArray = structuredClone(canvasArray);\r\n    \r\n    // Create a mask for shape's fill\r\n    let fillMask = Array.from({ length: canvasWidth }, () => Array(canvasHeight).fill(0));\r\n    \r\n    for (let i = 0; i<pixelSet.length; i++){\r\n        let pixel = pixelSet[i];\r\n        let x = pixel.x;\r\n        let y = pixel.y;\r\n        fillMask[x][y] = 1;\r\n    }\r\n    \r\n    // Loop through each pixel in the pixelSet\r\n    for (let i = 0; i<pixelSet.length; i++){\r\n        let pixel = pixelSet[i];\r\n        let x = pixel.x;\r\n        let y = pixel.y;\r\n\r\n        if (pixel !== undefined) {\r\n        // Find surrounding pixels within a certain radius\r\n        let surroundingPixels = findSurroundingPixels({ x, y }, tempCanvasArray, radius, 1, fillMask);\r\n\r\n        // Calculate the average values for red, green, and blue\r\n        let avgRed = calculateAverageColorComponent(surroundingPixels, 'r');\r\n        let avgGreen = calculateAverageColorComponent(surroundingPixels, 'g');\r\n        let avgBlue = calculateAverageColorComponent(surroundingPixels, 'b');\r\n\r\n        // Check distance between avgColor and pixel's original color\r\n        let originalColor = tempCanvasArray[x][y];\r\n\r\n        let d = dist(\r\n        originalColor.r,originalColor.g,originalColor.b,\r\n        avgRed,avgGreen,avgBlue\r\n    );\r\n        \r\n        if(d>0.01) {\r\n            // Update the pixel color in canvasArray\r\n            canvasArray[x][y] = {\r\n            r: avgRed,\r\n            g: avgGreen,\r\n            b: avgBlue,\r\n            };\r\n        }\r\n        }\r\n    }\r\n}\r\n\r\nfunction getPointOnLineFromY(line,y) {\r\n    let m = (line.y2 - line.y1) / (line.x2 - line.x1);\r\n    \r\n    return {\r\n        x: (y - line.y1) / m + line.x1,\r\n        y: y\r\n    };\r\n}\r\n\r\n// Function to convert hex to RGB\r\nfunction hexToRgb(hex) {\r\n    // Remove the hash symbol if present\r\n    hex = hex.replace(/^#/, '');\r\n    \r\n    // Parse the string into RGB components\r\n    let bigint = parseInt(hex, 16);\r\n    let r = (bigint >> 16) & 255;\r\n    let g = (bigint >> 8) & 255;\r\n    let b = bigint & 255;\r\n    \r\n    return [r, g, b];\r\n}\r\n\r\n// Function to convert RGB to hex\r\nfunction rgbToHex(r, g, b) {\r\n    return \"#\" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();\r\n}\r\n\r\n// Function to mix two colors\r\nfunction mixColors(color1, color2) {\r\n    let rgb1 = hexToRgb(color1);\r\n    let rgb2 = hexToRgb(color2);\r\n    \r\n    // Average the RGB values\r\n    let r = round((rgb1[0] + rgb2[0]) / 2);\r\n    let g = round((rgb1[1] + rgb2[1]) / 2);\r\n    let b = round((rgb1[2] + rgb2[2]) / 2);\r\n    \r\n    // Convert the averaged RGB values back to hex\r\n    return rgbToHex(r, g, b);\r\n}\r\n\r\nfunction rotateShape(relativePoints,baseRadius) {\r\n    // Find the centroid of the points\r\n    let points =  relativePoints.map(item => ({\r\n        x: item.x * canvasWidth,\r\n        y: item.y * canvasHeight,\r\n        curvature: item.curvature * maxCurvature,\r\n        percentageDistance: item.percentageDistance,\r\n        radiusIncrease: item.radiusIncrease\r\n    }));\r\n\r\n    const centroid = points.reduce((acc, point) => ({ x: acc.x + point.x, y: acc.y + point.y }), { x: 0, y: 0 });\r\n    centroid.x /= points.length;\r\n    centroid.y /= points.length;\r\n\r\n    let lastOverflow = 0;\r\n    let borderAngles = [];\r\n\r\n    for (let i = 0; i<360;i++){\r\n        let angle = radians(i);\r\n\r\n        //We will map the points array to return a 1 if the full shape is inside the canvas or a 0 if it overflows\r\n        let rotationOverflow = points.map(p => {\r\n            // Translate point to origin\r\n            let x = p.x - centroid.x;\r\n            let y = p.y - centroid.y;\r\n            let radiusIncrease = p.radiusIncrease;\r\n            \r\n            // Rotate point\r\n            let xNew = x * cos(angle) - y * sin(angle);\r\n            let yNew = x * sin(angle) + y * cos(angle);\r\n            \r\n            // Translate point back\r\n            xNew += centroid.x;\r\n            yNew += centroid.y;\r\n\r\n            let safetyDist = baseRadius * radiusIncrease;\r\n\r\n            if (xNew >= safetyDist && \r\n                xNew <= canvasWidth - safetyDist &&\r\n                yNew >= safetyDist &&\r\n                yNew <= canvasHeight - safetyDist\r\n            ) {\r\n                return 1;\r\n            }\r\n            \r\n            return 0;\r\n        }).reduce((acc, val) => acc * val, 1);\r\n\r\n        if(rotationOverflow != lastOverflow) {\r\n            borderAngles.push(i);\r\n            lastOverflow = lastOverflow ^ 1;\r\n        }\r\n    };\r\n\r\n    lastOverflow = 1;\r\n    console.log(borderAngles);\r\n\r\n    //We strart this loop in the second position of the array because the first one is always just 0\r\n    for (let j = 1; j<borderAngles.length;j++){\r\n\r\n        for (let i = borderAngles[j]-1; i<borderAngles[j];i+=0.005){\r\n            let angle = radians(i);\r\n\r\n            //We will map the points array to return a 1 if the full shape is inside the canvas or a 0 if it overflows\r\n            let rotationOverflow = points.map(p => {\r\n                // Translate point to origin\r\n                let x = p.x - centroid.x;\r\n                let y = p.y - centroid.y;\r\n                let radiusIncrease = p.radiusIncrease;\r\n                \r\n                // Rotate point\r\n                let xNew = x * cos(angle) - y * sin(angle);\r\n                let yNew = x * sin(angle) + y * cos(angle);\r\n                \r\n                // Translate point back\r\n                xNew += centroid.x;\r\n                yNew += centroid.y;\r\n\r\n                let safetyDist = baseRadius * radiusIncrease;\r\n\r\n                if (xNew >= safetyDist && \r\n                    xNew <= canvasWidth - safetyDist &&\r\n                    yNew >= safetyDist &&\r\n                    yNew <= canvasHeight - safetyDist\r\n                ) {\r\n                    return 1;\r\n                }\r\n                \r\n                return 0;\r\n            }).reduce((acc, val) => acc * val, 1);\r\n\r\n            if(rotationOverflow != lastOverflow) {\r\n                borderAngles[j] = i;\r\n                lastOverflow = lastOverflow ^ 1;\r\n                break;\r\n            }\r\n            \r\n        }\r\n\r\n    }\r\n\r\n    // In some edge cases borderangles may already have an even number of terms, if so not necessary to push a final 360 limit\r\n\r\n    if( borderAngles.length % 2 == 1) {\r\n        borderAngles.push(360);\r\n    }\r\n\r\n\r\n    //Now we have an array with the borderangles with sufficient precision (0.005 deg)\r\n    //We now select an angle in an allowed range\r\n\r\n    //First we assing a weight to each range\r\n    \r\n    let ranges = [];\r\n    for(i=0;i<borderAngles.length;i+=2){\r\n        ranges.push(borderAngles.slice(i,i+2));\r\n    }\r\n\r\n    let totalLength = 0;\r\n    let weights = ranges.map(range => {\r\n        let length = (range[1] - range[0] + 1);\r\n        totalLength += length;\r\n        return length;\r\n    });\r\n\r\n    let probabilities = weights.map(weight => weight / totalLength);\r\n\r\n    let randomValue = random();\r\n\r\n    let accumulatedProbability = 0;\r\n    let selectedRangeIndex = -1;\r\n    for (let i = 0; i < probabilities.length; i++) {\r\n        accumulatedProbability += probabilities[i];\r\n        if (randomValue <= accumulatedProbability) {\r\n            selectedRangeIndex = i;\r\n            break;\r\n        }\r\n    }\r\n\r\n    let selectedRange = ranges[selectedRangeIndex];\r\n\r\n    let rotationAngle = random(selectedRange[0], selectedRange[1]);\r\n\r\n    let rotatedPoints = relativePoints.map(p => {\r\n        // Translate point to origin\r\n        // Preserve other properties while rotating x and y\r\n        let { x, y, ...rest } = p;\r\n\r\n        let translatedX = x*canvasWidth - centroid.x;\r\n        let translatedY = y*canvasHeight - centroid.y;\r\n        let angle = radians(rotationAngle);\r\n        \r\n        // Rotate point\r\n        let xNew = translatedX * cos(angle) - translatedY * sin(angle);\r\n        let yNew = translatedX * sin(angle) + translatedY * cos(angle);\r\n        \r\n       ",
    " // Translate point back\r\n        xNew += centroid.x;\r\n        yNew += centroid.y;\r\n        \r\n        return { \r\n            x: xNew/canvasWidth, \r\n            y: yNew/canvasHeight,\r\n            ...rest \r\n        };\r\n    });\r\n\r\n    //Lastly, we also need to rotate circles and lines around the centroid\r\n    for (let i=0; i<setupVariables.circles.length;i++) {\r\n        let {centerX, centerY} = setupVariables.circles[i];\r\n\r\n        let translatedX = centerX*canvasWidth - centroid.x;\r\n        let translatedY = centerY*canvasHeight - centroid.y;\r\n        let angle = radians(rotationAngle);\r\n        \r\n        // Rotate point\r\n        let xNew = translatedX * cos(angle) - translatedY * sin(angle);\r\n        let yNew = translatedX * sin(angle) + translatedY * cos(angle);\r\n        \r\n        // Translate point back\r\n        xNew += centroid.x;\r\n        yNew += centroid.y;\r\n\r\n        setupVariables.circles[i].centerX = xNew/canvasWidth;\r\n        setupVariables.circles[i].centerY = yNew/canvasHeight;\r\n    }\r\n\r\n    for (let i=0; i<setupVariables.lines.length;i++) {\r\n        let {centerX, centerY} = setupVariables.lines[i];\r\n\r\n        let translatedX = centerX*canvasWidth - centroid.x;\r\n        let translatedY = centerY*canvasHeight - centroid.y;\r\n        let angle = radians(rotationAngle);\r\n        \r\n        // Rotate point\r\n        let xNew = translatedX * cos(angle) - translatedY * sin(angle);\r\n        let yNew = translatedX * sin(angle) + translatedY * cos(angle);\r\n        \r\n        // Translate point back\r\n        xNew += centroid.x;\r\n        yNew += centroid.y;\r\n\r\n        setupVariables.lines[i].centerX = xNew/canvasWidth;\r\n        setupVariables.lines[i].centerY = yNew/canvasHeight;\r\n        setupVariables.lines[i].angle = (setupVariables.lines[i].angle + angle)%(2*PI);\r\n    }\r\n\r\n    return rotatedPoints;\r\n}\r\n\r\nfunction findMinDistanceToBoundary(x1, y1, x2, y2, canvasWidth, canvasHeight) {\r\n    let distances = [];\r\n    \r\n    // Intersection with x = 0\r\n    if (x2 - x1 !== 0) {\r\n        let t = -x1 / (x2 - x1);\r\n        let yInt = y1 + t * (y2 - y1);\r\n        if (yInt >= 0 && yInt <= canvasHeight) {\r\n            distances.push(dist(x1, y1, 0, yInt));\r\n        }\r\n    }\r\n\r\n    // Intersection with y = 0\r\n    if (y2 - y1 !== 0) {\r\n        let t = -y1 / (y2 - y1);\r\n        let xInt = x1 + t * (x2 - x1);\r\n        if (xInt >= 0 && xInt <= canvasWidth) {\r\n            distances.push(dist(x1, y1, xInt, 0));\r\n        }\r\n    }\r\n\r\n    // Intersection with x = canvasWidth\r\n    if (x2 - x1 !== 0) {\r\n        let t = (canvasWidth - x1) / (x2 - x1);\r\n        let yInt = y1 + t * (y2 - y1);\r\n        if (yInt >= 0 && yInt <= canvasHeight) {\r\n            distances.push(dist(x1, y1, canvasWidth, yInt));\r\n        }\r\n    }\r\n\r\n    // Intersection with y = canvasHeight\r\n    if (y2 - y1 !== 0) {\r\n        let t = (canvasHeight - y1) / (y2 - y1);\r\n        let xInt = x1 + t * (x2 - x1);\r\n        if (xInt >= 0 && xInt <= canvasWidth) {\r\n            distances.push(dist(x1, y1, xInt, canvasHeight));\r\n        }\r\n    }\r\n\r\n    // Return the minimum distance found\r\n    return Math.min(...distances);\r\n}\r\n\r\nfunction movePointAlongLine(x1, y1, x2, y2, distance, i,canvasWidth, canvasHeight,direction,shape=\"none\") {\r\n    // Calculate the direction vector\r\n    let dx = x1 - x2;\r\n    let dy = y1 - y2;\r\n    \r\n    // Calculate the length of the line\r\n    let length = Math.sqrt(dx*dx+dy*dy);\r\n    \r\n    // Normalize the direction vector\r\n    let ux = dx / length;\r\n    let uy = dy / length;\r\n    \r\n    // Calculate the new point after moving a certain distance\r\n    let xNew = x1 + direction * distance * ux;\r\n    let yNew = y1 + direction * distance * uy;\r\n    \r\n    if(shape == \"circle\") {\r\n        setupVariables.circles[i].centerX = xNew/canvasWidth;\r\n        setupVariables.circles[i].centerY = yNew/canvasHeight;\r\n    } else if(shape == \"line\") {\r\n        setupVariables.lines[i].centerX = xNew/canvasWidth;\r\n        setupVariables.lines[i].centerY = yNew/canvasHeight;\r\n    }else{\r\n        setupVariables.seedpoints[i].x = xNew/canvasWidth;\r\n        setupVariables.seedpoints[i].y = yNew/canvasHeight;\r\n    }\r\n}\r\n\r\nfunction getOriginalValues(original, modified) {\r\n    let differences = {};\r\n\r\n    for (let key in original) {\r\n        if (modified.hasOwnProperty(key)) {\r\n        if (Array.isArray(original[key]) && Array.isArray(modified[key])) {\r\n            if (JSON.stringify(original[key]) !== JSON.stringify(modified[key])) {\r\n                differences[key] = original[key];\r\n            }\r\n        } else if (typeof original[key] === 'object' && typeof modified[key] === 'object') {\r\n            const nestedDifferences = getOriginalValues(original[key], modified[key]);\r\n            if (Object.keys(nestedDifferences).length > 0) {\r\n                differences[key] = nestedDifferences;\r\n            }\r\n        } else if (original[key] !== modified[key]) {\r\n            differences[key] = original[key];\r\n        }\r\n        } else {\r\n            differences[key] = original[key]; // Property was deleted in modified\r\n        }\r\n    }\r\n\r\n    // Check for new properties in modified\r\n    for (let key in modified) {\r\n        if (!original.hasOwnProperty(key)) {\r\n        differences[key] = null; // New property\r\n        }\r\n    }\r\n\r\n    return differences;\r\n}\r\n\r\nfunction reconstructOriginal(modified, differences) {\r\n    let original = structuredClone(modified); // Deep copy of modified object\r\n\r\n    function applyDifferences(obj, diff) {\r\n        for (let key in diff) {\r\n            if (Array.isArray(diff[key])) {\r\n                obj[key] = diff[key]; // Replace the entire array\r\n            } else if (typeof diff[key] === 'object' && diff[key] !== null && typeof obj[key] === 'object') {\r\n                applyDifferences(obj[key], diff[key]);\r\n            } else if (diff[key] !== null) {\r\n                obj[key] = diff[key];\r\n            } else {\r\n                delete obj[key];\r\n            }\r\n        }\r\n        // Add back properties that were in the original but not in modified\r\n        for (let key in diff) {\r\n            if (!obj.hasOwnProperty(key) && diff[key] !== null) {\r\n                obj[key] = diff[key];\r\n            }\r\n        }\r\n    }\r\n\r\n    applyDifferences(original, differences);\r\n    return original;\r\n}\r\n"
  ]
}