<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <script src="p5.js"></script>
  <title>Your p5.js Sketch</title>
</head>
<body>
  <script>
    let canvasWidth = 1200;
    let canvasHeight = 600;
    let seedpoints = [];
    let matchingPixels = [];
    let borderPixels = [];
    let previousLines = [];
    let maxCurvature = 100;
    let canvasArray = [];
    let shapeArray = [];
    let weightsArray = [];
    let linesToRightArray = [];
    let fullHistoryFromEvents = null;

    let variablesGenerated = false;
    let setupVariables = {
        aspectRatio: 0.5,
        canvasWidth: 1200,
        baseRadius: 0,
        numSeedpoints: 5,
        seedpoints: [],
        gradientType: 0,
        dividerCount: 0,
        circleCount: 0,
        lineCount: 0,
        circles: [],
        lines: [],
        colors: [],
        selectedcolors: [],
        dividers: [],
        mutation: "",
        initialVariables: {},
        changeHistory: []
    };

    /*let variablesGenerated = true;
    let setupVariables = {
    "aspectRatio": 0.6666666666666666,
    "canvasWidth": 1200,
    "baseRadius": 0.022222222222222223,
    "numSeedpoints": 7,
    "seedpoints": [
        {
            "x": 0.6019869885677136,
            "y": 0.5690106254193166,
            "curvature": 0.6044019185937941,
            "percentageDistance": 0.8396153,
            "radiusIncrease": 1
        },
        {
            "x": 0.6685772818644988,
            "y": 0.2558891278503317,
            "curvature": 1.2501380662433803,
            "percentageDistance": 0.8007817,
            "radiusIncrease": 3
        },
        {
            "x": 0.229664925461084,
            "y": 0.8346514522323651,
            "curvature": 1.2526878383941948,
            "percentageDistance": 0.9602711,
            "radiusIncrease": 1
        },
        {
            "x": 0.2147309576982849,
            "y": 0.8495085146607271,
            "curvature": 1.4348444803617895,
            "percentageDistance": 0.2447422,
            "radiusIncrease": 1
        },
        {
            "x": 0.4816861123288818,
            "y": 0.4438190278615864,
            "curvature": 0.7561085433699191,
            "percentageDistance": 0.3092208,
            "radiusIncrease": 2
        },
        {
            "x": 0.7273629879331294,
            "y": 0.32480711186905487,
            "curvature": 0.5717821228317916,
            "percentageDistance": 0.3740746,
            "radiusIncrease": 2
        },
        {
            "x": 0.462700057612043,
            "y": 0.6993519533133816,
            "curvature": 0.9985084091313183,
            "percentageDistance": 0.9457773,
            "radiusIncrease": 1
        }
    ],
    "gradientType": 2,
    "dividerCount": 2,
    "circleCount": 3,
    "lineCount": 0,
    "circles": [
        {
            "radius": 0.1,
            "centerX": 0.7015389597113081,
            "centerY": 0.3580839739106657
        },
        {
            "radius": 0.2814019808363906,
            "centerX": 0.3432056263779748,
            "centerY": 0.7230839739106656
        },
        {
            "radius": 0.78484030654696,
            "centerX": 0.5998722930446414,
            "centerY": 0.5218339739106657
        }
    ],
    "lines": [],
    "colors": [
        "#8493B6",
        "#A1C388",
        "#CB5284",
        "#626364",
        "#FBE2BA",
        "#7522D5"
    ],
    "selectedcolors": [
        "#7522D5",
        "#CB5284",
        "#626364"
    ],
    "dividers": [
        {
            "startPointX": 0.7382056263779747,
            "angle": 0.43708705832250416
        },
        {
            "startPointX": 0.4223722930446414,
            "angle": 0.2717518308199942
        }
    ],
    "mutation": "seedpointMoveUp-right",
    "initialVariables": {
        "aspectRatio": 0.6666666666666666,
        "canvasWidth": 1200,
        "baseRadius": 0.022222222222222223,
        "numSeedpoints": 7,
        "seedpoints": [
            {
                "x": 0.8279480288564055,
                "y": 0.45217665150865083,
                "curvature": 0.6044019185937941,
                "percentageDistance": 0.8396153,
                "radiusIncrease": 1
            },
            {
                "x": 0.8945383221531907,
                "y": 0.139055153939666,
                "curvature": 1.2501380662433803,
                "percentageDistance": 0.8007817,
                "radiusIncrease": 3
            },
            {
                "x": 0.4556259657497759,
                "y": 0.7178174783216995,
                "curvature": 1.2526878383941948,
                "percentageDistance": 0.9602711,
                "radiusIncrease": 1
            },
            {
                "x": 0.4406919979869768,
                "y": 0.7326745407500614,
                "curvature": 1.4348444803617895,
                "percentageDistance": 0.2447422,
                "radiusIncrease": 1
            },
            {
                "x": 0.7076471526175737,
                "y": 0.3269850539509207,
                "curvature": 0.7561085433699191,
                "percentageDistance": 0.3092208,
                "radiusIncrease": 2
            },
            {
                "x": 0.9533240282218213,
                "y": 0.20797313795838918,
                "curvature": 0.5717821228317916,
                "percentageDistance": 0.3740746,
                "radiusIncrease": 2
            },
            {
                "x": 0.6886610979007349,
                "y": 0.5825179794027159,
                "curvature": 0.9985084091313183,
                "percentageDistance": 0.9457773,
                "radiusIncrease": 1
            }
        ],
        "gradientType": 2,
        "dividerCount": 2,
        "circleCount": 3,
        "lineCount": 1,
        "circles": [
            {
                "radius": 0.1,
                "centerX": 0.9275,
                "centerY": 0.24125
            },
            {
                "radius": 0.2814019808363906,
                "centerX": 0.5691666666666667,
                "centerY": 0.60625
            },
            {
                "radius": 0.78484030654696,
                "centerX": 0.8258333333333333,
                "centerY": 0.405
            }
        ],
        "lines": [
            {
                "ancho": 11,
                "angle": 2.612796914553805,
                "length": 0.4353774832342044,
                "centerX": 0.7166666666666667,
                "centerY": 0.3925
            }
        ],
        "colors": [
            "#F69DA4",
            "#52A8A4",
            "#915A7F",
            "#F08248",
            "#1A3D5A",
            "#F69DA4"
        ],
        "selectedcolors": [
            "#F69DA4",
            "#915A7F",
            "#F08248"
        ],
        "dividers": [
            {
                "startPointX": 0.9641666666666666,
                "angle": 0.43708705832250416
            },
            {
                "startPointX": 0.6483333333333333,
                "angle": 0.2717518308199942
            }
        ],
        "mutation": "",
        "initialVariables": {},
        "changeHistory": []
    },
    "changeHistory": [
        {
            "seedpoints": {
                "0": {
                    "x": 0.8279480288564055,
                    "y": 0.45217665150865083
                },
                "1": {
                    "x": 0.8945383221531907,
                    "y": 0.139055153939666
                },
                "2": {
                    "x": 0.4556259657497759,
                    "y": 0.7178174783216995
                },
                "3": {
                    "x": 0.4406919979869768,
                    "y": 0.7326745407500614
                },
                "4": {
                    "x": 0.7076471526175737,
                    "y": 0.3269850539509207
                },
                "5": {
                    "x": 0.9533240282218213,
                    "y": 0.20797313795838918
                },
                "6": {
                    "x": 0.6886610979007349,
                    "y": 0.5825179794027159
                }
            },
            "circles": {
                "0": {
                    "centerX": 0.9275,
                    "centerY": 0.24125
                },
                "1": {
                    "centerX": 0.5691666666666667,
                    "centerY": 0.60625
                },
                "2": {
                    "centerX": 0.8258333333333333,
                    "centerY": 0.405
                }
            },
            "lines": {
                "0": {
                    "centerX": 0.7166666666666667,
                    "centerY": 0.3925
                }
            },
            "dividers": {
                "0": {
                    "startPointX": 0.9641666666666666
                },
                "1": {
                    "startPointX": 0.6483333333333333
                }
            }
        },
        {
            "colors": {
                "0": "#F69DA4",
                "1": "#52A8A4",
                "2": "#915A7F",
                "4": "#1A3D5A"
            },
            "selectedcolors": {
                "1": "#915A7F"
            }
        },
        {
            "colors": {
                "0": "#1A3D5A"
            }
        },
        {
            "colors": {
                "2": "#F69DA4"
            },
            "selectedcolors": {
                "1": "#F69DA4"
            }
        },
        {
            "colors": {
                "0": "#856051",
                "1": "#915A7F",
                "2": "#C47C92",
                "3": "#F08248",
                "4": "#52A8A4",
                "5": "#F69DA4"
            },
            "selectedcolors": {
                "0": "#F69DA4",
                "1": "#C47C92",
                "2": "#F08248"
            }
        },
        {
            "colors": {
                "0": "#FDF4B6",
                "1": "#49B753",
                "2": "#DE11F4",
                "3": "#B89313",
                "4": "#F8CFBD",
                "5": "#0B32B5"
            },
            "selectedcolors": {
                "0": "#0B32B5",
                "1": "#DE11F4",
                "2": "#B89313"
            }
        },
        {
            "lineCount": 1,
            "lines": [
                {
                    "ancho": 11,
                    "angle": 2.612796914553805,
                    "length": 0.4353774832342044,
                    "centerX": 0.49070562637797477,
                    "centerY": 0.5093339739106657
                }
            ]
        }
    ]
    }*/

    function setup() {
        // Set the seed based on the current date and time
        if(!variablesGenerated){
            let currentDate = new Date();
            randomSeed(currentDate.getTime());
            console.log(currentDate.getTime());
        }
        //randomSeed(1707067932653);
        //randomSeed(1708287067251);
        //randomSeed(1708778645106);
        //randomSeed(1708804809694);
        //randomSeed(1710060370029);
        //randomSeed(1710073785826);
        //randomSeed(1710561094530);
        //randomSeed(1710572840471);
        //randomSeed(1710573306631);

        let initalVariablesObj = {};
        if(variablesGenerated) {
            initalVariablesObj = setupVariablesCopy = JSON.parse(JSON.stringify(setupVariables));
        }

        
        if(variablesGenerated && setupVariables.mutation == "undoMutation") {
            setupVariables = reconstructOriginal(setupVariables, setupVariables.changeHistory[setupVariables.changeHistory.length-1]);
        }

        if(variablesGenerated && setupVariables.mutation == "returnToPreviousVersion") {
            if(fullHistoryFromEvents == null) {
                noLoop();
                return;
            }
            
            let stepsBack = ceil(random(fullHistoryFromEvents.length));

            for(let i = 1; i<=stepsBack; i++) {
                setupVariables = reconstructOriginal(setupVariables, fullHistoryFromEvents[fullHistoryFromEvents.length-i]);
            }
        }


        if(!variablesGenerated){
            let aspectRatioRoll = floor(random(11));
            let possibleRatios = [0.5,9/16,16/9,0.75,1.25,1,3/2,2/3,2,9/21,21/9];
            setupVariables.aspectRatio = possibleRatios[aspectRatioRoll];
        } else if (setupVariables.mutation == "aspectRatioChange") {
            let possibleRatios = [0.5,9/16,16/9,0.75,1.25,1,3/2,2/3,2,9/21,21/9];
            possibleRatios = possibleRatios.filter(item => item !== setupVariables.aspectRatio);
            let aspectRatioRoll = floor(random(10));
            setupVariables.aspectRatio = possibleRatios[aspectRatioRoll];
        }
    
        canvasWidth = setupVariables.canvasWidth;
        canvasHeight = canvasWidth * setupVariables.aspectRatio;
        maxCurvature = canvasWidth / 12;
        
        createCanvas(canvasWidth, canvasHeight);
        background(255, 255, 255);

        let maxBaseRadius = 20/900;
        let minBaseRadius = 5/900;
        let meanBaseRadius = 12/900;

        if(!variablesGenerated){
            setupVariables.baseRadius = constrain(floor(randomGaussian(meanBaseRadius, sqrt(10))), minBaseRadius, maxBaseRadius);
        } else if (setupVariables.mutation == "baseRadiusIncrease" || setupVariables.mutation == "baseRadiusDecrease") {
            let startingRadius = setupVariables.baseRadius;
            let changeRange = 0;

            if (setupVariables.mutation == "baseRadiusIncrease") {
                changeRange = max(maxBaseRadius - startingRadius,0);
                newMeanBaseRadius = startingRadius + changeRange * (meanBaseRadius - minBaseRadius) / (maxBaseRadius - minBaseRadius);
                setupVariables.baseRadius = constrain(floor(randomGaussian(newMeanBaseRadius, sqrt(10))), startingRadius, startingRadius + changeRange);
            } else {
                changeRange = max(startingRadius - minBaseRadius,0);
                newMeanBaseRadius = minBaseRadius + changeRange * (meanBaseRadius - minBaseRadius) / (maxBaseRadius - minBaseRadius);
                setupVariables.baseRadius = constrain(floor(randomGaussian(newMeanBaseRadius, sqrt(10))), minBaseRadius, minBaseRadius + changeRange);
            }   
        }

        let baseRadius = setupVariables.baseRadius * min(canvasWidth,canvasHeight);

        if(!variablesGenerated){
            let gradientRoll = random(9);
            setupVariables.gradientType = 0;
            if (gradientRoll < 3) {
                setupVariables.gradientType = 1;
            } else if (gradientRoll < 6) {
                setupVariables.gradientType = 2;          
            }
        } else if (setupVariables.mutation == "gradientTypeChange") {
            let possibleGradients = [0,1,2];
            possibleGradients = possibleGradients.filter(item => item !== setupVariables.gradientType);
            let gradientRoll = random(6);
            if (gradientRoll < 3) {
                setupVariables.gradientType = possibleGradients[0];
            } else {
                setupVariables.gradientType = possibleGradients[1];
            }
        }
    
        let gradientType = setupVariables.gradientType;

        let chance4 = 0.6529;
        let chance0 = 6;
        let chance3 = 20;
        let chance1 = 50;
        let chance2 = 100;
        let missingDividers = 0;
        let chosenDividerIndex = -1;
        
        if(!variablesGenerated){
            let dividerRoll = random(100);
            setupVariables.dividerCount = 2;
            if (dividerRoll < chance4) {
                setupVariables.dividerCount = 4;
            } else if (dividerRoll < chance0) {
                setupVariables.dividerCount = 0;
            } else if (dividerRoll < chance3) {
                setupVariables.dividerCount = 3;
            } else if (dividerRoll < chance1) {
                setupVariables.dividerCount = 1;
            }
        } else if (setupVariables.mutation == "dividerCountChange") {
            let probabilities = [
                (chance0-chance4)/100,
                (chance1-chance3)/100,
                (chance2-chance1)/100,
                (chance3-chance0)/100,
                chance4/100
            ];
            let probabilityOrder = [4,0,3,1,2];

            let oldCount = setupVariables.dividerCount; 
            probabilityOrder = probabilityOrder.filter(item => item !== oldCount);

            let dividerRoll = random(100);
            setupVariables.dividerCount = probabilityOrder[probabilityOrder.length-1];
            if (dividerRoll < 100*probabilities[probabilityOrder[0]]/(1-probabilities[oldCount])) {
                setupVariables.dividerCount = probabilityOrder[0];
            } else if (dividerRoll < 100*probabilities[probabilityOrder[1]]/(1-probabilities[oldCount])) {
                setupVariables.dividerCount = probabilityOrder[1];
            } else if (dividerRoll < 100*probabilities[probabilityOrder[2]]/(1-probabilities[oldCount])) {
                setupVariables.dividerCount = probabilityOrder[2];
            }

            if (setupVariables.dividerCount<oldCount) {
                let difference = oldCount - setupVariables.dividerCount;

                let dividerRemovalRoll = floor(random(setupVariables.dividers.length));
                let colorRemovalRoll = floor(random(setupVariables.dividers.length));

                setupVariables.dividers.splice(dividerRemovalRoll,1);
                setupVariables.selectedcolors.splice(colorRemovalRoll,1);
            } else if (setupVariables.dividerCount>oldCount) {
                let difference = setupVariables.dividerCount - oldCount;

                missingDividers = difference;
            }
        } else if (setupVariables.mutation == "dividerMove" || setupVariables.mutation == "dividerRotate") { 
            chosenDividerIndex = floor(random(setupVariables.dividers.length));
        }

        let dividerCount = setupVariables.dividerCount;
        

        chance0 = 3;
        chance3 = 10;
        chance1 = 40;
        chance2 = 100;
        let missingCircles = 0;

        if(!variablesGenerated){
            let circleRoll = random(100);
            setupVariables.circleCount = 2;
            if (circleRoll < chance0) {
                setupVariables.circleCount = 0;
            } else if (circleRoll < chance3) {
                setupVariables.circleCount = 3;
            } else if (circleRoll < chance1) {
                setupVariables.circleCount = 1;
            }
        } else if (setupVariables.mutation == "circleCountChange") {
            let probabilities = [
                chance0/100,
                (chance1-chance3)/100,
                (chance2-chance1)/100,
                (chance3-chance0)/100,
            ];
            let probabilityOrder = [0,3,1,2];

            let oldCount = setupVariables.circleCount; 
            probabilityOrder = probabilityOrder.filter(item => item !== oldCount);

            let circleRoll = random(100);
            setupVariables.circleCount = probabilityOrder[probabilityOrder.length-1];
            if (circleRoll < 100*probabilities[probabilityOrder[0]]/(1-probabilities[oldCount])) {
                setupVariables.circleCount = probabilityOrder[0];
            } else if (circleRoll < 100*probabilities[probabilityOrder[1]]/(1-probabilities[oldCount])) {
                setupVariables.circleCount = probabilityOrder[1];
            }

            if (setupVariables.circleCount<oldCount) {
                let difference = oldCount - setupVariables.circleCount;
                
                for (let i=0; i<difference; i++) {
                    let circleRemovalRoll = floor(random(setupVariables.circles.length));
                    setupVariables.circles.splice(circleRemovalRoll,1);
                }
            } else if (setupVariables.circleCount>oldCount) {
                let difference = setupVariables.circleCount - oldCount;

                missingCircles = difference;
            }
            
        }
        
        let circleCount = setupVariables.circleCount;

        chance0 = 40;
        chance3 = 3;
        chance1 = 100;
        chance2 = 10;
        let missingLines = 0;

        if(!variablesGenerated){
            let lineRoll = random(100);
            setupVariables.lineCount = 1;
            if (lineRoll < chance3) {
                setupVariables.lineCount = 3;
            } else if (lineRoll < chance2) {
                setupVariables.lineCount = 2;
            } else if (lineRoll < chance0) {
                setupVariables.lineCount = 0;
            }
        } else if (setupVariables.mutation == "lineCountChange") {
            let probabilities = [
                (chance0-chance2)/100,
                (chance1-chance0)/100,
                (chance2-chance3)/100,
                chance3/100,
            ];
            let probabilityOrder = [3,2,0,1];

            let oldCount = setupVariables.lineCount; 
            probabilityOrder = probabilityOrder.filter(item => item !== oldCount);

            let lineRoll = random(100);
            setupVariables.lineCount = probabilityOrder[probabilityOrder.length-1];
            if (lineRoll < 100*probabilities[probabilityOrder[0]]/(1-probabilities[oldCount])) {
                setupVariables.lineCount = probabilityOrder[0];
            } else if (lineRoll < 100*probabilities[probabilityOrder[1]]/(1-probabilities[oldCount])) {
                setupVariables.lineCount = probabilityOrder[1];
            }

            if (setupVariables.lineCount<oldCount) {
                let difference = oldCount - setupVariables.lineCount;

                for (let i=0; i<difference; i++){
                    let lineRemovalRoll = floor(random(setupVariables.lines.length));
                    setupVariables.lines.splice(lineRemovalRoll,1);
                }
            } else if (setupVariables.lineCount>oldCount) {
                let difference = setupVariables.lineCount - oldCount;

                missingLines = difference;
            }
            
        }

        let lineCount = setupVariables.lineCount;
        let stdevParam = 1.96;

        if(!variablesGenerated){
            for (let i=0; i<circleCount;i++) {
                setupVariables.circles.push({
                    radius: max(0.1,min(0.9,randomGaussian(0.6, 0.6/stdevParam))),
                });
            }
        } else {
            if (missingCircles > 0) {
                for (let i=0; i<missingCircles;i++) {
                    setupVariables.circles.push({
                        radius: max(0.1,min(0.9,randomGaussian(0.6, 0.6/stdevParam))),
                    });
                }
            }
            if (setupVariables.mutation == "circleSizeIncrease"){
                let chosenIndex = floor(random(0,setupVariables.circles.length));
                setupVariables.circles[chosenIndex].radius = 
                min(
                    1,
                    max(
                        setupVariables.circles[chosenIndex].radius,
                        min(0.9,randomGaussian(0.6, 0.6/stdevParam))
                    )+max(0.05,min(0.1,randomGaussian(0.05, 0.05/stdevParam)))
                );
            }
            if (setupVariables.mutation == "circleSizeDecrease"){
                let chosenIndex = floor(random(0,setupVariables.circles.length));
                setupVariables.circles[chosenIndex].radius = 
                max(
                    0,
                    min(
                        setupVariables.circles[chosenIndex].radius,
                        max(0.1,randomGaussian(0.6, 0.6/stdevParam))
                    )-max(0.05,min(0.1,randomGaussian(0.05, 0.05/stdevParam)))
                );
            }
        }
        

        let circles = setupVariables.circles;
        

        if(!variablesGenerated){
            for (let i=0; i<lineCount;i++) {
                setupVariables.lines.push({
                    // Minimum line should be 2x2 square, equivalent to circle with radius of 1
                    ancho: floor(random(2, baseRadius)),
                    angle: random(0, PI),
                    // Maybe with a Poisson distribution centered around 30%
                    length: max(0.1,min(0.9,randomGaussian(0.6, 0.6/stdevParam))),
                });
            }
        } else {
            if (missingLines > 0) {
                for (let i=0; i<missingLines;i++) {
                    setupVariables.lines.push({
                        // Minimum line should be 2x2 square, equivalent to circle with radius of 1
                        ancho: floor(random(2, baseRadius)),
                        angle: random(0, PI),
                        // Maybe with a Poisson distribution centered around 30%
                        length: max(0.1,min(0.9,randomGaussian(0.6, 0.6/stdevParam))),
                    });
                }
            }
            if (setupVariables.mutation == "lineWidthIncrease"){
                let chosenIndex = floor(random(0,setupVariables.lines.length));
                setupVariables.lines[chosenIndex].ancho = floor(random(setupVariables.lines[chosenIndex].ancho, baseRadius));
            }
            if (setupVariables.mutation == "lineWidthDecrease"){
                let chosenIndex = floor(random(0,setupVariables.lines.length));
                setupVariables.lines[chosenIndex].ancho = floor(random(1, setupVariables.lines[chosenIndex].ancho));
            }
            if (setupVariables.mutation == "lineAngleChange"){
                let chosenIndex = floor(random(0,setupVariables.lines.length));
                let oldAngle = setupVariables.lines[chosenIndex].angle
                let newAngle = random(0, PI);
                // To make sure we at least try to show a meaningful rotation
                while (abs((newAngle-oldAngle)/PI)<0.1) {
                    newAngle = random(0, PI);
                }
                setupVariables.lines[chosenIndex].angle = newAngle;
            }
            if (setupVariables.mutation == "lineLengthIncrease"){
                let chosenIndex = floor(random(0,setupVariables.lines.length));
                setupVariables.lines[chosenIndex].length = 
                min(
                    1,
                    max(
                        setupVariables.lines[chosenIndex].length,
                        min(0.9,randomGaussian(0.6, 0.6/stdevParam))
                    )+max(0.05,min(0.1,randomGaussian(0.05, 0.05/stdevParam)))
                );
            }
            if (setupVariables.mutation == "lineLengthDecrease"){
                let chosenIndex = floor(random(0,setupVariables.lines.length));
                setupVariables.lines[chosenIndex].length = 
                max(
                    0,
                    min(
                        setupVariables.lines[chosenIndex].length,
                        max(0.1,randomGaussian(0.6, 0.6/stdevParam))
                    )-max(0.05,min(0.1,randomGaussian(0.05, 0.05/stdevParam)))
                );
            }
        }

        let lines = setupVariables.lines;

        // Generate 3 to 20 seedpoints based on an approximation of a Poisson distribution
        generateSeedpoints(baseRadius);

        if(variablesGenerated && setupVariables.mutation.includes("shape")) {
            switch (setupVariables.mutation) {
                case "shapeExpand": {
                    let seedpoints = findConvexHull(setupVariables.seedpoints);
                    let centralPoint = findCentralPoint(seedpoints);
                    let minDist = Infinity;

                    for(let i=0; i<seedpoints.length;i++) {
                        let minDistance = findMinDistanceToBoundary(
                            seedpoints[i].x, seedpoints[i].y,
                            centralPoint.x, centralPoint.y,
                            canvasWidth, canvasHeight
                        );
                        minDist = max(0,min(minDistance-seedpoints[i].radiusIncrease*baseRadius, minDist));
                    }

                    let expansionDistance = random(0.1,0.9)*minDist;

                    for(let i=0; i<seedpoints.length;i++) {
                        movePointAlongLine(
                            setupVariables.seedpoints[i].x*canvasWidth,
                            setupVariables.seedpoints[i].y*canvasHeight,
                            centralPoint.x, centralPoint.y,
                            expansionDistance, i,
                            canvasWidth, canvasHeight,1
                        );
                    }
                    
                    for(let i=0; i<setupVariables.circleCount;i++) {
                        movePointAlongLine(
                            setupVariables.circles[i].centerX*canvasWidth,
                            setupVariables.circles[i].centerY*canvasHeight,
                            centralPoint.x, centralPoint.y,
                            expansionDistance, i,
                            canvasWidth, canvasHeight,1,"circle"
                        );
                    }

                    for(let i=0; i<setupVariables.lineCount;i++) {
                        movePointAlongLine(
                            setupVariables.lines[i].centerX*canvasWidth,
                            setupVariables.lines[i].centerY*canvasHeight,
                            centralPoint.x, centralPoint.y,
                            expansionDistance, i,
                            canvasWidth, canvasHeight,1,"line"
                        );
                    }

                    break;
                }
                case "shapeShrink": {
                    let seedpointsShrink = findConvexHull(setupVariables.seedpoints);
                    let centralPoint = findCentralPoint(seedpointsShrink);
                    let maxDist = Infinity;

                    for(let i=0; i<seedpointsShrink.length;i++) {
                        let maxDistance = dist(
                            seedpointsShrink[i].x, seedpointsShrink[i].y,
                            centralPoint.x, centralPoint.y
                        );
                        maxDist = min(maxDistance, maxDist);
                    }

                    let shrinkDistance = random(0.05,0.25)*maxDist;
                    for(let i=0; i<seedpointsShrink.length;i++) {
                        movePointAlongLine(
                            setupVariables.seedpoints[i].x*canvasWidth,
                            setupVariables.seedpoints[i].y*canvasHeight,
                            centralPoint.x, centralPoint.y,
                            shrinkDistance, i,
                            canvasWidth, canvasHeight,-1
                        );
                    }

                    for(let i=0; i<setupVariables.circleCount;i++) {
                        movePointAlongLine(
                            setupVariables.circles[i].centerX*canvasWidth,
                            setupVariables.circles[i].centerY*canvasHeight,
                            centralPoint.x, centralPoint.y,
                            shrinkDistance, i,
                            canvasWidth, canvasHeight,-1,"circle"
                        );
                    }

                    for(let i=0; i<setupVariables.lineCount;i++) {
                        movePointAlongLine(
                            setupVariables.lines[i].centerX*canvasWidth,
                            setupVariables.lines[i].centerY*canvasHeight,
                            centralPoint.x, centralPoint.y,
                            shrinkDistance, i,
                            canvasWidth, canvasHeight,-1,"line"
                        );
                    }
                    break;
                }
                case "shapeMakeWider": {
                    let seedpoints = findConvexHull(setupVariables.seedpoints);
                    let centralX = seedpoints.reduce((acc, obj) => acc + obj.x, 0)/seedpoints.length/canvasWidth;
                    let minDist = Infinity;

                    for(let i=0; i<seedpoints.length;i++) {
                        if(setupVariables.seedpoints[i].x > centralX) {
                            let minDistance = 1 - setupVariables.seedpoints[i].x;
                            minDist = max(0,min((minDistance*canvasWidth-setupVariables.seedpoints[i].radiusIncrease*baseRadius)/canvasWidth/(setupVariables.seedpoints[i].x - centralX), minDist));
                        } else {
                            let minDistance = setupVariables.seedpoints[i].x;
                            minDist = max(0,min((minDistance*canvasWidth-setupVariables.seedpoints[i].radiusIncrease*baseRadius)/canvasWidth/(centralX - setupVariables.seedpoints[i].x), minDist));
                        }
                    }

                    let expansionDistance = random(0.1,0.9)*minDist;

                    for(let i=0; i<seedpoints.length;i++) {
                        if(setupVariables.seedpoints[i].x > centralX) {
                            setupVariables.seedpoints[i].x = (setupVariables.seedpoints[i].x - centralX)*(1 + expansionDistance)+centralX;
                        } else {
                            setupVariables.seedpoints[i].x = centralX - (centralX - setupVariables.seedpoints[i].x)*(1 + expansionDistance);
                        }
                    }
                    
                    for(let i=0; i<setupVariables.circleCount;i++) {
                        if(setupVariables.circles[i].centerX > centralX) {
                            setupVariables.circles[i].centerX = (setupVariables.circles[i].centerX - centralX)*(1 + expansionDistance)+centralX;
                        } else {
                            setupVariables.circles[i].centerX = centralX - (centralX - setupVariables.circles[i].centerX)*(1 + expansionDistance);
                        }
                    }

                    for(let i=0; i<setupVariables.lineCount;i++) {
                        if(setupVariables.lines[i].centerX > centralX) {
                            setupVariables.lines[i].centerX = (setupVariables.lines[i].centerX - centralX)*(1 + expansionDistance)+centralX;
                        } else {
                            setupVariables.lines[i].centerX = centralX - (centralX - setupVariables.lines[i].centerX)*(1 + expansionDistance);
                        }
                    }
                    break;
                }
                case "shapeMakeNarrower":{
                    let seedpoints = findConvexHull(setupVariables.seedpoints);
                    let centralX = seedpoints.reduce((acc, obj) => acc + obj.x, 0)/seedpoints.length/canvasWidth;
                    let minDist = Infinity;

                    let shrinkFactor = random(0.75,0.95);

                    for(let i=0; i<seedpoints.length;i++) {
                        if(setupVariables.seedpoints[i].x  > centralX) {
                            setupVariables.seedpoints[i].x = (setupVariables.seedpoints[i].x - centralX)*shrinkFactor+centralX;
                        } else {
                            setupVariables.seedpoints[i].x = centralX - (centralX - setupVariables.seedpoints[i].x)*shrinkFactor;
                        }
                    }
                    
                    for(let i=0; i<setupVariables.circleCount;i++) {
                        if(setupVariables.circles[i].centerX > centralX) {
                            setupVariables.circles[i].centerX = (setupVariables.circles[i].centerX - centralX)*shrinkFactor+centralX;
                        } else {
                            setupVariables.circles[i].centerX =  centralX - (centralX - setupVariables.circles[i].centerX)*shrinkFactor;
                        }
                    }

                    for(let i=0; i<setupVariables.lineCount;i++) {
                        if(setupVariables.lines[i].centerX > centralX) {
                            setupVariables.lines[i].centerX = (setupVariables.lines[i].centerX - centralX)*shrinkFactor+centralX;
                        } else {
                            setupVariables.lines[i].centerX = centralX - (centralX - setupVariables.lines[i].centerX)*shrinkFactor;
                        }
                    }
                    break;
                }
                case "shapeMakeHigher":{
                    let seedpoints = findConvexHull(setupVariables.seedpoints);
                    let centralY = seedpoints.reduce((acc, obj) => acc + obj.y, 0)/seedpoints.length/canvasHeight;
                    let minDist = Infinity;

                    for(let i=0; i<seedpoints.length;i++) {
                        if(setupVariables.seedpoints[i].y > centralY) {
                            let minDistance = 1 - setupVariables.seedpoints[i].y;
                            minDist = max(0,min((minDistance*canvasHeight-setupVariables.seedpoints[i].radiusIncrease*baseRadius)/canvasHeight/(setupVariables.seedpoints[i].y - centralY), minDist));
                        } else {
                            let minDistance = setupVariables.seedpoints[i].y;
                            minDist = max(0,min((minDistance*canvasHeight-setupVariables.seedpoints[i].radiusIncrease*baseRadius)/canvasHeight/(centralY - setupVariables.seedpoints[i].y), minDist));
                        }
                    }

                    let expansionDistance = random(0.1,0.9)*minDist;

                    for(let i=0; i<seedpoints.length;i++) {
                        if(setupVariables.seedpoints[i].y > centralY) {
                            setupVariables.seedpoints[i].y = (setupVariables.seedpoints[i].y - centralY)*(1 + expansionDistance)+centralY;
                        } else {
                            setupVariables.seedpoints[i].y = centralY - (centralY - setupVariables.seedpoints[i].y)*(1 + expansionDistance);
                        }
                    }
                    
                    for(let i=0; i<setupVariables.circleCount;i++) {
                        if(setupVariables.circles[i].centerY > centralY) {
                            setupVariables.circles[i].centerY = (setupVariables.circles[i].centerY - centralY)*(1 + expansionDistance)+centralY;
                        } else {
                            setupVariables.circles[i].centerY = centralY - (centralY - setupVariables.circles[i].centerY)*(1 + expansionDistance);
                        }
                    }

                    for(let i=0; i<setupVariables.lineCount;i++) {
                        if(setupVariables.lines[i].centerY > centralY) {
                            setupVariables.lines[i].centerY = (setupVariables.lines[i].centerY - centralY)*(1 + expansionDistance)+centralY;
                        } else {
                            setupVariables.lines[i].centerY = centralY - (centralY - setupVariables.lines[i].centerY)*(1 + expansionDistance);
                        }
                    }
                    break;
                }
                case "shapeMakeShorter":{
                    let seedpoints = findConvexHull(setupVariables.seedpoints);
                    let centralY = seedpoints.reduce((acc, obj) => acc + obj.y, 0)/seedpoints.length/canvasHeight;
                    let minDist = Infinity;

                    let shrinkFactor = random(0.75,0.95);

                    for(let i=0; i<seedpoints.length;i++) {
                        if(setupVariables.seedpoints[i].y  > centralY) {
                            setupVariables.seedpoints[i].y = (setupVariables.seedpoints[i].y - centralY)*shrinkFactor+centralY;
                        } else {
                            setupVariables.seedpoints[i].y = centralY - (centralY - setupVariables.seedpoints[i].y)*shrinkFactor;
                        }
                    }
                    
                    for(let i=0; i<setupVariables.circleCount;i++) {
                        if(setupVariables.circles[i].centerY > centralY) {
                            setupVariables.circles[i].centerY = (setupVariables.circles[i].centerY - centralY)*shrinkFactor+centralY;
                        } else {
                            setupVariables.circles[i].centerY =  centralY - (centralY - setupVariables.circles[i].centerY)*shrinkFactor;
                        }
                    }

                    for(let i=0; i<setupVariables.lineCount;i++) {
                        if(setupVariables.lines[i].centerY > centralY) {
                            setupVariables.lines[i].centerY = (setupVariables.lines[i].centerY - centralY)*shrinkFactor+centralY;
                        } else {
                            setupVariables.lines[i].centerY = centralY - (centralY - setupVariables.lines[i].centerY)*shrinkFactor;
                        }
                    }
                    break;
                    }
                case "shapeChangeCurveCenters":{
                    for(let i=0; i<setupVariables.seedpoints.length;i++) {
                        setupVariables.seedpoints[i].percentageDistance = round(random(0, 1), 7);
                    }
                    break;
                    }
                case "shapeIncreaseConcavity":{
                    for(let i=0; i<setupVariables.seedpoints.length;i++) {
                        setupVariables.seedpoints[i].curvature = min(2,random(setupVariables.seedpoints[i].curvature*1.1, 1.5));
                    }
                    break;
                    }
                case "shapeReduceConcavity":{
                    for(let i=0; i<setupVariables.seedpoints.length;i++) {
                        setupVariables.seedpoints[i].curvature = max(0.375,random(0.5, setupVariables.seedpoints[i].curvature/1.1));
                    }
                    break;
                    }
                case "shapeChangeRadiuses":{
                    // 50/50 chance to increase or decrease for each seedpoint, then use same code as for individual seedpoints
                    // TBD - could be refactored so code to increase or decrease individual seedpoints is a separate functions since this is now duplicated
                    for(let i=0; i<setupVariables.seedpoints.length;i++) {
                        let bigOrSmall = random();

                        if(bigOrSmall<0.5) {
                            setupVariables.seedpoints[i].radiusIncrease = random(setupVariables.seedpoints[i].radiusIncrease*1.1,PI);
                            //an increase might push us out of the canvas, we need to double check. A decrease never will.
                            radius = baseRadius * setupVariables.seedpoints[i].radiusIncrease;
                            if((setupVariables.seedpoints[i].x*canvasWidth + radius) > canvasWidth) {
                                setupVariables.seedpoints[i].radiusIncrease = (canvasWidth - setupVariables.seedpoints[i].x*canvasWidth)/baseRadius;
                            };
                            if((setupVariables.seedpoints[i].x*canvasWidth - radius) < 0) {
                                setupVariables.seedpoints[i].radiusIncrease = (setupVariables.seedpoints[i].x*canvasWidth)/baseRadius;
                            };
                            if((setupVariables.seedpoints[i].y*canvasHeight + radius) > canvasHeight) {
                                setupVariables.seedpoints[i].radiusIncrease = (canvasHeight - setupVariables.seedpoints[i].y*canvasHeight)/baseRadius;
                            };
                            if((setupVariables.seedpoints[i].y*canvasHeight - radius) < 0) {
                                setupVariables.seedpoints[i].radiusIncrease = (setupVariables.seedpoints[i].y*canvasHeight)/baseRadius;
                            };
                        } else {
                            setupVariables.seedpoints[i].radiusIncrease = random(1,setupVariables.seedpoints[i].radiusIncrease/1.1);
                        }
                    }
                    break;
                    }
                case "shapeMove":{
                    let maxNegX = 1;
                    let maxPosX = 1;
                    let maxNegY = 1;
                    let maxPosY = 1;
                    for(let i=0; i<setupVariables.seedpoints.length;i++) {
                        radius = baseRadius * setupVariables.seedpoints[i].radiusIncrease;
                        maxNegX = min(maxNegX,(setupVariables.seedpoints[i].x*canvasWidth - radius)/canvasWidth);
                        maxPosX = min(maxPosX,(canvasWidth - radius - setupVariables.seedpoints[i].x*canvasWidth)/canvasWidth);
                        maxNegY = min(maxNegY,(setupVariables.seedpoints[i].y*canvasHeight - radius)/canvasHeight);
                        maxPosY = min(maxPosY,(canvasHeight - radius - setupVariables.seedpoints[i].y*canvasHeight)/canvasHeight);
                    }

                    let xRange = maxNegX + maxPosX;
                    let xOffset = random(-maxNegX+xRange*0.1,maxPosX-xRange*0.1);
                    let yRange = maxNegY + maxPosY;
                    let yOffset = random(-maxNegY+yRange*0.1,maxPosY-yRange*0.1);

                    
                    for(let i=0; i<setupVariables.seedpoints.length;i++) {
                        setupVariables.seedpoints[i].x += xOffset;
                        setupVariables.seedpoints[i].y += yOffset;
                    }

                    for(let i=0; i<setupVariables.circles.length;i++) {
                        setupVariables.circles[i].centerX += xOffset;
                        setupVariables.circles[i].centerY += yOffset;
                    }

                    for(let i=0; i<setupVariables.lines.length;i++) {
                        setupVariables.lines[i].centerX += xOffset;
                        setupVariables.lines[i].centerY += yOffset;
                    }

                    for(let i=0; i<setupVariables.dividers.length;i++) {
                        setupVariables.dividers[i].startPointX += xOffset;
                    }

                    break;
                    }
            }
        }

        if(variablesGenerated && setupVariables.mutation == "rotate") {
            setupVariables.seedpoints = rotateShape(setupVariables.seedpoints, baseRadius);
        }

        // Sort seedpoints based on their angle to the central point
        let seedpoints = findConvexHull(setupVariables.seedpoints);

        // Find the central point of the resulting shape
        let centralPoint = findCentralPoint(seedpoints);

        // Arrays to track whether the left and right edges of each seedpoint has been connected
        let connectedLeftEdges = new Array(seedpoints.length).fill(false);
        let connectedRightEdges = new Array(seedpoints.length).fill(false);

        noStroke();
        // Array of possible colors for each subsection

        let originalPalette = ["#fc1a4a", "#75d494", "#2587c3", "#f2c945", "#000000", "#FFFFFF"];

        if(!variablesGenerated) {
            setupVariables.colors = originalPalette;
        } else if (setupVariables.mutation == "paletteChangeOne") {
            let letters = '0123456789ABCDEF';
            let newColor = '#';
            for (let i = 0; i < 6; i++) {
                newColor += letters[floor(random(16))];
            }
            let oldColorIndex = floor(random(setupVariables.colors.length));
            let oldColor = setupVariables.colors[oldColorIndex];

            let matchingSelectedColors = [];
            for(let j=0; j<setupVariables.selectedcolors.length;j++) {
                if(setupVariables.selectedcolors[j] == oldColor) {
                    matchingSelectedColors.push(j);
                }
            }

            setupVariables.colors[oldColorIndex] = newColor;

            if (matchingSelectedColors.length > 0) {
                setupVariables.selectedcolors[matchingSelectedColors[floor(random(matchingSelectedColors.length))]] = newColor;
            }
        } else if (setupVariables.mutation == "paletteChangeAll") {
            let selectedcolorsByIndex = [];
            for(let j=0; j<setupVariables.selectedcolors.length; j++) {
                selectedcolorsByIndex[j] = [];
                for(let k=0; k<setupVariables.colors.length; k++) {
                    if(setupVariables.selectedcolors[j] == setupVariables.colors[k]) {
                        selectedcolorsByIndex[j].push(k);
                    }
                }
            }

            let letters = '0123456789ABCDEF';
            for(let h = 0; h<setupVariables.colors.length; h++) {
                let newColor = '#';
                for (let i = 0; i < 6; i++) {
                    newColor += letters[floor(random(16))];
                }
                let oldColorIndex = h;
                let oldColor = setupVariables.colors[oldColorIndex];
                setupVariables.colors[oldColorIndex] = newColor;
            }

            for(let j=0; j<setupVariables.selectedcolors.length; j++) {
                setupVariables.selectedcolors[j] = setupVariables.colors[selectedcolorsByIndex[j][floor(random(selectedcolorsByIndex[j].length))]];
            }

        } else if (setupVariables.mutation == "paletteCombineOne") {
            let oldColorIndex = floor(random(setupVariables.colors.length));
            let oldColor = setupVariables.colors[oldColorIndex];
            let remainingIndices = [...Array(6).keys()];
            remainingIndices.splice(oldColorIndex, 1);
            let combinedColor = setupVariables.colors[remainingIndices[floor(random(remainingIndices.length))]];
            let newColor = mixColors(oldColor, combinedColor);
            
            let matchingSelectedColors = [];
            for(let j=0; j<setupVariables.selectedcolors.length;j++) {
                if(setupVariables.selectedcolors[j] == oldColor) {
                    matchingSelectedColors.push(j);
                }
            }

            setupVariables.colors[oldColorIndex] = newColor;

            if (matchingSelectedColors.length > 0) {
                setupVariables.selectedcolors[matchingSelectedColors[floor(random(matchingSelectedColors.length))]] = newColor;
            }
        } else if (setupVariables.mutation == "paletteCombineAll") {
            let newColorPalette = [];
            let newSelectedColors = [];
            let selectedcolorsByIndex = [];
            for(let j=0; j<setupVariables.selectedcolors.length; j++) {
                selectedcolorsByIndex[j] = [];
                for(let k=0; k<setupVariables.colors.length; k++) {
                    if(setupVariables.selectedcolors[j] == setupVariables.colors[k]) {
                        selectedcolorsByIndex[j].push(k);
                    }
                }
            }

            for(let h = 0; h<setupVariables.colors.length; h++) {
                let oldColorIndex = h;
                let oldColor = setupVariables.colors[oldColorIndex];
                let remainingIndices = [...Array(6).keys()];
                remainingIndices.splice(oldColorIndex, 1);
                let combinedColor = setupVariables.colors[remainingIndices[floor(random(remainingIndices.length))]];
                let newColor = mixColors(oldColor, combinedColor);

                newColorPalette.push(newColor);
            }

            setupVariables.colors = newColorPalette;

            for(let j=0; j<setupVariables.selectedcolors.length; j++) {
                newSelectedColors.push(newColorPalette[selectedcolorsByIndex[j][floor(random(selectedcolorsByIndex[j].length))]]);
            }

            setupVariables.selectedcolors = newSelectedColors;            
        } else if (setupVariables.mutation == "paletteResetOne") {
            let oldColorIndex = floor(random(setupVariables.colors.length));
            let oldColor = setupVariables.colors[oldColorIndex];

            let matchingSelectedColors = [];
            for(let j=0; j<setupVariables.selectedcolors.length;j++) {
                if(setupVariables.selectedcolors[j] == oldColor) {
                    matchingSelectedColors.push(j);
                }
            }

            let newColor = originalPalette[oldColorIndex];
            setupVariables.colors[oldColorIndex] = newColor;

            if (matchingSelectedColors.length > 0) {
                setupVariables.selectedcolors[matchingSelectedColors[floor(random(matchingSelectedColors.length))]] = newColor;
            }
        } else if (setupVariables.mutation == "paletteResetAll") {
            let selectedcolorsByIndex = [];
            for(let j=0; j<setupVariables.selectedcolors.length; j++) {
                selectedcolorsByIndex[j] = [];
                for(let k=0; k<setupVariables.colors.length; k++) {
                    if(setupVariables.selectedcolors[j] == setupVariables.colors[k]) {
                        selectedcolorsByIndex[j].push(k);
                    }
                }
            }

            setupVariables.colors = originalPalette;

            for(let j=0; j<setupVariables.selectedcolors.length; j++) {
                setupVariables.selectedcolors[j] = originalPalette[selectedcolorsByIndex[j][floor(random(selectedcolorsByIndex[j].length))]];
            }

        } else if(setupVariables.mutation == "paletteShuffle") {
            let shuffledArray = [...Array(setupVariables.colors.length).keys()];
            for (let j = shuffledArray.length - 1; j > 0; j--) {
                let k = floor(random() * (j + 1));
                let temp = shuffledArray[j];
                shuffledArray[j] = shuffledArray[k];
                shuffledArray[k] = temp;
            }

            let newColorPalette = [];
            let newSelectedColors = [];
            let selectedcolorsByIndex = [];
            for(let j=0; j<setupVariables.selectedcolors.length; j++) {
                selectedcolorsByIndex[j] = [];
                for(let k=0; k<setupVariables.colors.length; k++) {
                    if(setupVariables.selectedcolors[j] == setupVariables.colors[k]) {
                        selectedcolorsByIndex[j].push(k);
                    }
                }
            }


            for(let j = 0; j<shuffledArray.length; j++) {
                let newColor = setupVariables.colors[shuffledArray[j]];
                newColorPalette.push(newColor);
            }

            setupVariables.colors = newColorPalette;

            for(let j=0; j<setupVariables.selectedcolors.length; j++) {
                newSelectedColors.push(newColorPalette[selectedcolorsByIndex[j][floor(random(selectedcolorsByIndex[j].length))]]);
            }

            setupVariables.selectedcolors = newSelectedColors;
        }

        let colors = setupVariables.colors;

        if(!variablesGenerated) {
            setupVariables.selectedcolors = [colors[floor(random(colors.length))]];
        }

        let selectedcolors = setupVariables.selectedcolors;
        fill(0,0,0);
        
        beginShape();
        // Draw seedpoints and connect them
        for (let i = 0; i < seedpoints.length; i++) {
            let currentSeed = seedpoints[i];
            connectedRightEdges[i] = true; // Mark the right edge as connected
            let nextSeedIndex = findNextUnconnectedSeed(currentSeed, seedpoints, connectedLeftEdges, connectedRightEdges, i);
        
            // Draw seedpoint
            //drawSemicircle(currentSeed.x, currentSeed.y, baseRadius, centralPoint);
            let seedPointAngle = atan2(centralPoint.y - currentSeed.y, centralPoint.x - currentSeed.x) + PI / 2;
            //Calculate the edges of the semicircle
            let radius = baseRadius * currentSeed.radiusIncrease;
            let startX = currentSeed.x + cos(seedPointAngle) * radius;
            let startY = currentSeed.y + sin(seedPointAngle) * radius;
            let endX = currentSeed.x - cos(seedPointAngle) * radius;
            let endY = currentSeed.y - sin(seedPointAngle) * radius;
            let midX = (startX + endX) / 2;
            let midY = (startY + endY) / 2;
            // Calculate the angle towards centralPoint
                let controlAngle = atan2(centralPoint.y - midY, centralPoint.x - midX);
            // Calculate control point position at a distance of curvature from the midpoint
                let controlX = midX - cos(controlAngle) * radius * 2;
                let controlY = midY - sin(controlAngle) * radius * 2;

            // Draw the arc
            drawArc(startX, startY, endX, endY, controlX, controlY);
        
            if (nextSeedIndex ==-1) {
                nextSeedIndex = connectedLeftEdges.indexOf(false);
            }
        
            if (nextSeedIndex !== -1) {
                let nextSeed = seedpoints[nextSeedIndex];
                connectedLeftEdges[nextSeedIndex] = true; // Mark the left edge as connected
            
                // Calculate the angle to face the edges of the canvas
                let currentAngle = atan2(centralPoint.y - currentSeed.y, centralPoint.x - currentSeed.x) + PI / 2;
                let nextAngle = atan2(centralPoint.y - nextSeed.y, centralPoint.x - nextSeed.x) + PI / 2;
                let nextRadius = baseRadius * nextSeed.radiusIncrease;
                //Calculate the edges of the arcs
                let currentX = currentSeed.x - cos(currentAngle) * radius;
                let currentY = currentSeed.y - sin(currentAngle) * radius;
                let nextX = nextSeed.x + cos(nextAngle) * nextRadius;
                let nextY = nextSeed.y + sin(nextAngle) * nextRadius;
                
                // Calculate control point for the Bezier curve
                let midX = lerp(currentX, nextX, currentSeed.percentageDistance);
                let midY = lerp(currentY, nextY, currentSeed.percentageDistance);
                
                // Calculate the angle towards centralPoint
                    let controlAngle = atan2(centralPoint.y - midY, centralPoint.x - midX);
                
                // Calculate control point position at a distance of curvature from the midpoint
                    let controlX = midX + cos(controlAngle) * currentSeed.curvature;
                    let controlY = midY + sin(controlAngle) * currentSeed.curvature;

                // Draw the arc
                drawArc(currentX, currentY, nextX, nextY, controlX, controlY);
            }
        }
        endShape();
        
        loadPixels(); // Load the pixel data from the canvas
     
        // Array to store pixel positions matching the target color
        let minX = createVector(canvasWidth, 0);
        let maxX = createVector(0, 0);

        // Loop through each pixel in the canvas
        for (let x = 0; x < width; x++) {
            canvasArray[x] = [];
            shapeArray[x] = [];
            weightsArray[x] = [];
            linesToRightArray[x] = [];
            for (let y = 0; y < height; y++) {
                let pixelIndex = (x + y * width) * 4; // Calculate the pixel index in the pixel array

                // Check if the current pixel color matches the target color
                if (
                    pixels[pixelIndex] === 0 &&
                    pixels[pixelIndex + 1] === 0 &&
                    pixels[pixelIndex + 2] === 0
                ) {
                    // If it matches, store the pixel position in the array
                    matchingPixels.push(createVector(x, y));
            
                    canvasArray[x][y] = {
                        r: pixels[pixelIndex],
                        g: pixels[pixelIndex+1],
                        b: pixels[pixelIndex+2],
                    };
                
                    shapeArray[x][y] = 1;

                    weightsArray[x][y] = 0;
                    linesToRightArray[x][y] = 0;

                    if(x>maxX.x) {
                        maxX = createVector(x, y);
                    }
                    if (x<minX.x) {
                        minX = createVector(x, y);
                    }
                } else {
                    //otherwise check if it is border and not background
                    if (
                        pixels[pixelIndex] !== 255 &&
                        pixels[pixelIndex +1] !== 255 &&
                        pixels[pixelIndex +2] !== 255
                    ) {
                        // If does not match, store the pixel position in the array
                        borderPixels.push({
                            x: x,
                            y: y,
                            r: pixels[pixelIndex],
                            g: pixels[pixelIndex+1],
                            b: pixels[pixelIndex+2],
                        });
                        shapeArray[x][y] = 0;
                    } else{
                        //this means it is background
                        shapeArray[x][y] = 0;
                        setPixelColor(x,y,"#EBE5D9");
                    }
                }
            }
        }

        // Now, 'matchingPixels' array contains the positions of all pixels with RGB(0, 0, 0)
        //minX is the left edge of the shape and maxX is the right side of the shape

        //Now we will draw lines to split the area in 1-4 subareas
        for (let i = 0; i < dividerCount; i++){
            //add a color for the new subsection

            if(!variablesGenerated || missingDividers>i){

                if(missingDividers>i) {
                    let randomIndex = floor(random(setupVariables.selectedcolors.length+1));
                    setupVariables.selectedcolors.splice(randomIndex,0,colors[floor(random(colors.length))]);
                } else {
                    setupVariables.selectedcolors.push(colors[floor(random(colors.length))]);
                };

                selectedcolors = setupVariables.selectedcolors;

                // Select a random point on the top edge
                let startPointX = floor(random(width));
                let angle = random(); // Random angle in radians (180 degrees) as % of range between min and max angle

                setupVariables.dividers[setupVariables.dividers.length] = {
                    startPointX: startPointX / canvasWidth,
                    angle: angle
                }
            }
            
            let startPointX = setupVariables.dividers[i].startPointX * canvasWidth;

            let minAngle = atan2(minX.y, minX.x - startPointX);
            let maxAngle = atan2(maxX.y, maxX.x - startPointX);
            
            // Ensure angles are positive
            minAngle = (minAngle + TWO_PI);
            maxAngle = (maxAngle + TWO_PI);
            
            // Ensure minAngle is smaller than maxAngle
            if (minAngle > maxAngle) {
                let temp = minAngle;
                minAngle = maxAngle;
                maxAngle = temp;
            }

            let angle = setupVariables.dividers[i].angle * (maxAngle - minAngle) + minAngle;

            if(chosenDividerIndex == i && setupVariables.mutation == "dividerMove") {
                let chosenDivider = setupVariables.dividers[chosenDividerIndex];

                let x0 = minX.x; // x-coordinate of the point
                let y0 = minX.y; // y-coordinate of the point
                let m = tan(angle);
                let minTopX = x0 - (y0 / m);

                let x1 = maxX.x; // x-coordinate of the point
                let y1 = maxX.y; // y-coordinate of the point
                let maxTopX = x1 - (y1 / m);

                if(minTopX>maxTopX) {
                    let temp = maxTopX;
                    maxTopX = minTopX;
                    minTopX = temp;
                }

                setupVariables.dividers[i].startPointX = floor(random(max(0,minTopX),min(canvasWidth,maxTopX+1)))/canvasWidth;

                startPointX = setupVariables.dividers[i].startPointX * canvasWidth;
            } else if(chosenDividerIndex == i && setupVariables.mutation == "dividerRotate") {
                let newRand = random();
                setupVariables.dividers[i].angle = newRand;
                angle = newRand * (maxAngle - minAngle) + minAngle;
            }


            drawLine(startPointX, angle, minAngle, maxAngle);
        }
        


        //Now that we have the lines, we will divide the matchingPixels array into subareas and paint each one a different color
        
        //Create a first empty array because sometimes we have a shape with 0 pixels with 0 lines to its right
        let subArrays = [[]];
        let borderArrays = [];

        // Loop through each pixel in the matchingPixels array
        for (let i = 0; i < matchingPixels.length; i++) {
            let pixel = matchingPixels[i];

            // Count the number of lines to the right of the pixel
            let lineCountResult = countLinesToRight(pixel);
        
            let linesToRight = lineCountResult[0];
            let borderWeight = lineCountResult[1];

            // Color in the pixel correspondingly
            let pixelColor = color(selectedcolors[linesToRight]);

            // Instead of setting the color directly, we will just store it in the canvasArray for now - since we now have to do antialiasing
            canvasArray[pixel.x][pixel.y] = {
                r: red(pixelColor),
                g: green(pixelColor),
                b: blue(pixelColor),
            };
        
            // If the sub-array for the count doesn't exist, create it
            if (!subArrays[linesToRight]) {
                subArrays[linesToRight] = [];
            }

            // Add the pixel to the corresponding sub-array
            subArrays[linesToRight].push(pixel);
            // Also add the linesToRight to the corresponding array where we track it
            linesToRightArray[pixel.x][pixel.y] = linesToRight;
        
            // If the borderArray for the count doesn't exist, create it
            if (!borderArrays[linesToRight]) {
                borderArrays[linesToRight] = [];
            }

            // If the pixel is a border, add it to the corresponding borderArray and to weightsArray
            if(borderWeight !== 0 ) {
                borderArrays[linesToRight].push({
                    x: pixel.x,
                    y: pixel.y,
                    weight: borderWeight
                });

                weightsArray[pixel.x][pixel.y] = borderWeight;
            }
        }
        
        // Add gradient to the shape if it has more than one color
        if (subArrays.length == 1 || gradientType == 0){    
            // Apply antialiasing to the pixel colors stored in canvasArray and modifies these colors accordingly
            applyAntialiasing(10);
        } else if (gradientType == 1) {
            // As an alternative, color the pixels in each subsection of the shape using a gradient that goes either from the rightmost or leftmost edge of the shape towards the next closest line and from each line to the middle line between it and each adjacent line. We should write a function that recalculates the color of each pixel inside the shape (as defined by those with a value of 1 for their coordinates in shapeArray) such that we get these gradients
            let distancesArray = [];
            let maxDistances = [];
            let splitArray = false;
            let splitFlagsArray = [];
            let reverseDistancesArray = [];
            //deletable I think
            let maxReverseDistances = [];
            let maxIntermediateDistances = [];
            let maxIntermediateReverseDistances = [];
            let maxDistances2 = [];
            let lineIndex = 0;
            let reverseLineIndex = 0;
            let maxIntermediateLineIndices = [];
            let maxIntermediateReverseLineIndices = [];
            // For each point in each subarray, calculate the distance to the first line that we cross when ray tracing to the right.
            // Store this information in the distancesArray, that should have values only for points inside the shape.
            // We need to treat subArrays[0] separately, there we will have to ray trace backwards and do the opposite gradient to achieve the desired effect.
            // For subArrays that are not subArrays[0] or subArrays[subArrays.length-1] we need to ray trace both ways, compare the two distances and store this information in subArrayHalf

            for (let i = 0;i<subArrays.length; i++) {
                maxDistances [i] = 0;
                maxDistances2 [i] = [];
                //deletable I think
                maxReverseDistances[i] = 0;
                distancesArray[i] = [];
                reverseDistancesArray [i] = [];
                splitFlagsArray[i] = [];
                maxIntermediateDistances[i] = [];
                maxIntermediateReverseDistances[i] = [];
                maxIntermediateLineIndices[i] = [];
                maxIntermediateReverseLineIndices[i] = [];
                if(i == 0 || i == (subArrays.length -1)){
                    splitArray = false;
                }else {
                    splitArray = true;
                }

                for(let j = 0; j < subArrays[i].length; j++) {
                    let pixel = subArrays[i][j];
                    let direction = 1;
                    
                    if (!maxIntermediateDistances[i][pixel.y]) {
                        maxIntermediateDistances[i][pixel.y] = 0;
                    }
                    if (!maxIntermediateReverseDistances[i][pixel.y]) {
                        maxIntermediateReverseDistances[i][pixel.y] = 0;
                    }
                    if (!maxDistances2[i][pixel.y]) {
                        maxDistances2[i][pixel.y] = 0;
                    }
                    
                    if( i == 0) {
                        direction = -1;
                    }
                    
                    let distance = Infinity;
                    let reverseDistance = Infinity;

                    [distance, lineIndex] = findFirstLineToRightDistance (pixel, direction);
                
                    [reverseDistance, reverseLineIndex] =  findFirstLineToRightDistance (pixel, direction * -1);

                    if(distance < Infinity) {
                        maxIntermediateLineIndices[i][pixel.y] = lineIndex;
                    
                        if (reverseDistance < Infinity && splitArray) {
                            // These splits are in reverse order since selectedcolors is colors ordered from right to left
                            if(distance > reverseDistance) {
                                //this is the left side of the subarray
                                splitFlagsArray[i][j] = 1;
                            } else {
                                //this is the right side of the subarray
                                splitFlagsArray[i][j] = -1;
                            }
                            maxIntermediateReverseLineIndices[i][pixel.y] = reverseLineIndex;
                        } else {
                            splitFlagsArray[i][j] = 0;
                        }
                    
                        distancesArray[i][j] = distance;
                    
                        if (distance > maxDistances[i] && splitFlagsArray[i][j] == 0) {
                            maxDistances[i] = distance;
                        }

                        if (distance > maxDistances2[i][pixel.y] && splitFlagsArray[i][j] == 0) {
                            maxDistances2[i][pixel.y] = distance;
                        }
                                
                        if (distance > maxIntermediateDistances[i][pixel.y] && splitFlagsArray[i][j] == -1) {
                            maxIntermediateDistances[i][pixel.y] = distance;
                        }
                    } else {
                        maxIntermediateReverseLineIndices[i] = reverseLineIndex;
                    }
                
                    if(reverseDistance < Infinity && splitFlagsArray[i][j] == 1) {
                        distancesArray[i][j] = reverseDistance;
                    
                        if (reverseDistance > maxIntermediateReverseDistances[i][pixel.y]) {
                            maxIntermediateReverseDistances[i][pixel.y] = reverseDistance;
                        }
                    }
                
                }  
            
                // Now we loop through the maxIntermediateDistances[i] and maxIntermediateReverseDistances[i] array and fix it up so that we don't have the gradient bordering the edge of the shape.
                // We should skip this for the leftmost and rightmost subareas for a bit of extra efficiency
                if(!splitArray) {
                    continue;
                }

                // Each of these array's indexes signify the y value for that maxium, and the value stored at that index is the x value relative to the line that limits this area of the shape
                // This Y value should be increasing linearly for the whole array, but X may not always be linear as well.
                // We should figure out if there is a part of the array where it is not increasing linearly, and if so make it linear / maintain the last prior value where it increased linearly
                // The first step to do this is figuring out which half of the boundary is linear
                // Assumption: linear part will always reach one of the two shape edges - I think this is always the case but could not prove it 100%
                // We calculate the total number of values in each array of max distances - we have to do this because these two arrays do not start at 0.
            
                for (let j = 1; j < maxIntermediateReverseDistances[i].length; j++) {
                    if(maxIntermediateLineIndices[i][j] !== undefined && maxIntermediateReverseLineIndices[i][j] !== undefined){
                            //this should only happen if at this y coordinate, the line that divides the two halves of the subarray is outside of the shape
                            //the whole linear regression above tries to find this line but does not seem to be working
                            //we can maybe instead try to find the midpoint between the two points that cross this y on the bordering divider lines
                            //todo: try this approach - we need a way to figure out which two lines to use
                            //we should have this in the following arrays: maxIntermediateLineIndices[i][j] and maxIntermediateReverseLineIndices[i][j]
                            //we should use these indices to get lines from previousLines[j]
                            let rightLine = previousLines[maxIntermediateLineIndices[i][j]];
                            let leftLine = previousLines[maxIntermediateReverseLineIndices[i][j]];
                            //then we find on each of those lines what point corresponds to the y coordinate we are looking for
                            let rightPoint = getPointOnLineFromY(rightLine,j);
                            let leftPoint = getPointOnLineFromY(leftLine,j);
                            let halfWidth = abs((rightPoint.x - leftPoint.x) / 2);
                            
                            maxIntermediateReverseDistances[i][j] = halfWidth;
                            maxIntermediateDistances[i][j] = halfWidth;

                            //we calculate the mid x between those two points, and with that X and the Y coordinate we are working on, we check if the closest point to that (round down or up) is in shapeArray
                            //if it is, we do nothing. If it is not, we use the max distance between this and the previous Y (as below) -> actually this would give us a vertical reference point rather than one that follows the line, I don't think this is the right approach
                            //actually, in all cases I think max distance should just be half the distance between those two points. We don't even need to calculate the midpoint, just the distance between those two points
                            //half that should be the max distance both for one direction and the other. In cases where this midpoint is in the shape it will already be the case, if not we will set it.
                            //so we actually just loop through y coordinates, find the two crossing points with that y coordinate's LineIndex and ReverseLineIndex, calculate the distance between those 2 and then half that. Use the result of this as BOTH maxIntermediateDistances[i][j] and maxIntermediateReverseDistances[i][j].
                            //that should work in all cases
                            //all of the section between exclamations should be able to be substituted by this
                            //and the line immediately below this one may not be needed (and this loop through y values of maxIntermediateDistances and maxIntermediateReverseDistances yes though)
                    }
                }
            }

            // For each point in each subarray, calculate its interpolation factor as this distance divided by the maximum distance obtained by a point in that subarray
            let interpolationFactorsArrays = [];
        
            for (let i=0;i<distancesArray.length;i++) {
                interpolationFactorsArrays[i] = [];
                for(let j=0; j<distancesArray[i].length;j++) {
                    if(splitFlagsArray[i][j] == 1){
                        // Check if the value is not empty before dividing
                        if (maxIntermediateReverseDistances[i][subArrays[i][j].y] === 0 || maxIntermediateReverseDistances[i][subArrays[i][j].y] == undefined){
                            interpolationFactorsArrays[i][j] = 0;
                        } else {
                            interpolationFactorsArrays[i][j] = distancesArray[i][j] / maxIntermediateReverseDistances[i][subArrays[i][j].y];
                        }
                    } else if(splitFlagsArray[i][j] == -1) {
                        // Check if the value is not empty before dividing
                        if (maxIntermediateDistances[i][subArrays[i][j].y] === 0 || maxIntermediateDistances[i][subArrays[i][j].y] == undefined){
                            interpolationFactorsArrays[i][j] = 0;
                        } else {
                            interpolationFactorsArrays[i][j] = distancesArray[i][j] / maxIntermediateDistances[i][subArrays[i][j].y];
                        }
                    } else {
                        // Check if the value is not empty before dividing, we have two alternative approaches here, I like second best
                        if (maxDistances[i] === 0 || maxDistances[i] == undefined){
                            interpolationFactorsArrays[i][j] = 0;
                        } else {
                            interpolationFactorsArrays[i][j] = distancesArray[i][j] / maxDistances[i];
                        }
                    }
                }
            }

            // Interpolate between that subarray's color and the next/previous one depending on gradient direction, and apply that color to that point in the canvasArray
        
            // We need to subdivide each central subArray into two
            // Then, for each subdivided subarray, the first half has to be the midpoint color between this subarray and the previous one, and the second half's color has to be this subarray's original color
            // The gradient will either go:
            // From this section's color to the intermediate color between this section and the next, if it is an odd section
            // From the intermediate color between this section and the previous to this section's color, if it is an even section
            let newSelectedColors = [];
        
            // Code to subdivide the central selectedColors array:
            // we need to add an intermediate color between every two colors
            // two subarrays -> 3 selectedcolors
            // three subarrays -> 5 selectedcolors
            // newSelectedColors should always have a length of one more item than subArrays
        
            for (let i=0; i< selectedcolors.length; i++) {
                if (i != (selectedcolors.length -1) ){
                    newSelectedColors.push(color(selectedcolors[i]));
                    newSelectedColors.push(lerpColor(color(selectedcolors[i]),color(selectedcolors[i+1]),0.5));
                } else {
                    // add  just the current selectedColor and nothing else
                    newSelectedColors.push(color(selectedcolors[i]));
                }
            }
            applyGradients(subArrays,interpolationFactorsArrays,newSelectedColors,splitFlagsArray);
            applyAntialiasing(10);
        } else {
            // Apply antialiasing to the pixel colors stored in canvasArray and modifies these colors accordingly
            applyAntialiasing(0);
            
            for (let i=1; i<borderArrays.length;i++){
                if (borderArrays[i] == undefined){
                continue;
                }
                for (let j=0;j<borderArrays[i].length;j++) {
                    let targetPixel = borderArrays[i][j];
                    let newColor = lerpColor(
                        color(selectedcolors[i-1]),
                        color(selectedcolors[i]),
                        targetPixel.weight
                    );
                    canvasArray[targetPixel.x][targetPixel.y] = {
                        r: red(newColor),
                        g: green(newColor),
                        b: blue(newColor),
                    };
                }    
            }
        }
        
        // after antialiasing, fix up borders
        
        //We now need to loop through the borderPixels array and change its color
        //The color that each of these pixels currently has is the result of having a combination of black and white pixels surrounding it
        //The white pixels that used to surround this pixel are now of color "#EBE5D9"
        //The black pixels are now one of the following colors: "#ED3A49", "#70D794", "#3479B4", "#F2C946", "#000000", "#FFFFFF"
        //We need to apply to the new colors the same interpolation that had been applied to black and white to get the pixel's current color.
        //This will give us the pixel's new color, which we will apply using the setPixelColor() function
        
        // Loop through the borderPixels array
        for (let i = 0; i < borderPixels.length; i++) {
            let pixel = borderPixels[i];
            
            // Calculate the interpolation factor based on the pixel position between minX and maxX
            let redInterpolationFactor = pixel.r/255;
            let greenInterpolationFactor = pixel.g/255;
            let blueInterpolationFactor = pixel.b/255;
            
            // Find all of this pixel's surrounding pixels in the matchingPixels array
            let surroundingPixels = findSurroundingPixels(pixel, canvasArray);

            // Calculate the average values for red, green, and blue
            let avgRed = calculateAverageColorComponent(surroundingPixels, 'r');
            let avgGreen = calculateAverageColorComponent(surroundingPixels, 'g');
            let avgBlue = calculateAverageColorComponent(surroundingPixels, 'b');
            
            // Apply the interpolation factor to the difference between 255 and each color component
            let interpolatedRed = avgRed + (235 - avgRed) * (redInterpolationFactor || 0);
            let interpolatedGreen = avgGreen + (229 - avgGreen) * (greenInterpolationFactor || 0);
            let interpolatedBlue = avgBlue + (217 - avgBlue) * (blueInterpolationFactor ||0);
            
            
            // Set the new color for the pixel using the setPixelColor function
            setPixelColor(pixel.x, pixel.y, color(interpolatedRed, interpolatedGreen, interpolatedBlue));
        }
        
        
        
        
        // Finally, here we will add circles and lines
        
        let bordersArray = JSON.parse(JSON.stringify(shapeArray));
        let preShapesCanvasArray = JSON.parse(JSON.stringify(canvasArray));
        let circleMoveIndex = setupVariables.circleCount;
        let circleOrder = [];
        let shuffledArrayIndex = 0;
        let circlePixelsArray = [];
        let circleRetryArray = new Array(circles.length).fill(0);

        if(variablesGenerated && setupVariables.mutation == "circlePositionChange"){
            circleMoveIndex = floor(random(setupVariables.circleCount));
        }

        if(variablesGenerated && (setupVariables.mutation == "circleMoveLeft" || setupVariables.mutation == "circleMoveRight" || setupVariables.mutation == "circleMoveUp" || setupVariables.mutation == "circleMoveDown")){
            let shuffledArray = [...Array(setupVariables.circleCount).keys()];
            for (let j = shuffledArray.length - 1; j > 0; j--) {
                let k = floor(random() * (j + 1));
                let temp = shuffledArray[j];
                shuffledArray[j] = shuffledArray[k];
                shuffledArray[k] = temp;
            }
            circleOrder = shuffledArray;
        }

        // Since mutations that affect seedpoints or the actual contour of the shape may make it so a circle no longer fits, even it variables have been generated we double check that all circles' centers are inside the shape, if not, we will regenerate
        let excludedCircleIndices = [];

        if(variablesGenerated) {
            for(let i=0; i<circles.length;i++){
                let finished = false;
                let x = round(setupVariables.circles[i].centerX * canvasWidth,0);
                let y = round(setupVariables.circles[i].centerY * canvasHeight,0);

                // Define the range of offsets to check (+/- 2 positions)
                let offsets = [-2, -1, 0, 1, 2];

                // Loop through all possible offsets
                for (let offsetX of offsets) {
                    for (let offsetY of offsets) {
                        // Calculate the neighbor's coordinates
                        let neighborX = x + offsetX;
                        let neighborY = y + offsetY;

                        // Check if the neighbor is within shape
                        if(neighborX >=0 &&
                           neighborY >= 0 &&
                           neighborX < shapeArray.length &&
                           neighborY < shapeArray[neighborX].length &&
                           shapeArray[neighborX][neighborY] == 0
                        ) {
                            excludedCircleIndices.push(i);
                            finished = true;
                            break;
                        }
                    }
                    if(finished) break;
                }
            }
        }

        // We retry this loop up to 3 times searching for a circle that fits
        for(let i=0; i<circles.length;i++){
            circleRetryArray[i]++;
            // Pick a random point inside the shape
            // TBD: maybe we don't need to add/subtract baseRadius when generating center
            if(!variablesGenerated || missingCircles > i || circleMoveIndex == i || excludedCircleIndices.includes(i)){
                if(missingCircles > i) {
                    // This works because we have pushed new circles to the end of the array
                    setupVariables.circles[setupVariables.circles.length-1-i].centerX = floor(random(minX.x+baseRadius,maxX.x-baseRadius+1))/canvasWidth;
                } else {
                    setupVariables.circles[i].centerX = floor(random(minX.x+baseRadius,maxX.x-baseRadius+1))/canvasWidth;
                }
                
                let centerX = round(setupVariables.circles[i].centerX * canvasWidth,0);
                let minY = shapeArray[centerX].indexOf(1);
                //Rethink this: it assumes we have an array where all of the 1s are together
                //but we could have an array like [0,0,0,0,0,1,1,1,1,0,0,0,0,0,0,0,0,0,0,1,1,1,1,1,1,1,1,1,1,0,0,0,0]
                //then, instead of having one single interval of minY and maxY, we would need to have a discontinuous range
                //maybe we can leave this as is and draw a random number in a single range with size equal to the number of 1s in the array
                //but then we need to check for several brekapoints, i.e. if the number is bigger than the size of the first set of 1s
                //then we add the number of 0s in between the two ranges of 1s to the selected number to get the final centerY we need to use
                let maxY = minY - 1 + shapeArray[centerX].reduce((acc, currentValue) => acc + currentValue, 0);
                //To do this, now we need to get an array of breakpoints
                let breakPointArray = [];
                for (let j = 1; j < shapeArray[centerX].length; j++) {
                    if (shapeArray[centerX][j] !== shapeArray[centerX][j - 1]) {
                        breakPointArray.push(j);
                    }
                }

                if(missingCircles > i) {
                    centerX = round(setupVariables.circles[setupVariables.circles.length-1-i].centerX * canvasWidth,0);
                    minY = shapeArray[centerX].indexOf(1);
                    maxY = minY - 1 + shapeArray[centerX].reduce((acc, currentValue) => acc + currentValue, 0);
                    breakPointArray = [];
                    for (let j = 1; j < shapeArray[centerX].length; j++) {
                        if (shapeArray[centerX][j] !== shapeArray[centerX][j - 1]) {
                            breakPointArray.push(j);
                        }
                    }
                    let centerY = floor(random(minY+baseRadius,maxY-baseRadius+1));
                    // Here we check if centerY is above more than 1 breakpoint, if soo we increase it
                    if(breakPointArray.length > 2) {
                        for (let j = 1; j < breakPointArray.length-1; j++) {
                            if (centerY > breakPointArray[j]) {
                                centerY += breakPointArray[j+1]-breakPointArray[j];
                            }
                            j++;
                        }
                    }
                    setupVariables.circles[setupVariables.circles.length-1-i].centerY = centerY / canvasHeight;     
                } else {
                    let centerY = floor(random(minY+baseRadius,maxY-baseRadius+1));
                    // Here we check if centerY is above more than 1 breakpoint, if soo we increase it
                    if(breakPointArray.length > 2) {
                        for (let j = 1; j < breakPointArray.length-1; j++) {
                            if (centerY > breakPointArray[j]) {
                                centerY += breakPointArray[j+1]-breakPointArray[j];
                            }
                            j++;
                        }
                    }
                    setupVariables.circles[i].centerY = centerY / canvasHeight;
                }
            }

            let centerY = round(setupVariables.circles[i].centerY * canvasHeight,0);
            //We redefine these outside the closure for circle number i, which is not necessarily the circle for which we just generated values
            //If we are mutating, it will not be the same
            let centerX = round(setupVariables.circles[i].centerX * canvasWidth,0);
            let minY = shapeArray[centerX].indexOf(1);
            let maxY = minY - 1 + shapeArray[centerX].reduce((acc, currentValue) => acc + currentValue, 0);
            //We need to adjust maxY to give us the actual maximum Y including the length of any gaps in between
            let breakPointArray = [];
            for (let j = 1; j < shapeArray[centerX].length; j++) {
                if (shapeArray[centerX][j] !== shapeArray[centerX][j - 1]) {
                    breakPointArray.push(j);
                }
            }
            if(breakPointArray.length > 2) {
                for (let j = 1; j < breakPointArray.length-1; j++) {
                    if (maxY > breakPointArray[j]) {
                        maxY += breakPointArray[j+1]-breakPointArray[j];
                    }
                    j++;
                }
            }
        
            let circleMinX = minX.x;
            let circleMaxX = maxX.x;

            //These loops give us the minX and maxX at a specific Y
            for (let j = 0; j < shapeArray.length; j++) {
                if (shapeArray[j][centerY] === 1) {
                    circleMinX = j;
                    break;
                }
            }
        
            for (let j = shapeArray.length-1; j >= 0; j--) {
                if (shapeArray[j][centerY] === 1) {
                    circleMaxX = j;
                    break;
                }
            }

            // To avoid errors, we need to check if we have pixels outside the shape betwwen minX and maxX
            if(variablesGenerated && setupVariables.mutation == "circleMoveLeft" && circleOrder[shuffledArrayIndex] == i){
                let XBreakPointArray = [];
                let eligibleXs = 0;
                for (let j = 1; j < centerX+1; j++) {
                    if(shapeArray[j][centerY] == 1) {
                        eligibleXs++;
                    }
                    if (shapeArray[j][centerY] !== shapeArray[j-1][centerY]) {
                        XBreakPointArray.push(j);
                    }
                }
                //Since we are not going until the end of the canvas we add a final beakpoint at centerX to ensure we have an even number of breakpoints
                XBreakPointArray.push(centerX);
                // We subtract 1 to not double count the first possible pixel
                centerX = floor(random(circleMinX,circleMinX+eligibleXs-1));
                if(XBreakPointArray.length > 2) {
                    for (let j = 1; j < XBreakPointArray.length-1; j++) {
                        if (centerX > XBreakPointArray[j]) {
                            centerX += XBreakPointArray[j+1]-XBreakPointArray[j];
                        }
                        j++;
                    }
                }
            }

            if(variablesGenerated && setupVariables.mutation == "circleMoveRight" && circleOrder[shuffledArrayIndex] == i){
                //Since we are not starting at the beginning of the canvas we add a first beakpoint at centerX to ensure we have an even number of breakpoints
                let XBreakPointArray = [centerX];
                let eligibleXs = 1;
                for (let j = centerX+1; j < shapeArray.length; j++) {
                    if(shapeArray[j][centerY] == 1) {
                        eligibleXs++;
                    }
                    if (shapeArray[j][centerY] !== shapeArray[j-1][centerY]) {
                        XBreakPointArray.push(j);
                    }
                }
                // We add 1 to guarantee a move to the right, don't need to subtract 1 from eligibleXs because we are flooring
                centerX = floor(random(centerX+1,centerX+eligibleXs+1));
                if(XBreakPointArray.length > 2) {
                    for (let j = 1; j < XBreakPointArray.length-1; j++) {
                        if (centerX > XBreakPointArray[j]) {
                            centerX += XBreakPointArray[j+1]-XBreakPointArray[j];
                        }
                        j++;
                    }
                }
            }

            if(variablesGenerated && setupVariables.mutation == "circleMoveUp" && circleOrder[shuffledArrayIndex] == i){
                let adjustment = 0;
                if(breakPointArray.length > 2) {
                    for (let j = 1; j < breakPointArray.length-1; j++) {
                        if (centerY > breakPointArray[j]) {
                            adjustment += breakPointArray[j+1]-breakPointArray[j];
                        }
                        j++;
                    }
                }
                //Since we are flooring, this will never be centerY, and might be minY
                centerY = floor(random(minY,centerY-adjustment));
                if(breakPointArray.length > 2) {
                    for (let j = 1; j < breakPointArray.length-1; j++) {
                        if (centerY > breakPointArray[j]) {
                            centerY += breakPointArray[j+1]-breakPointArray[j];
                        }
                        j++;
                    }
                }
            }

            if(variablesGenerated && setupVariables.mutation == "circleMoveDown" && circleOrder[shuffledArrayIndex] == i){
                let adjustment = 0;
                if(breakPointArray.length > 2) {
                    for (let j = 1; j < breakPointArray.length-1; j++) {
                        if (centerY > breakPointArray[j]) {
                            adjustment += breakPointArray[j+1]-breakPointArray[j];
                        }
                        j++;
                    }
                }
                let eligibleYs = shapeArray[centerX].reduce((acc, currentValue) => acc + currentValue, 0);
                // We add 1 so that we can never get centerY again
                centerY = floor(random(centerY-adjustment+1,minY-1+eligibleYs));
                if(breakPointArray.length > 2) {
                    for (let j = 1; j < breakPointArray.length-1; j++) {
                        if (centerY > breakPointArray[j]) {
                            centerY += breakPointArray[j+1]-breakPointArray[j];
                        }
                        j++;
                    }
                }
            }

            // We want radius of at least 2 so that it does not look like a square
            let radius = max(2,ceil(circles[i].radius*min((min(canvasHeight,canvasWidth)/12),abs(circleMaxX-centerX),abs(centerX-circleMinX),abs(maxY-centerY),abs(centerY-minY))));

            // Calculate pixels inside circle
            let circlePixels = calculatePixelsInsideCircle(centerX,centerY,radius);

            while (circlePixels == null) {
                radius--;
                circlePixels = calculatePixelsInsideCircle(centerX,centerY,radius);
            }
        
            // We don't want to draw individual pixels, circles should have at least radius 2. If we can't draw that, hide this circle.
            if(radius<2) {
                // We do this to try to guarantee that a circle moves left/right whenever any of them could
                if(variablesGenerated && (setupVariables.mutation == "circleMoveLeft" || setupVariables.mutation == "circleMoveRight" || setupVariables.mutation == "circleMoveUp" || setupVariables.mutation == "circleMoveDown") && circleOrder[shuffledArrayIndex] == i && circleRetryArray[i] > 2){
                    shuffledArrayIndex++;
                    if(shuffledArrayIndex<circleOrder.length) {
                        if(circleOrder[shuffledArrayIndex]>i) {
                            i--;
                        } else {
                            i = circleOrder[shuffledArrayIndex]-1;
                        }
                    }
                }

                if((!variablesGenerated || setupVariables.mutation == "circlePositionChange" || setupVariables.mutation == "circleMoveLeft" || setupVariables.mutation == "circleMoveRight" || setupVariables.mutation == "circleMoveUp" || setupVariables.mutation == "circleMoveDown") && circleRetryArray[i] < 3){
                    i--;
                }
                continue;
            }

            // If we have successfully moved a circle left/right, we persist the change
            if(variablesGenerated && (setupVariables.mutation == "circleMoveLeft" || setupVariables.mutation == "circleMoveRight") && circleOrder[shuffledArrayIndex] == i){
                setupVariables.circles[i].centerX = centerX/canvasWidth;
            }

            if(variablesGenerated && (setupVariables.mutation == "circleMoveUp" || setupVariables.mutation == "circleMoveDown") && circleOrder[shuffledArrayIndex] == i){
                setupVariables.circles[i].centerY = centerY/canvasHeight;
            }

            circlePixelsArray[i] = [];
            circlePixelsArray[i][0] = circlePixels[0];
            circlePixelsArray[i][1] = circlePixels[1];
        }


        for(let i=0; i<circles.length;i++){
            let pixelsInside = circlePixelsArray[i][0];
            let pixelsBorder = circlePixelsArray[i][1];

            // Draw a black circle
            // Make all pixelsInside black or white depending on their background
            // If we change something to white, or if it is black but part of another shape's border, change it to gray instead
            let antialiasThreshold = 75;
            let antialiasThresholdDenominator = 75;
            let antialiasSlope = 10;
            if (gradientType==1){
                antialiasThreshold = 110;
                antialiasThresholdDenominator = 5500;
                antialiasSlope = 1;
            } else if (gradientType==2) {
                antialiasThreshold = 220;    
                antialiasThresholdDenominator = 220;
                antialiasSlope = 0.5;
            }
        
            for(let j=0; j<pixelsInside.length; j++) {
                let targetPixel = pixelsInside[j];
                let currentColor = color(
                    canvasArray[targetPixel.x][targetPixel.y].r,
                    canvasArray[targetPixel.x][targetPixel.y].g,
                    canvasArray[targetPixel.x][targetPixel.y].b,
                );
                
                let colorDifference = dist(
                    red(currentColor),green(currentColor),blue(currentColor),
                    0,0,0
                );

                let prevColorCloseToBlack = false;
                let nextColorCloseToBlack = false;
                
                if(
                    gradientType == 2 && 
                    //This line below means we are at a border between two colors
                    weightsArray[targetPixel.x][targetPixel.y] != 0
                ){

                    let linesToRight = linesToRightArray[targetPixel.x][targetPixel.y];

                    // assuming 25 pixels should be enough to find a non-border
                    let nonBorderX = targetPixel.x;
                    for(let k=1; k<26; k++) {
                        nonBorderX++;
                        if(linesToRightArray[nonBorderX][targetPixel.y] == 0 || linesToRightArray[nonBorderX][targetPixel.y] != linesToRight) {
                            continue;
                        }
                    }

                    if (linesToRight == 0 || linesToRight == linesToRightArray[nonBorderX][targetPixel.y]) {
                        let prevColorDifference = dist(
                            red(color(selectedcolors[linesToRight])),green(color(selectedcolors[linesToRight])),blue(color(selectedcolors[linesToRight])),
                            0,0,0
                        );

                        let nextColorDifference = dist(
                            red(color(selectedcolors[linesToRight+1])),green(color(selectedcolors[linesToRight+1])),blue(color(selectedcolors[linesToRight+1])),
                            0,0,0
                        );

                        if (prevColorDifference<antialiasThreshold){
                            prevColorCloseToBlack = true;
                        }
                        if (nextColorDifference<antialiasThreshold){
                            nextColorCloseToBlack = true;
                        }
                    } else {
                        let prevColorDifference = dist(
                            red(color(selectedcolors[linesToRight-1])),green(color(selectedcolors[linesToRight-1])),blue(color(selectedcolors[linesToRight-1])),
                            0,0,0
                        );
                        let nextColorDifference = dist(
                            red(color(selectedcolors[linesToRight])),green(color(selectedcolors[linesToRight])),blue(color(selectedcolors[linesToRight])),
                            0,0,0
                        );

                        if (prevColorDifference<antialiasThreshold){
                            prevColorCloseToBlack = true;
                        }
                        if (nextColorDifference<antialiasThreshold){
                            nextColorCloseToBlack = true;
                        }
                    }

                    if (prevColorCloseToBlack !== nextColorCloseToBlack) {
                        let newWhiteColor = lerpColor(color(255,255,255),color(0,0,0),weightsArray[targetPixel.x][targetPixel.y]);

                        if (nextColorCloseToBlack) {
                            newWhiteColor = lerpColor(color(0,0,0),color(255,255,255),weightsArray[targetPixel.x][targetPixel.y]);
                        }
                    
                        // Now we invert the weight so that if another shape is then drawn on top of this, the weight will work in reverse
                        weightsArray[targetPixel.x][targetPixel.y] = 1-weightsArray[targetPixel.x][targetPixel.y];

                        canvasArray[targetPixel.x][targetPixel.y] = {
                            r: red(newWhiteColor),
                            g: green(newWhiteColor),
                            b: blue(newWhiteColor),
                        };
                        continue;
                    }

                }


                if (
                    // If we have previously drawn another circle and this pixel is inside the current circle but on the border of that one
                    bordersArray[targetPixel.x][targetPixel.y] !== 1  
                ) {
                    let originalColor = color(
                        preShapesCanvasArray[targetPixel.x][targetPixel.y].r,
                        preShapesCanvasArray[targetPixel.x][targetPixel.y].g,
                        preShapesCanvasArray[targetPixel.x][targetPixel.y].b
                    );
                    let originalColorDifference = dist(
                        red(originalColor),green(originalColor),blue(originalColor),
                        0,0,0
                    );

                    let newColor = lerpColor(
                        color(255,255,255),
                        color(0,0,0),
                        bordersArray[targetPixel.x][targetPixel.y]
                    );

                    if (originalColorDifference<antialiasThreshold) {
                        let midThreshold = antialiasThreshold-antialiasSlope*2;

                        let newWhiteColor = lerpColor(color(255,255,255),color(0,0,0),
                            (Math.exp((originalColorDifference - midThreshold) / antialiasSlope) - Math.exp(-(originalColorDifference - midThreshold) / antialiasSlope)) /
                            (Math.exp((originalColorDifference - midThreshold) / antialiasSlope) + Math.exp(-(originalColorDifference - midThreshold) / antialiasSlope))
                            * 0.5 + 0.5
                        );

                        newColor = lerpColor(
                            color(0,0,0),
                            color(red(newWhiteColor),green(newWhiteColor),blue(newWhiteColor)),
                            bordersArray[targetPixel.x][targetPixel.y]
                        );
                    }
                
                    canvasArray[targetPixel.x][targetPixel.y] = {
                        r: red(newColor),
                        g: green(newColor),
                        b: blue(newColor),
                    };
                } else if (colorDifference<antialiasThreshold && (weightsArray[targetPixel.x][targetPixel.y] === 0 || (gradientType != 2 || setupVariables.dividerCount === 0 || prevColorCloseToBlack !== nextColorCloseToBlack || (prevColorCloseToBlack && nextColorCloseToBlack)))) {
                    let midThreshold = antialiasThreshold-antialiasSlope*2;

                    let newWhiteColor = lerpColor(color(255,255,255),color(0,0,0),
                        (Math.exp((colorDifference - midThreshold) / antialiasSlope) - Math.exp(-(colorDifference - midThreshold) / antialiasSlope)) /
                        (Math.exp((colorDifference - midThreshold) / antialiasSlope) + Math.exp(-(colorDifference - midThreshold) / antialiasSlope))
                        * 0.5 + 0.5
                    );

                    canvasArray[targetPixel.x][targetPixel.y] = {
                        r: red(newWhiteColor),
                        g: green(newWhiteColor),
                        b: blue(newWhiteColor),
                    };

                } else {
                    canvasArray[targetPixel.x][targetPixel.y] = {
                        r: 0,
                        g: 0,
                        b: 0,
                    };
                }
            }
                
            // Once circle is full and we have colored borders, we need to smooth out jagged lines

            // If the fill has no gradients, we use weightsArray, otherwise we will antialias with radius 1
            
            if(gradientType != 2){
                //antiAliasShapeFill(pixelsInside);            
            }

            // Make all pixelsBorder the average between black and their previous color, weighted by the percentage occupation by the circle - each pixelsBorder is an object with props x,y,weight
            for(let j=0; j<pixelsBorder.length; j++) {
                let targetPixel = pixelsBorder[j];
                let currentRed = canvasArray[targetPixel.x][targetPixel.y].r;
                let currentGreen = canvasArray[targetPixel.x][targetPixel.y].g;
                let currentBlue = canvasArray[targetPixel.x][targetPixel.y].b;
                
                if(bordersArray[targetPixel.x][targetPixel.y] === 1 ) {
                    bordersArray[targetPixel.x][targetPixel.y] = targetPixel.weight;
                } else {
                    bordersArray[targetPixel.x][targetPixel.y] = min(bordersArray[targetPixel.x][targetPixel.y],targetPixel.weight);
                };
                
                let colorDifference = dist(
                    currentRed,
                    currentGreen,
                    currentBlue,
                    0,0,0
                );
                
                if (colorDifference<antialiasThreshold) {
                    let midThreshold = antialiasThreshold-antialiasSlope*2;
                    let newWhiteColor = lerpColor(color(255,255,255),color(0,0,0),
                        (Math.exp((colorDifference - midThreshold) / antialiasSlope) - Math.exp(-(colorDifference - midThreshold) / antialiasSlope)) /
                        (Math.exp((colorDifference - midThreshold) / antialiasSlope) + Math.exp(-(colorDifference - midThreshold) / antialiasSlope))
                        * 0.5 + 0.5
                    );

                    let newColor = lerpColor(
                        newWhiteColor,
                        color(currentRed,currentGreen,currentBlue),
                        targetPixel.weight
                    );
                    canvasArray[targetPixel.x][targetPixel.y] = {
                        r: red(newColor),
                        g: green(newColor),
                        b: blue(newColor),
                    };
                } else {
                    let newColor = lerpColor(
                        color(0,0,0),
                        color(currentRed,currentGreen,currentBlue),
                        bordersArray[targetPixel.x][targetPixel.y]
                    );
                    canvasArray[targetPixel.x][targetPixel.y] = {
                        r: red(newColor),
                        g: green(newColor),
                        b: blue(newColor),
                    };
                }
            }
        }

        let lineMoveIndex = setupVariables.lineCount;
        let lineRetryArray = new Array(lines.length).fill(0);
        let lineOrder = [];
        
        if(variablesGenerated && setupVariables.mutation == "linePositionChange"){
            lineMoveIndex = floor(random(setupVariables.lineCount));
        }

        if(variablesGenerated && (setupVariables.mutation == "lineMoveLeft" || setupVariables.mutation == "lineMoveRight" || setupVariables.mutation == "lineMoveUp" || setupVariables.mutation == "lineMoveDown")){
            let shuffledArray = [...Array(setupVariables.lineCount).keys()];
            for (let j = shuffledArray.length - 1; j > 0; j--) {
                let k = floor(random() * (j + 1));
                let temp = shuffledArray[j];
                shuffledArray[j] = shuffledArray[k];
                shuffledArray[k] = temp;
            }
            lineOrder = shuffledArray;
        }

        // Since mutations that affect seedpoints or the actual contour of the shape may make it so a circle no longer fits, even it variables have been generated we double check that all circles' centers are inside the shape, if not, we will regenerate
        let excludedLineIndices = [];

        if(variablesGenerated) {
            for(let i=0; i<lines.length;i++){
                let finished = false;
                let x = round(setupVariables.lines[i].centerX * canvasWidth,0);
                let y = round(setupVariables.lines[i].centerY * canvasHeight,0);

                // Define the range of offsets to check (+/- 2 positions)
                let offsets = [-2, -1, 0, 1, 2];

                // Loop through all possible offsets
                for (let offsetX of offsets) {
                    for (let offsetY of offsets) {
                        // Calculate the neighbor's coordinates
                        let neighborX = x + offsetX;
                        let neighborY = y + offsetY;

                        // Check if the neighbor is within shape
                        if(neighborX >=0 &&
                        neighborY >= 0 &&
                        neighborX < shapeArray.length &&
                        neighborY < shapeArray[neighborX].length &&
                        shapeArray[neighborX][neighborY] == 0
                        ) {
                            excludedLineIndices.push(i);
                            finished = true;
                            break;
                        }
                    }
                    if(finished) break;
                }
            }
        }


        for(let i=0; i<lines.length;i++){
            lineRetryArray[i]++;

            let halfWidth = lines[i].ancho/2;
            let angle = lines[i].angle;
            // Pick a random point
            if (!variablesGenerated || missingLines > i || lineMoveIndex == i || excludedLineIndices.includes(i)) {
                if(missingLines > i) {
                    // This works because we have pushed new lines to the end of the array
                    setupVariables.lines[setupVariables.lines.length-1-i].centerX = floor(random(minX.x+halfWidth,maxX.x-halfWidth+1)) / canvasWidth;     
                } else {
                    setupVariables.lines[i].centerX = floor(random(minX.x+halfWidth,maxX.x-halfWidth+1)) / canvasWidth;
                }
            
                let centerX = round(setupVariables.lines[i].centerX * canvasWidth, 0);
                let minY = shapeArray[centerX].indexOf(1);
                let maxY = minY - 1 + shapeArray[centerX].reduce((acc, currentValue) => acc + currentValue, 0);           
                //follow same logic as for circles
                let breakPointArray = [];
                for (let j = 1; j < shapeArray[centerX].length; j++) {
                    if (shapeArray[centerX][j] !== shapeArray[centerX][j - 1]) {
                        breakPointArray.push(j);
                    }
                }

                if(missingLines > i) {
                    centerX = round(setupVariables.lines[setupVariables.lines.length-1-i].centerX * canvasWidth,0);
                    minY = shapeArray[centerX].indexOf(1);
                    maxY = minY - 1 + shapeArray[centerX].reduce((acc, currentValue) => acc + currentValue, 0);
                    breakPointArray = [];
                    for (let j = 1; j < shapeArray[centerX].length; j++) {
                        if (shapeArray[centerX][j] !== shapeArray[centerX][j - 1]) {
                            breakPointArray.push(j);
                        }
                    }
                    let centerY = floor(random(minY+halfWidth,maxY-halfWidth+1));
                    // Here we check if centerY is above more than 1 breakpoint, if soo we increase it
                    if(breakPointArray.length > 2) {
                        for (let j = 1; j < breakPointArray.length-1; j++) {
                            if (centerY > breakPointArray[j]) {
                                centerY += breakPointArray[j+1]-breakPointArray[j];
                            }
                            j++;
                        }
                    }
                    setupVariables.lines[setupVariables.lines.length-1-i].centerY = centerY / canvasHeight;     
                } else {
                    let centerY = floor(random(minY+halfWidth,maxY-halfWidth+1));
                    // Here we check if centerY is above more than 1 breakpoint, if soo we increase it
                    if(breakPointArray.length > 2) {
                        for (let j = 1; j < breakPointArray.length-1; j++) {
                            if (centerY > breakPointArray[j]) {
                                centerY += breakPointArray[j+1]-breakPointArray[j];
                            }
                            j++;
                        }
                    }
                    setupVariables.lines[i].centerY = centerY / canvasHeight;
                }
           
            }

            let centerY = round(setupVariables.lines[i].centerY * canvasHeight,0);
            //We redefine these outside the closure for circle number i, which is not necessarily the circle for which we just generated values
            //If we are mutating, it will not be the same
            let centerX = round(setupVariables.lines[i].centerX * canvasWidth,0);
            //I think the two lines below can be deleted but maybe we need them for the move line right/left/up/down mutations
            let minY = shapeArray[centerX].indexOf(1);
            let maxY = minY - 1 + shapeArray[centerX].reduce((acc, currentValue) => acc + currentValue, 0);
            //We need to adjust maxY to give us the actual maximum Y including the length of any gaps in between
            let breakPointArray = [];
            for (let j = 1; j < shapeArray[centerX].length; j++) {
                if (shapeArray[centerX][j] !== shapeArray[centerX][j - 1]) {
                    breakPointArray.push(j);
                }
            }
            if(breakPointArray.length > 2) {
                for (let j = 1; j < breakPointArray.length-1; j++) {
                    if (maxY > breakPointArray[j]) {
                        maxY += breakPointArray[j+1]-breakPointArray[j];
                    }
                    j++;
                }
            }

            let lineMinX = minX.x;
            let lineMaxX = maxX.x;

            //These loops give us the minX and maxX at a specific Y
            for (let j = 0; j < shapeArray.length; j++) {
                if (shapeArray[j][centerY] === 1) {
                    lineMinX = j;
                    break;
                }
            }
        
            for (let j = shapeArray.length-1; j >= 0; j--) {
                if (shapeArray[j][centerY] === 1) {
                    lineMaxX = j;
                    break;
                }
            }

            // To avoid errors, we need to check if we have pixels outside the shape betwwen minX and maxX
            if(variablesGenerated && setupVariables.mutation == "lineMoveLeft" && lineOrder[shuffledArrayIndex] == i){
                let XBreakPointArray = [];
                let eligibleXs = 0;
                for (let j = 1; j < centerX+1; j++) {
                    if(shapeArray[j][centerY] == 1) {
                        eligibleXs++;
                    }
                    if (shapeArray[j][centerY] !== shapeArray[j-1][centerY]) {
                        XBreakPointArray.push(j);
                    }
                }
                //Since we are not going until the end of the canvas we add a final beakpoint at centerX to ensure we have an even number of breakpoints
                XBreakPointArray.push(centerX);
                // We subtract 1 to not double count the first possible pixel
                centerX = floor(random(lineMinX,lineMinX+eligibleXs-1));
                if(XBreakPointArray.length > 2) {
                    for (let j = 1; j < XBreakPointArray.length-1; j++) {
                        if (centerX > XBreakPointArray[j]) {
                            centerX += XBreakPointArray[j+1]-XBreakPointArray[j];
                        }
                        j++;
                    }
                }
            }            


            if(variablesGenerated && setupVariables.mutation == "lineMoveRight" && lineOrder[shuffledArrayIndex] == i){
                //Since we are not starting at the beginning of the canvas we add a first beakpoint at centerX to ensure we have an even number of breakpoints
                let XBreakPointArray = [centerX];
                let eligibleXs = 1;
                for (let j = centerX+1; j < shapeArray.length; j++) {
                    if(shapeArray[j][centerY] == 1) {
                        eligibleXs++;
                    }
                    if (shapeArray[j][centerY] !== shapeArray[j-1][centerY]) {
                        XBreakPointArray.push(j);
                    }
                }
                // We add 1 to guarantee a move to the right, don't need to subtract 1 from eligibleXs because we are flooring
                centerX = floor(random(centerX+1,centerX+eligibleXs+1));
                if(XBreakPointArray.length > 2) {
                    for (let j = 1; j < XBreakPointArray.length-1; j++) {
                        if (centerX > XBreakPointArray[j]) {
                            centerX += XBreakPointArray[j+1]-XBreakPointArray[j];
                        }
                        j++;
                    }
                }
            }

            if(variablesGenerated && setupVariables.mutation == "lineMoveUp" && lineOrder[shuffledArrayIndex] == i){
                let adjustment = 0;
                if(breakPointArray.length > 2) {
                    for (let j = 1; j < breakPointArray.length-1; j++) {
                        if (centerY > breakPointArray[j]) {
                            adjustment += breakPointArray[j+1]-breakPointArray[j];
                        }
                        j++;
                    }
                }
                //Since we are flooring, this will never be centerY, and might be minY
                centerY = floor(random(minY,centerY-adjustment));
                if(breakPointArray.length > 2) {
                    for (let j = 1; j < breakPointArray.length-1; j++) {
                        if (centerY > breakPointArray[j]) {
                            centerY += breakPointArray[j+1]-breakPointArray[j];
                        }
                        j++;
                    }
                }
            }

            if(variablesGenerated && setupVariables.mutation == "lineMoveDown" && lineOrder[shuffledArrayIndex] == i){
                let adjustment = 0;
                if(breakPointArray.length > 2) {
                    for (let j = 1; j < breakPointArray.length-1; j++) {
                        if (centerY > breakPointArray[j]) {
                            adjustment += breakPointArray[j+1]-breakPointArray[j];
                        }
                        j++;
                    }
                }
                let eligibleYs = shapeArray[centerX].reduce((acc, currentValue) => acc + currentValue, 0);
                // We add 1 so that we can never get centerY again
                centerY = floor(random(centerY-adjustment+1,minY-1+eligibleYs));
                if(breakPointArray.length > 2) {
                    for (let j = 1; j < breakPointArray.length-1; j++) {
                        if (centerY > breakPointArray[j]) {
                            centerY += breakPointArray[j+1]-breakPointArray[j];
                        }
                        j++;
                    }
                }
            }

            // Follow the line angle with increasing length in both senses until we reach a pixel that is not in shapeArray
            // Consider repeating this if it gives us a maxLength of less than 2 but trying to rotate the angle instead, maybe in increments of 5-10
            let lineMin = createVector(centerX,centerY);
            let lineMax = lineMin;
            let maxLength = 0;
            let maxLineDist = sqrt(canvasHeight**2+(maxX.x-minX.x)**2);
            let lastPositivePixel = lineMin;
            let lastNegativePixel = lineMin;
            let rotationAngle = 0;
            let widthFits = false;

            while (!widthFits && rotationAngle <= PI && maxLength<2){
                for (let j = 1; j < maxLineDist; j++) {
                    let positivePixel = findPointOnLine(centerX, centerY, angle, j);
                    let negativePixel = findPointOnLine(centerX, centerY, angle + PI, j);
                    if (shapeArray[floor(positivePixel.x)] == undefined || shapeArray[floor(positivePixel.x)][floor(positivePixel.y)] !== 1) {
                        lastPositivePixel = positivePixel;
                        lastNegativePixel = negativePixel;
                        maxLength = j-1;
                        break;
                    }
                    
                    if (shapeArray[floor(negativePixel.x)] == undefined || shapeArray[floor(negativePixel.x)][floor(negativePixel.y)] !== 1) {
                        lastPositivePixel = positivePixel;
                        lastNegativePixel = negativePixel;
                        maxLength = j-1;
                        break;
                    }
                }
            
                // Check if the full width of the line can fit in each of the line's extremes and still be inside shapeArray by calculating both points at a distance of ancho/2 from these two last points in a perpendicular direction from angle
                // While it does not fit, shorten the max length and repeat
                // When it fits or max length is 0, stop doing it and use this value as max length
            
                widthFits = false;
            
                let positivePositivePixel;
                let positiveNegativePixel;
                let negativePositivePixel;
                let negativeNegativePixel;
            
                while (!widthFits && maxLength > 0){
                    positivePositivePixel = findPointOnLine(lastPositivePixel.x, lastPositivePixel.y, angle+PI/2, halfWidth);
                    positiveNegativePixel = findPointOnLine(lastPositivePixel.x, lastPositivePixel.y, angle-PI/2, halfWidth);
                    negativePositivePixel = findPointOnLine(lastNegativePixel.x, lastNegativePixel.y, angle+PI/2, halfWidth);
                    negativeNegativePixel = findPointOnLine(lastNegativePixel.x, lastNegativePixel.y, angle-PI/2, halfWidth);
                    
                    if (
                        (shapeArray[floor(positivePositivePixel.x)] == undefined || shapeArray[floor(positivePositivePixel.x)][floor(positivePositivePixel.y)] !== 1) ||
                        (shapeArray[floor(positiveNegativePixel.x)] == undefined || shapeArray[floor(positiveNegativePixel.x)][floor(positiveNegativePixel.y)] !== 1) ||
                        (shapeArray[floor(negativePositivePixel.x)] == undefined || shapeArray[floor(negativePositivePixel.x)][floor(negativePositivePixel.y)] !== 1) ||
                        (shapeArray[floor(negativeNegativePixel.x)] == undefined || shapeArray[floor(negativeNegativePixel.x)][floor(negativeNegativePixel.y)] !== 1)
                    ) {
                        // Shorten maxLength and then recalculate lastPixels
                        maxLength--;
                        lastPositivePixel = findPointOnLine(centerX, centerY, angle, maxLength);
                        lastNegativePixel = findPointOnLine(centerX, centerY, angle + PI, maxLength);
                    } else {
                        widthFits = true;
                    }
                }
                // I added this if to debug something way after I originally wrote this, I think it is fine but not sure why I did not do this in the first place
                if(!widthFits){
                    rotationAngle += PI/180;
                    angle += PI/180;
                }
            }

            // We don't want points instead of lines
            // We will retry this up to 3 times
            if(maxLength<2) {
                // We do this to try to guarantee that a line moves left/right whenever any of them could
                if(variablesGenerated && (setupVariables.mutation == "lineMoveLeft" || setupVariables.mutation == "lineMoveRight" || setupVariables.mutation == "lineMoveUp" || setupVariables.mutation == "lineMoveDown") && lineOrder[shuffledArrayIndex] == i && lineRetryArray[i] > 2){
                    shuffledArrayIndex++;
                    if(shuffledArrayIndex<lineOrder.length) {
                        if(lineOrder[shuffledArrayIndex]>i) {
                            i--;
                        } else {
                            i = lineOrder[shuffledArrayIndex]-1;
                        }
                    }
                }

                if((!variablesGenerated || setupVariables.mutation == "linePositionChange" || setupVariables.mutation == "lineMoveLeft" || setupVariables.mutation == "lineMoveRight" || setupVariables.mutation == "lineMoveUp" || setupVariables.mutation == "lineMoveDown") && lineRetryArray[i] < 3) {
                    i--;
                }
                continue;
            }

            // We normalize angle back to be > 0 and < PI and store the updated angle
            angle = angle%PI;
            setupVariables.lines[i].angle= angle;

            // Pick a random length of the line lower than maxLength with a cap TBD and a floor because we don't want points instead of lines
            let length = max(2,floor(lines[i].length*min(min(canvasHeight,canvasWidth)/6,maxLength)));

            lastPositivePixel = findPointOnLine(centerX, centerY, angle, length);
            lastNegativePixel = findPointOnLine(centerX, centerY, angle + PI, length);
            positivePositivePixel = findPointOnLine(lastPositivePixel.x, lastPositivePixel.y, angle+PI/2, halfWidth);
            positiveNegativePixel = findPointOnLine(lastPositivePixel.x, lastPositivePixel.y, angle-PI/2, halfWidth);
            negativePositivePixel = findPointOnLine(lastNegativePixel.x, lastNegativePixel.y, angle+PI/2, halfWidth);
            negativeNegativePixel = findPointOnLine(lastNegativePixel.x, lastNegativePixel.y, angle-PI/2, halfWidth);
        
            // Calculate all of the pixels in the line considering its width ("ancho") in pixels and that it will go half its length in either sense starting at the random point we picked following its angle.
            // To do this, we will add to a lineBorder array all points that are on one of the line's 4 borders
            let fullCorners = [
            positivePositivePixel,
            negativePositivePixel,
            negativeNegativePixel,
            positiveNegativePixel
            ];
            let northBorder = {
            x1: positivePositivePixel.x,
            y1: positivePositivePixel.y,
            x2: negativePositivePixel.x,
            y2: negativePositivePixel.y,
            name: "north"
            };
            let southBorder = {
            x1: positiveNegativePixel.x,
            y1: positiveNegativePixel.y,
            x2: negativeNegativePixel.x,
            y2: negativeNegativePixel.y,
            name: "south"
            };
            let leftBorder = {
            x1: positiveNegativePixel.x,
            y1: positiveNegativePixel.y,
            x2: positivePositivePixel.x,
            y2: positivePositivePixel.y,
            name: "left"
            };
            let rightBorder = {
            x1: negativeNegativePixel.x,
            y1: negativeNegativePixel.y,
            x2: negativePositivePixel.x,
            y2: negativePositivePixel.y,
            name: "right"
            };
            // When adding the pixels along each of these 4 borders, include their weight
            let borders = [northBorder,rightBorder,southBorder,leftBorder];
            let lineBorder = [];
            let Pixels = [];
            let borderOutsideShape = false;
        
            for (let j=0; j<borders.length;j++) {
                let points = getPointsOnLine(borders[j],angle);
                let pointsToPush = [];
                for (let k = 0; k< points.length; k++){
                    let foundPoint = false;
                    for(let l = 0; l<lineBorder.length; l++) {
                        if(
                        lineBorder[l].x == points[k].x &&
                        lineBorder[l].y == points[k].y
                        ){
                        foundPoint = true;
                        let centerPoint = {};
                        for (let m=0;m<fullCorners.length;m++){
                            if(
                                lineBorder[l].x == floor(fullCorners[m].x) &&
                                lineBorder[l].y == floor(fullCorners[m].y)
                            ){
                            centerPoint = fullCorners[m];
                            }
                        }
                        lineBorder[l].weight = calculateAreas(
                            lineBorder[l].crossingPoints,
                            points[k].crossingPoints,
                            centerPoint)[0];
                        }
                        lineBorder[l].borderName = lineBorder[l].borderName+points[k].crossingPoints;
                    }
                    if(!foundPoint){
                        if(shapeArray[points[k].x] == undefined ||
                        shapeArray [points[k].x][points[k].y] != 1) {
                            borderOutsideShape = true;
                            continue;  
                        }
                        pointsToPush.push(points[k]);
                    }
                }
                lineBorder.push(...pointsToPush);
            }
        
            // We don't want the shape border to overlap with the line - can happen if there is a big concavity with a peak right in the middle of the line
            // However this should not happen because we started extending the line from the center, which must be inside the shape

            // If this happens, we retry up to 3 times
            if (borderOutsideShape) {
                // We do this to try to guarantee that a line moves left/right whenever any of them could
                if(variablesGenerated && (setupVariables.mutation == "lineMoveLeft" || setupVariables.mutation == "lineMoveRight" || setupVariables.mutation == "lineMoveUp" || setupVariables.mutation == "lineMoveDown") && lineOrder[shuffledArrayIndex] == i && lineRetryArray[i] > 2){
                    shuffledArrayIndex++;
                    if(shuffledArrayIndex<lineOrder.length) {
                        if(lineOrder[shuffledArrayIndex]>i) {
                            i--;
                        } else {
                            i = lineOrder[shuffledArrayIndex]-1;
                        }
                    }
                }

                if((!variablesGenerated || setupVariables.mutation == "linePositionChange" || setupVariables.mutation == "lineMoveLeft" || setupVariables.mutation == "lineMoveRight" || setupVariables.mutation == "lineMoveUp" || setupVariables.mutation == "lineMoveDown") && lineRetryArray[i] < 3) {
                    i--;
                }
                continue;
            }

            // If we have successfully moved a line left/right, we persist the change
            if(variablesGenerated && (setupVariables.mutation == "lineMoveLeft" || setupVariables.mutation == "lineMoveRight") && lineOrder[shuffledArrayIndex] == i){
                setupVariables.lines[i].centerX = centerX/canvasWidth;
            }

            if(variablesGenerated && (setupVariables.mutation == "lineMoveUp" || setupVariables.mutation == "lineMoveDown") && lineOrder[shuffledArrayIndex] == i){
                setupVariables.lines[i].centerY = centerY/canvasHeight;
            }                      
        
            // Now we need to calculate an array of linePixels that are fully inside these borders
            // We consider all points with a min and max X and min and max Y from the four corners that we calculated above
            // We loop through these points and check if they are inside our line "rectangle"
            let maxBorderX = ceil(max(positivePositivePixel.x,negativePositivePixel.x,negativeNegativePixel.x,positiveNegativePixel.x));
            let minBorderX = floor(min(positivePositivePixel.x,negativePositivePixel.x,negativeNegativePixel.x,positiveNegativePixel.x));
            let maxBorderY = ceil(max(positivePositivePixel.y,negativePositivePixel.y,negativeNegativePixel.y,positiveNegativePixel.y));
            let minBorderY = floor(min(positivePositivePixel.y,negativePositivePixel.y,negativeNegativePixel.y,positiveNegativePixel.y));
        
            let linePixels = [];
        
            for (let j=minBorderX;j<=maxBorderX;j++) {
                for (let k=minBorderY;k<=maxBorderY;k++) {
                    if(isPointInsidePolygon(j, k, borders)){
                    if(!lineBorder.some(
                        point => isEqual(point, { x: j, y: k }
                    ))){
                        linePixels.push({x:j,y:k});  
                    }
                    }
                }
            }
            // We now have a linePixels array with pixels inside the line
            // and a lineBorder array with pixels along the border
            // Set the color of those pixels to black or gray/white just like for the circle
            // TBD if we need different thresholds for lines
            let antialiasThreshold = 75;
            let antialiasThresholdDenominator = 75;
            let antialiasSlope = 10;
            if (gradientType==1){
                antialiasThreshold = 110;
                antialiasThresholdDenominator = 5500;
                antialiasSlope = 1;
            } else if (gradientType==2) {
                antialiasThreshold = 220;    
                antialiasThresholdDenominator = 220;
                antialiasSlope = 0.5;
            }
        
            for(let j=0; j<linePixels.length; j++) {
            let targetPixel = linePixels[j];
            let currentColor = color(
                canvasArray[targetPixel.x][targetPixel.y].r,
                canvasArray[targetPixel.x][targetPixel.y].g,
                canvasArray[targetPixel.x][targetPixel.y].b,
            );
            
            let colorDifference = dist(
                red(currentColor),green(currentColor),blue(currentColor),
                0,0,0
            );
            
            let prevColorCloseToBlack = false;
            let nextColorCloseToBlack = false;

            if(
                gradientType == 2 && 
                weightsArray[targetPixel.x][targetPixel.y] != 0
            ){
                let linesToRight = linesToRightArray[targetPixel.x][targetPixel.y];

                // assuming 25 pixels should be enough to find a non-border
                let nonBorderX = targetPixel.x;
                for(let k=1; k<26; k++) {
                    nonBorderX++;
                    if(linesToRightArray[nonBorderX][targetPixel.y] == 0) {
                        continue;
                    }
                }


                if (linesToRight == 0 || linesToRight == linesToRightArray[nonBorderX][targetPixel.y]) {
                    let prevColorDifference = dist(
                        red(color(selectedcolors[linesToRight])),green(color(selectedcolors[linesToRight])),blue(color(selectedcolors[linesToRight])),
                        0,0,0
                    );
                    let nextColorDifference = dist(
                        red(color(selectedcolors[linesToRight+1])),green(color(selectedcolors[linesToRight+1])),blue(color(selectedcolors[linesToRight+1])),
                        0,0,0
                    );

                    if (prevColorDifference<antialiasThreshold){
                        prevColorCloseToBlack = true;
                    }
                    if (nextColorDifference<antialiasThreshold){
                        nextColorCloseToBlack = true;
                    }
                } else {
                    let prevColorDifference = dist(
                        red(color(selectedcolors[linesToRight-1])),green(color(selectedcolors[linesToRight-1])),blue(color(selectedcolors[linesToRight-1])),
                        0,0,0
                    );
                    let nextColorDifference = dist(
                        red(color(selectedcolors[linesToRight])),green(color(selectedcolors[linesToRight])),blue(color(selectedcolors[linesToRight])),
                        0,0,0
                    );

                    if (prevColorDifference<antialiasThreshold){
                        prevColorCloseToBlack = true;
                    }
                    if (nextColorDifference<antialiasThreshold){
                        nextColorCloseToBlack = true;
                    }
                }

                if (prevColorCloseToBlack != nextColorCloseToBlack) {
                    let newWhiteColor = lerpColor(color(255,255,255),color(0,0,0),weightsArray[targetPixel.x][targetPixel.y]);

                    if (nextColorCloseToBlack) {
                        newWhiteColor = lerpColor(color(0,0,0),color(255,255,255),weightsArray[targetPixel.x][targetPixel.y]);
                    }
                
                    canvasArray[targetPixel.x][targetPixel.y] = {
                        r: red(newWhiteColor),
                        g: green(newWhiteColor),
                        b: blue(newWhiteColor),
                    };
                    continue;
                }

            }

            if (
                bordersArray[targetPixel.x][targetPixel.y] !== 1
            ) {

                let originalColor = color(
                    preShapesCanvasArray[targetPixel.x][targetPixel.y].r,
                    preShapesCanvasArray[targetPixel.x][targetPixel.y].g,
                    preShapesCanvasArray[targetPixel.x][targetPixel.y].b
                );
                let originalColorDifference = dist(
                    red(originalColor),green(originalColor),blue(originalColor),
                    0,0,0
                );
            
                let newColor = lerpColor(
                        color(255,255,255),
                        color(0,0,0),
                        bordersArray[targetPixel.x][targetPixel.y]
                );

                if (originalColorDifference<antialiasThreshold) {
                    let midThreshold = antialiasThreshold-antialiasSlope*2;

                    let newWhiteColor = lerpColor(color(255,255,255),color(0,0,0),
                        (Math.exp((originalColorDifference - midThreshold) / antialiasSlope) - Math.exp(-(originalColorDifference - midThreshold) / antialiasSlope)) /
                        (Math.exp((originalColorDifference - midThreshold) / antialiasSlope) + Math.exp(-(originalColorDifference - midThreshold) / antialiasSlope))
                        * 0.5 + 0.5
                    );

                    newColor = lerpColor(
                        color(0,0,0),
                        color(red(newWhiteColor),green(newWhiteColor),blue(newWhiteColor)),
                        bordersArray[targetPixel.x][targetPixel.y]
                    );
                }
            
                canvasArray[targetPixel.x][targetPixel.y] = {
                    r: red(newColor),
                    g: green(newColor),
                    b: blue(newColor),
                };
            } else if (colorDifference<antialiasThreshold && (weightsArray[targetPixel.x][targetPixel.y] === 0 || (gradientType != 2 || setupVariables.dividerCount === 0 || prevColorCloseToBlack !== nextColorCloseToBlack || (prevColorCloseToBlack && nextColorCloseToBlack)))) {
                let midThreshold = antialiasThreshold-antialiasSlope*2;

                let newWhiteColor = lerpColor(color(255,255,255),color(0,0,0),
                    (Math.exp((colorDifference - midThreshold) / antialiasSlope) - Math.exp(-(colorDifference - midThreshold) / antialiasSlope)) /
                    (Math.exp((colorDifference - midThreshold) / antialiasSlope) + Math.exp(-(colorDifference - midThreshold) / antialiasSlope))
                    * 0.5 + 0.5
                );
            
                canvasArray[targetPixel.x][targetPixel.y] = {
                    r: red(newWhiteColor),
                    g: green(newWhiteColor),
                    b: blue(newWhiteColor),
                };
            } else {
                canvasArray[targetPixel.x][targetPixel.y] = {
                    r: 0,
                    g: 0,
                    b: 0,
                };
            }
            }
        
            // Once line is full, we need to smooth out jagged lines
            if(gradientType != 2){
                //antiAliasShapeFill(linePixels);
            }
        
            // Set the color of the border pixels by antialiasing just like for the circles
            for(let j=0; j<lineBorder.length; j++) {
                let targetPixel = lineBorder[j];
                
                if(canvasArray[targetPixel.x] == undefined ||
                    canvasArray[targetPixel.x][targetPixel.y] == undefined
                ) {continue;}
                
                let currentRed = canvasArray[targetPixel.x][targetPixel.y].r;
                let currentGreen = canvasArray[targetPixel.x][targetPixel.y].g;
                let currentBlue = canvasArray[targetPixel.x][targetPixel.y].b;
                

                bordersArray[targetPixel.x][targetPixel.y] = targetPixel.weight;

                let colorDifference = dist(
                    currentRed,
                    currentGreen,
                    currentBlue,
                    0,0,0
                );
            
            if (colorDifference<antialiasThreshold) {
                let midThreshold = antialiasThreshold-antialiasSlope*2;

                let newWhiteColor = lerpColor(color(255,255,255),color(0,0,0),
                    (Math.exp((colorDifference - midThreshold) / antialiasSlope) - Math.exp(-(colorDifference - midThreshold) / antialiasSlope)) /
                    (Math.exp((colorDifference - midThreshold) / antialiasSlope) + Math.exp(-(colorDifference - midThreshold) / antialiasSlope))
                    * 0.5 + 0.5
                );

                let newColor = lerpColor(
                    newWhiteColor,
                    color(currentRed,currentGreen,currentBlue),
                    bordersArray[targetPixel.x][targetPixel.y]
                );

                canvasArray[targetPixel.x][targetPixel.y] = {
                    r: red(newColor),
                    g: green(newColor),
                    b: blue(newColor),
                };
            } else {
                let newColor = lerpColor(
                    color(0,0,0),
                    color(currentRed,currentGreen,currentBlue),
                    bordersArray[targetPixel.x][targetPixel.y]
                );

                canvasArray[targetPixel.x][targetPixel.y] = {
                    r: red(newColor),
                    g: green(newColor),
                    b: blue(newColor),
                };
            }
            }
        }
        
        
        // Loop through each pixel in the matchingPixels array this time to set adjusted colors and setPixelColor on the canvas
        for (let i = 0; i < matchingPixels.length; i++) {
            let pixel = matchingPixels[i];
            let pixelData = canvasArray[pixel.x][pixel.y];
            let pixelColor = color(pixelData.r,pixelData.g,pixelData.b);

            setPixelColor(pixel.x, pixel.y, pixelColor);
        }
        
        updatePixels();
        if(variablesGenerated) {
            setupVariables.changeHistory.push(getOriginalValues(initalVariablesObj,setupVariables));
            
            //Due to blockchain storage limits, we need to cap this, so we cap at a history of 5
            if (setupVariables.changeHistory.length > 5) {
                setupVariables.changeHistory = setupVariables.changeHistory.slice(-5);
            }

        } else {
            setupVariablesCopy = JSON.parse(JSON.stringify(setupVariables));
            setupVariables.initialVariables = setupVariablesCopy;
        }
        console.log(setupVariables);
    }

    // Function to calculate the distance from a point (x, y) to a line
    function distToLine(x, y, line) {
        let x1 = line.x1;
        let y1 = line.y1;
        let x2 = line.x2;
        let y2 = line.y2;

        let numer = abs((y2 - y1) * x - (x2 - x1) * y + x2 * y1 - y2 * x1);
        let denom = dist(x1, y1, x2, y2);
        return numer / denom;
    }

    // Function to find surrounding pixels within a certain radius
    function findSurroundingPixels(pixel, pixelArray, radius = 1, withinShape = 0, maskArray = shapeArray) {
        let result = [];
        for(let i = -radius;i<=radius;i++){
        for (let j = -radius; j<=radius;j++){
        if(pixelArray &&
        pixelArray[i+pixel.x] &&
        pixelArray[i+pixel.x][j+pixel.y] &&
            (i+j)!=0 &&
            i+pixel.x>=0 &&
            j+pixel.y>=0 &&
            j+pixel.y<pixelArray[i+pixel.x].length)
        {
            if (withinShape === 0 || maskArray[i+pixel.x][j+pixel.y] === 1){
            result.push(pixelArray[i+pixel.x][j+pixel.y]);    
            }
        }
        }
        }
        return result;
    }

    // Function to calculate the average color component (r, g, or b) of an array of pixels
    function calculateAverageColorComponent(pixels, component) {
        if ( pixels.length == 0) {
            return 0;  
        }
        
        let total = 0;
        for (let i = 0; i < pixels.length; i++) {
            total += pixels[i][component];
        }
        return total / pixels.length;
    }


    function setPixelColor(x, y, color) {
        let pixelIndex = (x + y * width) * 4; // Calculate the pixel index in the pixel array

        // Set the color of the pixel
        pixels[pixelIndex] = red(color);
        pixels[pixelIndex + 1] = green(color);
        pixels[pixelIndex + 2] = blue(color);
        pixels[pixelIndex + 3] = 255; // Alpha value (fully opaque)

        canvasArray[x][y] = {
            r: red(color),
            g: green(color),
            b: blue(color),
        };
    }

    function findFirstLineToRightDistance(pixel, direction) {
        let minDist = Infinity;
        let maximumX = canvasWidth;
        let lineIndex = 0;
        if (direction == -1){
            maximumX = 0;
        }
        // Loop through each line in previousLines and find the intersection point with a ray cast from our point to the right end of the canvas (or left, if we reverse directions)
        // If there is an intersection point and it is the smallest so far, update minDist
        for (let j = 0; j < previousLines.length; j++) {
            let line = previousLines[j];
            let intersectionPoint = findIntersectionAnywhere(pixel.x, pixel.y, maximumX, pixel.y, line.x1, line.y1, line.x2, line.y2,direction);

            if (intersectionPoint) {
                //We do not want the shortest distance to the line, just the horizontal distance to the line
                let dist = abs(pixel.x - intersectionPoint.x);
                if (dist < minDist) {
                    minDist = dist;
                    lineIndex = j;
                }
            }
        }

        return [minDist,lineIndex];
    }

    function countLinesToRight(pixel) {
        let linesToRight = 0;
        let borderWeight = 0;

        // Loop through each line in previousLines
        for (let j = 0; j < previousLines.length; j++) {
            let line = previousLines[j];

            // Check if the pixel is to the left of the line
            if (
            pixel.x < line.x1 + (pixel.y - line.y1) / (line.y2-line.y1) * (line.x2 - line.x1)
            ) {
            linesToRight++;
            // Check if next pixel is at less than 1 pixel away from the line
                if (distToLine(pixel.x, pixel.y, line)<1) {
                    //If so, that means we are a border
                    borderWeight = distToLine(pixel.x, pixel.y, line);
                }
            }
        }

        return [linesToRight,borderWeight];
    }


    function checkIfRight(pixel,line) {
        let isPixelRight = true;

            // Check if the pixel is to the left of the line
            if (
            pixel.x < line.x1 + (pixel.y - line.y1) / (line.y2-line.y1) * (line.x2 - line.x1)
            ) {
            isPixelRight = false;
            }

        return isPixelRight;
    }

    function drawLine(startX, initialAngle, minAngle, maxAngle) {
        let diagonal = ceil((canvasHeight**2+canvasWidth**2)**0.5);
        let angle = adjustAngle(startX,initialAngle,minAngle,maxAngle,diagonal);

        if(angle == null) {
            return;
        }

        let endX = startX + cos(angle) * diagonal;
        let endY = sin(angle) * diagonal;
        
        // If there are no intersections with previous lines, draw the line and store it in previousLines
        //line(startX, 0, endX, endY);
        previousLines.push({ x1: startX, y1: 0, x2: endX, y2: endY });
    }


    function adjustAngle(startX,initialAngle,minAngle,maxAngle,diagonal){
        let lineLength = diagonal; // Adjust the length as needed, should be at least canvas diagonal
        let angle = initialAngle;
        let intersection = 0;
        let minReached = false;
        
        while (intersection == 0){
            intersection = 1;
            let endX = startX + cos(angle) * lineLength;
            let endY = sin(angle) * lineLength;
            // Check for intersections with previously drawn lines
            for (let i = 0; i < previousLines.length; i++) {
                let existingLine = previousLines[i];
                let intersectionPoint = findIntersection(startX, 0, endX, endY, existingLine.x1, existingLine.y1, existingLine.x2, existingLine.y2);
            
                if (intersectionPoint && pointInMatchingPixels(intersectionPoint)) {
                    intersection = intersection * 0;
                } else {
                    intersection = intersection * 1;
                }
            }
            
            if(intersection == 1){
                break;
            }
            
            if(angle > minAngle && !minReached){
                angle -= 0.02;
                angle = Math.max(angle,minAngle);
            } else {
                if (!minReached){
                    minReached = true;
                    angle = initialAngle + 0.02
                } else {
                    angle += 0.02;
                    angle = Math.min(angle,maxAngle);
                }
            }
            
            if(angle > maxAngle){
                //we did not manage to find a possible line
                return null;
            }
        }
        
        return angle;
    }

    function pointInMatchingPixels(point) {
        // Check if the point is within matchingPixels
        for (let i = 0; i < matchingPixels.length; i++) {
            let existingPoint = matchingPixels[i];
            if (dist(point.x, point.y, existingPoint.x, existingPoint.y) < 1) {
            return true;
            }
        }
        return false;
    }

    function findIntersection(x1, y1, x2, y2, x3, y3, x4, y4) {
        // Calculate the intersection point of two lines
        let denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (denominator === 0) {
            return null; // Lines are parallel or coincident
        }

        // We round to avoid results like 63.00000000000001 instead of 63
        let intersectionX = round(((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denominator,12);
        let intersectionY = round(((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denominator,12);

        // Check if the intersection point is on the line segments
        if (
            intersectionX >= Math.min(x1, x2) &&
            intersectionX <= Math.max(x1, x2) &&
            intersectionY >= Math.min(y1, y2) &&
            intersectionY <= Math.max(y1, y2) &&
            intersectionX >= Math.min(x3, x4) &&
            intersectionX <= Math.max(x3, x4) &&
            intersectionY >= Math.min(y3, y4) &&
            intersectionY <= Math.max(y3, y4)
        ) {
            return createVector(intersectionX, intersectionY);
        }

        return null; // Intersection point is outside the line segments
    }

    function findIntersectionAnywhere(x1, y1, x2, y2, x3, y3, x4, y4,direction = 1) {
        // Calculate the intersection point of two lines
        let denominator = (x1 - x2) * (y3 - y4) - (y1 - y2) * (x3 - x4);

        if (denominator === 0) {
            return null; // Lines are parallel or coincident
        }

        let intersectionX = ((x1 * y2 - y1 * x2) * (x3 - x4) - (x1 - x2) * (x3 * y4 - y3 * x4)) / denominator;
        let intersectionY = ((x1 * y2 - y1 * x2) * (y3 - y4) - (y1 - y2) * (x3 * y4 - y3 * x4)) / denominator;

            // Check only if the intersection point is in the desired direction
        if (
            (direction == 1 && intersectionX >= x1) ||
            (direction == -1 && intersectionX <= x1)
        ) {
            return createVector(intersectionX, intersectionY);
        }

        return null; // Intersection point is outside the line segments
    }


    function findNextUnconnectedSeed(currentSeed, seedpoints, connectedLeftEdges, connectedRightEdges, currentIndex) {
        let nextSeedIndex = -1;

        for (let i = 0; i < seedpoints.length; i++) {
            let adjustedIndex = (currentIndex + i) % seedpoints.length;
            if (!connectedLeftEdges[adjustedIndex] && adjustedIndex !== currentIndex && !connectedRightEdges[adjustedIndex]) {
            nextSeedIndex = adjustedIndex;
            return nextSeedIndex;
            }
        }
        return nextSeedIndex;
    }

    function findCentralPoint(points) {
        let centralX = 0;
        let centralY = 0;

        for (let point of points) {
            centralX += point.x;
            centralY += point.y;
        }

        return {
            x: centralX / points.length,
            y: centralY / points.length,
        };
    }

    function generateSeedpoints(baseRadius) {
        // Mean for the Poisson distribution
        let mean = 8;

        // Generate a random number of seedpoints from 5 to 20
        if(!variablesGenerated){
            setupVariables.numSeedpoints = constrain(floor(randomGaussian(mean, sqrt(mean))), 5, 20);
        } else if(setupVariables.mutation == "seedPointCountIncrease" && setupVariables.numSeedpoints < 20){
            setupVariables.numSeedpoints++;
        } else if(setupVariables.mutation == "seedPointCountDecrease" && setupVariables.numSeedpoints > 5){
            setupVariables.numSeedpoints--;
            let randomIndex = floor(random(setupVariables.seedpoints.length));
            setupVariables.seedpoints.splice(randomIndex,1);
        }

        let numSeedpoints = setupVariables.numSeedpoints;

        // Generate seedpoints
        let radius = baseRadius;
        let targetSeedpoint = -1;

        if(variablesGenerated && setupVariables.mutation.includes("seedpoint")) {
            if (setupVariables.mutation.includes("-")) {
                let splitMutation = setupVariables.mutation.split("-");
                setupVariables.mutation = splitMutation[0];
                let zone = splitMutation[1];
                let classifiedPoints = {
                    "top": [],
                    "bottom": [],
                    "left": [],
                    "right": []
                }

                // Find the centroid of the points
                let points =  setupVariables.seedpoints.map(item => ({
                    x: item.x,
                    y: item.y,
                }));

                const centroid = points.reduce((acc, point) => ({ x: acc.x + point.x, y: acc.y + point.y }), { x: 0, y: 0 });
                centroid.x /= points.length;
                centroid.y /= points.length;

                for (let i=0; i<setupVariables.seedpoints.length; i++) {
                    if(setupVariables.seedpoints[i].x > centroid.x) {
                        classifiedPoints.right.push(i);
                    } else { 
                        classifiedPoints.left.push(i);
                    }
                    
                    if(setupVariables.seedpoints[i].y > centroid.y) {
                        classifiedPoints.bottom.push(i);
                    } else { 
                        classifiedPoints.top.push(i);
                    }
                }

                let possibleIndices = classifiedPoints[zone];

                targetSeedpoint = possibleIndices[floor(random(possibleIndices.length))];
            } else {
                targetSeedpoint = floor(random(setupVariables.numSeedpoints));
            }
        }

        for (let i = 0; i < numSeedpoints; i++) {
            if (!setupVariables.seedpoints[i]) {
                let radiusIncrease = random(1,PI);
                radius = baseRadius * radiusIncrease;
                let x = random(radius, canvasWidth - radius)/canvasWidth;
                let y = random(radius, canvasHeight - radius)/canvasHeight;
            
                // Generate two additional values
                let curvature = random(0.5, 1.5);
                let percentageDistance = round(random(0, 1), 7);
                //setupVariables.seedpoints[i] = [];

                setupVariables.seedpoints[i] = { x, y, curvature, percentageDistance, radiusIncrease };
            } else if (i == targetSeedpoint) {
                switch (setupVariables.mutation) {
                    case "seedpointMoveRight":
                        radius = baseRadius * setupVariables.seedpoints[i].radiusIncrease;
                        setupVariables.seedpoints[i].x = random(setupVariables.seedpoints[i].x*canvasWidth, canvasWidth - radius)/canvasWidth;
                        break;
                    case "seedpointMoveLeft":
                        radius = baseRadius * setupVariables.seedpoints[i].radiusIncrease;
                        setupVariables.seedpoints[i].x = random(radius, setupVariables.seedpoints[i].x*canvasWidth)/canvasWidth;
                        break;
                    case "seedpointMoveUp":
                        radius = baseRadius * setupVariables.seedpoints[i].radiusIncrease;
                        setupVariables.seedpoints[i].y = random(radius, setupVariables.seedpoints[i].y*canvasHeight)/canvasHeight;
                        break;
                    case "seedpointMoveDown":
                        radius = baseRadius * setupVariables.seedpoints[i].radiusIncrease;
                        setupVariables.seedpoints[i].y = random(setupVariables.seedpoints[i].y*canvasHeight, canvasHeight - radius)/canvasHeight;
                        break;
                    case "seedpointChangeCurveCenter":
                        setupVariables.seedpoints[i].percentageDistance = round(random(0, 1), 7);
                        break;
                    case "seedpointIncreaseConcavity":
                        setupVariables.seedpoints[i].curvature = min(2,random(setupVariables.seedpoints[i].curvature*1.1, 1.5));
                        break;
                    case "seedpointDecreaseConcavity":
                        setupVariables.seedpoints[i].curvature = max(0.375,random(0.5, setupVariables.seedpoints[i].curvature/1.1));
                        break;
                    case "seedpointIncreaseRadius":
                        setupVariables.seedpoints[i].radiusIncrease = random(setupVariables.seedpoints[i].radiusIncrease*1.1,PI);
                        //an increase might push us out of the canvas, we need to double check. A decrease never will.
                        radius = baseRadius * setupVariables.seedpoints[i].radiusIncrease;
                        if((setupVariables.seedpoints[i].x*canvasWidth + radius) > canvasWidth) {
                            setupVariables.seedpoints[i].radiusIncrease = (canvasWidth - setupVariables.seedpoints[i].x*canvasWidth)/baseRadius;
                        };
                        if((setupVariables.seedpoints[i].x*canvasWidth - radius) < 0) {
                            setupVariables.seedpoints[i].radiusIncrease = (setupVariables.seedpoints[i].x*canvasWidth)/baseRadius;
                        };
                        if((setupVariables.seedpoints[i].y*canvasHeight + radius) > canvasHeight) {
                            setupVariables.seedpoints[i].radiusIncrease = (canvasHeight - setupVariables.seedpoints[i].y*canvasHeight)/baseRadius;
                        };
                        if((setupVariables.seedpoints[i].y*canvasHeight - radius) < 0) {
                            setupVariables.seedpoints[i].radiusIncrease = (setupVariables.seedpoints[i].y*canvasHeight)/baseRadius;
                        };
                        break;
                    case "seedpointDecreaseRadius":
                        setupVariables.seedpoints[i].radiusIncrease = random(1,setupVariables.seedpoints[i].radiusIncrease/1.1);
                        break;
                }
            }
        }
    }

    function drawSemicircle(x, y, radius, centralPoint) {
        push();
        translate(x, y);

        // Calculate the angle to face the edges of the canvas
        let angle = atan2(centralPoint.y - y, centralPoint.x - x) + PI / 2;

        rotate(angle);

        // Draw a half circle (180 degrees) using the arc function
        arc(0, 0, radius * 2, radius * 2, 0, PI);
        pop();
    }

    function findConvexHull(relativePoints) {
        // Find the centroid of the points
        let points =  relativePoints.map(item => ({
            x: item.x * canvasWidth,
            y: item.y * canvasHeight,
            curvature: item.curvature * maxCurvature,
            percentageDistance: item.percentageDistance,
            radiusIncrease: item.radiusIncrease
        }));

        const centroid = points.reduce((acc, point) => ({ x: acc.x + point.x, y: acc.y + point.y }), { x: 0, y: 0 });
        centroid.x /= points.length;
        centroid.y /= points.length;

        // Sort the points based on polar angle with respect to the centroid
        points.sort((a, b) => {
            const angleA = Math.atan2(a.y - centroid.y, a.x - centroid.x);
            const angleB = Math.atan2(b.y - centroid.y, b.x - centroid.x);
            return angleA - angleB;
        });

        return points;
    }

    // Function to draw an arc with a peak at a certain percentage of the distance between two points
    function drawArc(startX, startY, endX, endY, controlX, controlY) {
        vertex(startX, startY);
        quadraticVertex(controlX, controlY, endX, endY);
    }

    // Function to apply antialiasing to pixel colors stored in canvasArray
    function applyAntialiasing(radius,inShape = true,restrict = false, includedPoints=[]) {

        if(floor(radius) == 0) {
        return;
        }

        let tempCanvasArray = JSON.parse(JSON.stringify(canvasArray)); // Create a copy of the original canvasArray

        // Loop through each pixel in the canvasArray
        for (let x = 0; x < canvasWidth; x++) {
            for (let y = 0; y < canvasHeight; y++) {
            let pixel = canvasArray[x][y];
            if(inShape && !shapeArray[x][y]){
                continue;
            }
            if(restrict && !includedPoints.some(point => isEqual(point, { x: x, y: y }))) {
                continue;  
            }

            if (pixel !== undefined) {
                // Find surrounding pixels within a certain radius
                let surroundingPixels = findSurroundingPixels({ x, y }, tempCanvasArray, radius, 1);

                // Calculate the average values for red, green, and blue
                let avgRed = calculateAverageColorComponent(surroundingPixels, 'r');
                let avgGreen = calculateAverageColorComponent(surroundingPixels, 'g');
                let avgBlue = calculateAverageColorComponent(surroundingPixels, 'b');

                // Update the pixel color in canvasArray
                canvasArray[x][y] = {
                r: avgRed,
                g: avgGreen,
                b: avgBlue,
                };
            }
            }
        }
    }

    function applyGradients(subArrays,interpolationFactorsArrays,selectedColors,splitFlagsArray) {
        // We loop through each pixel in each subarray
        for (let i = 0;i<subArrays.length; i++) {
            // We calculate the start and end color that this subarray should have
            let startColor = selectedColors[i];
            let endColor = selectedColors[i+1];

            for(let j = 0; j < subArrays[i].length; j++) {
                let pixel = subArrays[i][j];
                
                if(i == (subArrays.length-1)) {
                startColor = selectedColors[selectedColors.length-2];
                endColor = selectedColors[selectedColors.length-1];
                } else if (i > 0) {
                if(splitFlagsArray[i][j] == -1){
                    startColor = selectedColors[i*2-1];
                    endColor = selectedColors[i*2];
                } else if (splitFlagsArray[i][j] == 1) {
                    startColor = selectedColors[i*2];
                    endColor = selectedColors[i*2+1];    
                } else {
                    startColor = selectedColors[i*2];
                    endColor = selectedColors[i*2];
                }
                }
            
                let lerpFactor = interpolationFactorsArrays[i][j];
                // Calculate the r, g and b coponents of this pixel using its interpolationFactor
                // if we are in the rightmost section we need to invert the factor because distances were calculated backwards so 100% is the end and not the start
                if(i==0 || splitFlagsArray[i][j] == 1) { lerpFactor = 1-lerpFactor;}
                
            
                let newColor = lerpColor(startColor,endColor,lerpFactor);
                // Set the new canvasArray color
                canvasArray[pixel.x][pixel.y] = {
                    r: red(newColor),
                    g: green(newColor),
                    b: blue(newColor),
                }
            }
        }
    }

    function findLinearRegression(points) {
        let sumX = 0;
        let sumY = 0;
        let sumXY = 0;
        let sumX2 = 0;

        for (let i = 0; i < points.length; i++) {
            sumX += points[i].x;
            sumY += points[i].y;
            sumXY += points[i].x * points[i].y;
            sumX2 += points[i].x ** 2;
        }

        let n = points.length;
        let m = (n * sumXY - sumX * sumY) / (n * sumX2 - sumX ** 2);
        let b = (sumY - m * sumX) / n;

        return { m, b };
    }

    function calculateGoodnessOfFit(points, linearRegression) {
        let sumSquaredErrors = 0;

        for (let i = 0; i < points.length; i++) {
            let predictedY = linearRegression.m * points[i].x + linearRegression.b;
            let error = points[i].y - predictedY;
            sumSquaredErrors += error ** 2;
        }

        let meanY = points.reduce((sum, point) => sum + point.y, 0) / points.length;
        let totalSumOfSquares = points.reduce((sum, point) => sum + (point.y - meanY) ** 2, 0);

        // R-squared value
        let rSquared = 1 - sumSquaredErrors / totalSumOfSquares;

        return rSquared;
    }

    function calculatePixelsInsideCircle(cx, cy, r) {
        let includedPixels = [];
        let borderPixels = [];
        let startX = max(0,cx-r-1);
        let endX = min(width,cx+r+1);
        let startY = max(0,cy-r-1);
        let endY = min(height,cy+r+1);
        
        for (let x = startX; x <= endX; x++) {
            for (let y = startY; y <= endY; y++) {
            // Calculate distance from the center of the circle
            let d = dist(x, y, cx, cy);
            // If the distance is less than the radius, the pixel is inside the circle
            if (d < r) {
                if (canvasArray[x] == undefined || canvasArray[x][y] == undefined || shapeArray[x][y] != 1) {
                    return null;    
                }
                    includedPixels.push({
                    x:x,
                    y:y
                });
            } else if (floor(d)<=r) {
                if (canvasArray[x] == undefined || canvasArray[x][y] == undefined || shapeArray[x][y] != 1) {
                    return null;    
                }
                borderPixels.push({
                    x:x,
                    y:y,
                    weight: d-floor(d)
                });  
            }
            }
        }
        return [includedPixels,borderPixels];
    }

    function isEqual(obj1, obj2) {
        return obj1.x === obj2.x && obj1.y === obj2.y;
    }

    function findPointOnLine(x1, y1, angle, distance) {
        let x2 = x1 + distance * cos(angle);
        let y2 = y1 + distance * sin(angle);
        return createVector(x2, y2);
    }

    function getPointsOnLine(line, angle) {
        let points = [];
        
        let minimumX = floor(min(line.x1,line.x2));
        let maximumX = ceil(max(line.x1,line.x2));
        let minimumY = floor(min(line.y1,line.y2));
        let maximumY = ceil(max(line.y1,line.y2));

        for(let i = minimumX; i <= maximumX; i++) {
            for(let j = minimumY; j <= maximumY; j++){
            //Treat the pixel like a small square and check if the line crosses it
            let pixelBorderLines = [
                {x1: i, y1: j, x2: i+1, y2:j},
                {x1: i+1, y1: j, x2: i+1, y2:j+1},
                {x1: i+1, y1: j+1, x2: i, y2:j+1},
                {x1: i, y1: j+1, x2: i, y2:j}
            ];
            let lineCrosses = false;
            let intersections = [];
            
            for(let k=0; k< pixelBorderLines.length; k++) {
                let intersection = findIntersection(
                pixelBorderLines[k].x1, pixelBorderLines[k].y1,
                pixelBorderLines[k].x2, pixelBorderLines[k].y2,
                line.x1, line.y1,
                line.x2, line.y2
                )
                if (intersection != null){
                lineCrosses = true;
                intersections.push({
                    x: intersection.x,
                    y: intersection.y,
                    x0: i,
                    y0: j,
                });
                }
            }
            
            if(lineCrosses) {
                // Calculate area of the pixel that is black assuming that only one line crosses it
                let outsideArea = 1;
                if(intersections.length == 2){
                let topLeftCornerArea = calculateSimpleAreas(i,j,intersections[0],intersections[1],true)[0];
                let topRightCornerArea = calculateSimpleAreas(i+1,j,intersections[0],intersections[1],false)[0];
                
                if(line.name == "right"){
                    if(angle < PI/2) {
                    outsideArea = topLeftCornerArea;
                    } else {
                    outsideArea = topRightCornerArea;
                    }
                } else if (line.name == "left") {
                    if(angle < PI/2) {
                    outsideArea = 1-topLeftCornerArea;
                    } else {
                    outsideArea = 1-topRightCornerArea;
                    }
                } else if (line.name == "north") {
                    if(angle < PI/2) {
                    outsideArea = 1-topRightCornerArea;
                    } else {
                    outsideArea = topLeftCornerArea;
                    }
                } else if (line.name == "south") {
                    if(angle < PI/2) {
                    outsideArea = topRightCornerArea;
                    } else {
                    outsideArea = 1-topLeftCornerArea;
                    }
                }
                }

                points.push({
                    x: i,
                    y: j,
                    weight: outsideArea,
                    crossingPoints: intersections,
                    borderName: line.name,
                })  
            }
            }
        }

        return points;
    }

    function isPointInsidePolygon(x, y, lines) {
        let count = 0;
        for (let i = 0; i < lines.length; i++) {
            let thisLine = lines[i];
            if (
            (y<thisLine.y1)!=(y<thisLine.y2) &&
            x < thisLine.x1 + ((y-thisLine.y1)/(thisLine.y2-thisLine.y1)) * (thisLine.x2 - thisLine.x1)
            ) {
            count++;
            }
        }
        return count % 2 === 1;
    }

    function calculateAreas(intersection1,intersection2,centerPoint) {
        let area1 = 1;
        let area2 = 0;
        
        if(intersection1.length>1 || intersection2.length >1){
        // I think this should only happen if we have 4 intersections
        let splitLine = intersection1;
        
        let splitLine1 = splitLine[0].x == floor(splitLine[0].x) ? "x" : "y";
        let splitLine2 = splitLine[1].x == floor(splitLine[1].x) ? "x" : "y";
        
        let thirdVertex = {};
        
        thirdVertex[splitLine1] = splitLine[0][splitLine1];
        thirdVertex[splitLine2] = splitLine[1][splitLine2];
        
        let subArea1 = calculateArea(
            splitLine[0].x, splitLine[0].y,
            thirdVertex.x, thirdVertex.y,
            splitLine[1].x, splitLine[1].y
        );
        
        // If both are on the same axis, this means we have a trapeze
        if(splitLine1 == splitLine2){
            // In this case we have to divide into 2 triangles
            // Both triangles will share one of the interesection points and the opposing vertex
            // The third vertex of each triangle will be either the other intersection point or the other contiguous vertex
            let firstCommonVertex = [splitLine[0].x, splitLine[0].y];
            let otherIntersection = [splitLine[1].x, splitLine[1].y];
            let otherLine = intersection2;
            // To understand what area we need to calculate we need to check if the lower of intersection2's x/y coordinates is higher than the higher of intersecton1's x/y coordinate
            let maxX1 = max(splitLine[0].x,splitLine[1].x);
            let maxY1 = max(splitLine[0].y,splitLine[1].y);
            let minX1 = min(splitLine[0].x,splitLine[1].x);
            let minY1 = min(splitLine[0].y,splitLine[1].y);
            let maxX2 = max(otherLine[0].x,otherLine[1].x);
            let maxY2 = max(otherLine[0].y,otherLine[1].y);
            let minX2 = min(otherLine[0].x,otherLine[1].x);
            let minY2 = min(otherLine[0].y,otherLine[1].y);
            
            let secondCommonVertexX = 0;
            let secondCommonVertexY = 0;
            
            let otherVertexX = 0;
            let otherVertexY = 0;
            
            if (maxX1 < minX2) {
            secondCommonVertexY = maxY1;
            secondCommonVertexX = floor(splitLine[0].x);
            if(maxY1 == splitLine[0].y) {
                firstCommonVertex = [splitLine[1].x, splitLine[1].y];
                otherIntersection = [splitLine[0].x, splitLine[0].y];
            }
            otherVertexX = secondCommonVertexX;
            otherVertexY = secondCommonVertexY - 1;
            }
            
            if (maxX2 < minX1) {
            secondCommonVertexY = maxY1;
            secondCommonVertexX = ceil(splitLine[0].x);
            if(maxY1 == splitLine[0].y) {
                firstCommonVertex = [splitLine[1].x, splitLine[1].y];
                otherIntersection = [splitLine[0].x, splitLine[0].y];
            }
            otherVertexX = secondCommonVertexX;
            otherVertexY = secondCommonVertexY - 1;
            }
            
            if (maxY1 < minY2) {
            secondCommonVertexX = maxX1;
            secondCommonVertexY = floor(splitLine[0].y);
            if(maxX1 == splitLine[0].x) {
                firstCommonVertex = [splitLine[1].x, splitLine[1].y];
                otherIntersection = [splitLine[0].x, splitLine[0].y];
            }
            otherVertexX = secondCommonVertexX - 1;
            otherVertexY = secondCommonVertexY;
            }
            
            if (maxY2 < minY1) {
            secondCommonVertexX = maxX1;
            secondCommonVertexY = ceil(splitLine[0].y);
            if(maxX1 == splitLine[0].x) {
                firstCommonVertex = [splitLine[1].x, splitLine[1].y];
                otherIntersection = [splitLine[0].x, splitLine[0].y];
            }
            otherVertexX = secondCommonVertexX - 1;
            otherVertexY = secondCommonVertexY;
            }
            
            let secondCommonVertex = [secondCommonVertexX, secondCommonVertexY];
            
            let otherVertex = [otherVertexX, otherVertexY];
            
            let subSubArea1 = calculateArea(
            firstCommonVertex[0], firstCommonVertex[1],
            secondCommonVertex[0], secondCommonVertex[1],
            otherIntersection[0], otherIntersection[1]
            );
            
            let subSubArea2 = calculateArea(
            firstCommonVertex[0], firstCommonVertex[1],
            secondCommonVertex[0], secondCommonVertex[1],
            otherVertex[0], otherVertex[1]
            );
            
            subArea1 = subSubArea1 + subSubArea2;
            
        }
        
        splitLine = intersection2;
        
        splitLine1 = splitLine[0].x == floor(splitLine[0].x) ? "x" : "y";
        splitLine2 = splitLine[1].x == floor(splitLine[1].x) ? "x" : "y";
        
        thirdVertex = {};
        
        thirdVertex[splitLine1] = splitLine[0][splitLine1];
        thirdVertex[splitLine2] = splitLine[1][splitLine2];
        
        let subArea2 = calculateArea(
            splitLine[0].x, splitLine[0].y,
            thirdVertex.x, thirdVertex.y,
            splitLine[1].x, splitLine[1].y
        );
        
            // If both are on the same axis, this means we have a trapeze
        if(splitLine1 == splitLine2){
            // In this case we have to divide into 2 triangles
            // Both triangles will share one of the interesection points and the opposing vertex
            // The third vertex of each triangle will be either the other intersection point or the other contiguous vertex
            let firstCommonVertex = [splitLine[0].x, splitLine[0].y];
            let otherIntersection = [splitLine[1].x, splitLine[1].y];
            let otherLine = intersection1;
            // To understand what area we need to calculate we need to check if the lower of intersection2's x/y coordinates is higher than the higher of intersecton1's x/y coordinate
            let maxX1 = max(splitLine[0].x,splitLine[1].x);
            let maxY1 = max(splitLine[0].y,splitLine[1].y);
            let minX1 = min(splitLine[0].x,splitLine[1].x);
            let minY1 = min(splitLine[0].y,splitLine[1].y);
            let maxX2 = max(otherLine[0].x,otherLine[1].x);
            let maxY2 = max(otherLine[0].y,otherLine[1].y);
            let minX2 = min(otherLine[0].x,otherLine[1].x);
            let minY2 = min(otherLine[0].y,otherLine[1].y);
            
            let secondCommonVertexX = 0;
            let secondCommonVertexY = 0;
            
            let otherVertexX = 0;
            let otherVertexY = 0;
            
            if (maxX1 < minX2) {
            secondCommonVertexY = maxY1;
            secondCommonVertexX = floor(splitLine[0].x);
            if(maxY1 == splitLine[0].y) {
                firstCommonVertex = [splitLine[1].x, splitLine[1].y];
                otherIntersection = [splitLine[0].x, splitLine[0].y];
            }
            otherVertexX = secondCommonVertexX;
            otherVertexY = secondCommonVertexY - 1;
            }
            
            if (maxX2 < minX1) {
            secondCommonVertexY = maxY1;
            secondCommonVertexX = ceil(splitLine[0].x);
            if(maxY1 == splitLine[0].y) {
                firstCommonVertex = [splitLine[1].x, splitLine[1].y];
                otherIntersection = [splitLine[0].x, splitLine[0].y];
            }
            otherVertexX = secondCommonVertexX;
            otherVertexY = secondCommonVertexY - 1;
            }
            
            if (maxY1 < minY2) {
            secondCommonVertexX = maxX1;
            secondCommonVertexY = floor(splitLine[0].y);
            if(maxX1 == splitLine[0].x) {
                firstCommonVertex = [splitLine[1].x, splitLine[1].y];
                otherIntersection = [splitLine[0].x, splitLine[0].y];
            }
            otherVertexX = secondCommonVertexX - 1;
            otherVertexY = secondCommonVertexY;
            }
            
            if (maxY2 < minY1) {
            secondCommonVertexX = maxX1;
            secondCommonVertexY = ceil(splitLine[0].y);
            if(maxX1 == splitLine[0].x) {
                firstCommonVertex = [splitLine[1].x, splitLine[1].y];
                otherIntersection = [splitLine[0].x, splitLine[0].y];
            }
            otherVertexX = secondCommonVertexX - 1;
            otherVertexY = secondCommonVertexY;
            }
            
            let secondCommonVertex = [secondCommonVertexX, secondCommonVertexY];
            
            let otherVertex = [otherVertexX, otherVertexY];
            
            let subSubArea1 = calculateArea(
            firstCommonVertex[0], firstCommonVertex[1],
            secondCommonVertex[0], secondCommonVertex[1],
            otherIntersection[0], otherIntersection[1]
            );
            
            let subSubArea2 = calculateArea(
            firstCommonVertex[0], firstCommonVertex[1],
            secondCommonVertex[0], secondCommonVertex[1],
            otherVertex[0], otherVertex[1]
            );
            
            subArea2 = subSubArea1 + subSubArea2;
            
        }
        
        area1 = subArea1 + subArea2;
        area2 = 1-area1;
        
        
        return [area1, area2];
        }
        
        //Check if the splitLine passes by two neighbouring or opposed sides
        let splitLine = [intersection1[0], intersection2[0]];
        
        let splitLine1 = splitLine[0].x == floor(splitLine[0].x) ? "x" : "y";
        let splitLine2 = splitLine[1].x == floor(splitLine[1].x) ? "x" : "y";

        // If they are on the same edge, we just have to calculate the area of a triangle
        if(splitLine1 == splitLine2 &&
            splitLine[0][splitLine1] == splitLine[1][splitLine2]){
            area2 = calculateArea(
            splitLine[0].x, splitLine[0].y,
            splitLine[1].x, splitLine[1].y,
            centerPoint.x, centerPoint.y
            );
            area1 = 1 - area2;
        } else {
            // We have to caculate the area of a trapeze.
            // We can split the trapeze into two triangles, sharing centerPoint and the vertex of the square that is in between the two intersectionpoints
            // Summing these two up we get area1, and area2 will be the rest
            // First we check which splitline shares a coordinate with the first vertex
        
            if( splitLine1 !== splitLine2){
            // In this case we have 2 triangles
            let chosenSquareVertex = {};
            chosenSquareVertex[splitLine1] = splitLine[0][splitLine1];
            chosenSquareVertex[splitLine2] = splitLine[1][splitLine2];
        
            let subArea1 = calculateArea(
                centerPoint.x, centerPoint.y,
                chosenSquareVertex.x, chosenSquareVertex.y,
                splitLine[0].x, splitLine[0].y
            );

            let subArea2 = calculateArea(
                centerPoint.x, centerPoint.y,
                chosenSquareVertex.x, chosenSquareVertex.y,
                splitLine[1].x, splitLine[1].y
            );
            area2 = subArea1 + subArea2;
            } else {
            // In this case we have 3 triangles
            let chosenSquareVertex1 = {};
            let chosenSquareVertex2 = {};
            let otherComponent = splitLine1 == 'x' ? 'y' : 'x';
            
            chosenSquareVertex1[splitLine1] = splitLine[0][splitLine1];
            chosenSquareVertex1[otherComponent] = floor(splitLine[0][otherComponent]);
            
            chosenSquareVertex2[splitLine2] = splitLine[1][splitLine2];
            chosenSquareVertex2[otherComponent] = floor(splitLine[1][otherComponent]);
            
            let subArea1 = calculateArea(
                centerPoint.x, centerPoint.y,
                chosenSquareVertex1.x, chosenSquareVertex1.y,
                splitLine[0].x, splitLine[0].y
            );

            let subArea2 = calculateArea(
                centerPoint.x, centerPoint.y,
                chosenSquareVertex1.x, chosenSquareVertex1.y,
                chosenSquareVertex2.x, chosenSquareVertex2.y
            );
            
            let subArea3 = calculateArea(
                centerPoint.x, centerPoint.y,
                chosenSquareVertex2.x, chosenSquareVertex2.y,
                splitLine[1].x, splitLine[1].y
            );
            
            area2 = subArea1 + subArea2 + subArea3;
            
            // Depending on where the centerpoint is, we will have calculated either inside or outside area, we have to check if we need to correct this or not
            
            if(centerPoint[otherComponent]-floor(centerPoint[otherComponent])<0.5) {
                area2 = 1-area2;
            }
            
            }

            area1 = 1-area2;
        }
        
        return [area1, area2];
        }

        function calculateArea(x1, y1, x2, y2, x3, y3) {
        x1 = round(x1,5);
        y1 = round(y1,5);
        x2 = round(x2,5);
        y2 = round(y2,5);
        x3 = round(x3,5);
        y3 = round(y3,5);
        
        return Math.abs((x1*(y2-y3) + x2*(y3-y1) + x3*(y1-y2)) / 2);
        }

        function calculateSimpleAreas(x,y,intersection1,intersection2,topLeft) {
        let area1 = 1;
        let area2 = 0;
        
        //Check if the splitLine passes by two neighbouring or opposed vertices
        let splitLine = [intersection1, intersection2];
        
        let splitLine1 = splitLine[0].x == floor(splitLine[0].x) ? "x" : "y";
        let splitLine2 = splitLine[1].x == floor(splitLine[1].x) ? "x" : "y";

        // If they are on contiguous edges, we just have to calculate the area of a triangle
        if(splitLine1 != splitLine2){
            let thirdVertex = {};
            thirdVertex[splitLine1] = splitLine[0][splitLine1];
            thirdVertex[splitLine2] = splitLine[1][splitLine2];
        
            area2 = calculateArea(
            splitLine[0].x, splitLine[0].y,
            splitLine[1].x, splitLine[1].y,
            thirdVertex.x, thirdVertex.y
            );
        
            area1 = 1 - area2;

            if(thirdVertex.x == x && thirdVertex.y == y){
            area2 = area1;
            area1 = 1 - area2;
            }
        } else {
            // We have to caculate the area of a trapeze.
            // We can split the trapeze into two triangles, sharing the x,y vertex
            // Summing these two up we get area1, and area2 will be the rest
            // First we check which splitline shares a coordinate with the first vertex
            let contigSplitLine;
            let oppSplitLine;    
            let otherSquareVertex = {};
        
            if(
            (splitLine1 == 'x' && splitLine[0][splitLine1] == x) ||
            (splitLine1 == 'y' && splitLine[0][splitLine1] == y)
            ) {
            contigSplitLine = splitLine[0];
            oppSplitLine = splitLine[1];
            otherSquareVertex[splitLine2] = splitLine[1][splitLine2];
            //this should be floor or ceil depending on whether we are at topleft or topright vertex of the square
            if(splitLine2 == 'x'){
                otherSquareVertex.y = floor(splitLine[1].y);
            } else {
                if(topLeft){
                otherSquareVertex.x = floor(splitLine[1].x);
                } else {
                otherSquareVertex.x = ceil(splitLine[1].x);
                }
            }
            } else {
            contigSplitLine = splitLine[1];
            oppSplitLine = splitLine[0];
            otherSquareVertex[splitLine1] = splitLine[0][splitLine1];
            if(splitLine1 == 'x'){
                otherSquareVertex.y = floor(splitLine[0].y);
            } else {
                if (topLeft) {
                otherSquareVertex.x = floor(splitLine[0].x);
                } else {
                otherSquareVertex.x = ceil(splitLine[0].x);
                }
            }
            }
        
            let subArea1 = calculateArea(
            x, y,
            contigSplitLine.x, contigSplitLine.y,
            oppSplitLine.x, oppSplitLine.y
            );
        
        
            let subArea2 = calculateArea(
            x, y,
            oppSplitLine.x, oppSplitLine.y,
            otherSquareVertex.x,otherSquareVertex.y
            );
        
            area1 = subArea1+subArea2;
        
            area2 = 1-area1;
        }
        
        return [area1, area2];
    }

    function convertToGrayscale(inputColor) {
        // Extracting red, green, and blue components
        let r = red(inputColor);
        let g = green(inputColor);
        let b = blue(inputColor);

        // Calculating the grayscale value (average of RGB components)
        let grayscaleValue = (r + g + b) / 3;

        // Creating a grayscale color using the grayscale value
        let grayscaleColor = color(grayscaleValue);

        return grayscaleColor;
    }


    function antiAliasShapeFill(pixelSet,radius=1) {
        // Create a copy of the original canvasArray
        let tempCanvasArray = JSON.parse(JSON.stringify(canvasArray));
        
        // Create a mask for shape's fill
        let fillMask = Array.from({ length: canvasWidth }, () => Array(canvasHeight).fill(0));
        
        for (let i = 0; i<pixelSet.length; i++){
            let pixel = pixelSet[i];
            let x = pixel.x;
            let y = pixel.y;
            fillMask[x][y] = 1;
        }
        
        // Loop through each pixel in the pixelSet
        for (let i = 0; i<pixelSet.length; i++){
            let pixel = pixelSet[i];
            let x = pixel.x;
            let y = pixel.y;

            if (pixel !== undefined) {
            // Find surrounding pixels within a certain radius
            let surroundingPixels = findSurroundingPixels({ x, y }, tempCanvasArray, radius, 1, fillMask);

            // Calculate the average values for red, green, and blue
            let avgRed = calculateAverageColorComponent(surroundingPixels, 'r');
            let avgGreen = calculateAverageColorComponent(surroundingPixels, 'g');
            let avgBlue = calculateAverageColorComponent(surroundingPixels, 'b');

            // Check distance between avgColor and pixel's original color
            let originalColor = tempCanvasArray[x][y];

            let d = dist(
            originalColor.r,originalColor.g,originalColor.b,
            avgRed,avgGreen,avgBlue
        );
            
            if(d>0.01) {
                // Update the pixel color in canvasArray
                canvasArray[x][y] = {
                r: avgRed,
                g: avgGreen,
                b: avgBlue,
                };
            }
            }
        }
    }

    function getPointOnLineFromY(line,y) {
        let m = (line.y2 - line.y1) / (line.x2 - line.x1);
        
        return {
            x: (y - line.y1) / m + line.x1,
            y: y
        };
    }

    // Function to convert hex to RGB
    function hexToRgb(hex) {
        // Remove the hash symbol if present
        hex = hex.replace(/^#/, '');
        
        // Parse the string into RGB components
        let bigint = parseInt(hex, 16);
        let r = (bigint >> 16) & 255;
        let g = (bigint >> 8) & 255;
        let b = bigint & 255;
        
        return [r, g, b];
    }

    // Function to convert RGB to hex
    function rgbToHex(r, g, b) {
        return "#" + ((1 << 24) + (r << 16) + (g << 8) + b).toString(16).slice(1).toUpperCase();
    }

    // Function to mix two colors
    function mixColors(color1, color2) {
        let rgb1 = hexToRgb(color1);
        let rgb2 = hexToRgb(color2);
        
        // Average the RGB values
        let r = round((rgb1[0] + rgb2[0]) / 2);
        let g = round((rgb1[1] + rgb2[1]) / 2);
        let b = round((rgb1[2] + rgb2[2]) / 2);
        
        // Convert the averaged RGB values back to hex
        return rgbToHex(r, g, b);
    }

    function rotateShape(relativePoints,baseRadius) {
        // Find the centroid of the points
        let points =  relativePoints.map(item => ({
            x: item.x * canvasWidth,
            y: item.y * canvasHeight,
            curvature: item.curvature * maxCurvature,
            percentageDistance: item.percentageDistance,
            radiusIncrease: item.radiusIncrease
        }));

        const centroid = points.reduce((acc, point) => ({ x: acc.x + point.x, y: acc.y + point.y }), { x: 0, y: 0 });
        centroid.x /= points.length;
        centroid.y /= points.length;

        let lastOverflow = 0;
        let borderAngles = [];

        for (let i = 0; i<360;i++){
            let angle = radians(i);

            //We will map the points array to return a 1 if the full shape is inside the canvas or a 0 if it overflows
            let rotationOverflow = points.map(p => {
                // Translate point to origin
                let x = p.x - centroid.x;
                let y = p.y - centroid.y;
                let radiusIncrease = p.radiusIncrease;
                
                // Rotate point
                let xNew = x * cos(angle) - y * sin(angle);
                let yNew = x * sin(angle) + y * cos(angle);
                
                // Translate point back
                xNew += centroid.x;
                yNew += centroid.y;

                let safetyDist = baseRadius * radiusIncrease;

                if (xNew >= safetyDist && 
                    xNew <= canvasWidth - safetyDist &&
                    yNew >= safetyDist &&
                    yNew <= canvasHeight - safetyDist
                ) {
                    return 1;
                }
                
                return 0;
            }).reduce((acc, val) => acc * val, 1);

            if(rotationOverflow != lastOverflow) {
                borderAngles.push(i);
                lastOverflow = lastOverflow ^ 1;
            }
        };

        lastOverflow = 1;

        //We strart this loop in the second position of the array because the first one is always just 0
        for (let j = 1; j<borderAngles.length;j++){

            for (let i = borderAngles[j]-1; i<borderAngles[j];i+=0.005){
                let angle = radians(i);

                //We will map the points array to return a 1 if the full shape is inside the canvas or a 0 if it overflows
                let rotationOverflow = points.map(p => {
                    // Translate point to origin
                    let x = p.x - centroid.x;
                    let y = p.y - centroid.y;
                    let radiusIncrease = p.radiusIncrease;
                    
                    // Rotate point
                    let xNew = x * cos(angle) - y * sin(angle);
                    let yNew = x * sin(angle) + y * cos(angle);
                    
                    // Translate point back
                    xNew += centroid.x;
                    yNew += centroid.y;

                    let safetyDist = baseRadius * radiusIncrease;

                    if (xNew >= safetyDist && 
                        xNew <= canvasWidth - safetyDist &&
                        yNew >= safetyDist &&
                        yNew <= canvasHeight - safetyDist
                    ) {
                        return 1;
                    }
                    
                    return 0;
                }).reduce((acc, val) => acc * val, 1);

                if(rotationOverflow != lastOverflow) {
                    borderAngles[j] = i;
                    lastOverflow = lastOverflow ^ 1;
                    break;
                }
                
            }

        }

        borderAngles.push(360);

        //Now we have an array with the borderangles with sufficient precision (0.005 deg)
        //We now select an angle in an allowed range

        //First we assing a weight to each range
        
        let ranges = [];
        for(i=0;i<borderAngles.length;i+=2){
            ranges.push(borderAngles.slice(i,i+2));
        }

        let totalLength = 0;
        let weights = ranges.map(range => {
            let length = (range[1] - range[0] + 1);
            totalLength += length;
            return length;
        });

        let probabilities = weights.map(weight => weight / totalLength);

        let randomValue = random();

        let accumulatedProbability = 0;
        let selectedRangeIndex = -1;
        for (let i = 0; i < probabilities.length; i++) {
            accumulatedProbability += probabilities[i];
            if (randomValue <= accumulatedProbability) {
            selectedRangeIndex = i;
            break;
            }
        }

        let selectedRange = ranges[selectedRangeIndex];
        let rotationAngle = random(selectedRange[0], selectedRange[1]);

        let rotatedPoints = relativePoints.map(p => {
            // Translate point to origin
            // Preserve other properties while rotating x and y
            let { x, y, ...rest } = p;

            let translatedX = x*canvasWidth - centroid.x;
            let translatedY = y*canvasHeight - centroid.y;
            let angle = radians(rotationAngle);
            
            // Rotate point
            let xNew = translatedX * cos(angle) - translatedY * sin(angle);
            let yNew = translatedX * sin(angle) + translatedY * cos(angle);
            
            // Translate point back
            xNew += centroid.x;
            yNew += centroid.y;
            
            return { 
                x: xNew/canvasWidth, 
                y: yNew/canvasHeight,
                ...rest 
            };
        });

        //Lastly, we also need to rotate circles and lines around the centroid
        for (let i=0; i<setupVariables.circles.length;i++) {
            let {centerX, centerY} = setupVariables.circles[i];

            let translatedX = centerX*canvasWidth - centroid.x;
            let translatedY = centerY*canvasHeight - centroid.y;
            let angle = radians(rotationAngle);
            
            // Rotate point
            let xNew = translatedX * cos(angle) - translatedY * sin(angle);
            let yNew = translatedX * sin(angle) + translatedY * cos(angle);
            
            // Translate point back
            xNew += centroid.x;
            yNew += centroid.y;

            setupVariables.circles[i].centerX = xNew/canvasWidth;
            setupVariables.circles[i].centerY = yNew/canvasHeight;
        }

        for (let i=0; i<setupVariables.lines.length;i++) {
            let {centerX, centerY} = setupVariables.lines[i];

            let translatedX = centerX*canvasWidth - centroid.x;
            let translatedY = centerY*canvasHeight - centroid.y;
            let angle = radians(rotationAngle);
            
            // Rotate point
            let xNew = translatedX * cos(angle) - translatedY * sin(angle);
            let yNew = translatedX * sin(angle) + translatedY * cos(angle);
            
            // Translate point back
            xNew += centroid.x;
            yNew += centroid.y;

            setupVariables.lines[i].centerX = xNew/canvasWidth;
            setupVariables.lines[i].centerY = yNew/canvasHeight;
            setupVariables.lines[i].angle = (setupVariables.lines[i].angle + angle)%(2*PI);
        }

        return rotatedPoints;
    }

    function findMinDistanceToBoundary(x1, y1, x2, y2, canvasWidth, canvasHeight) {
        let distances = [];
        
        // Intersection with x = 0
        if (x2 - x1 !== 0) {
            let t = -x1 / (x2 - x1);
            let yInt = y1 + t * (y2 - y1);
            if (yInt >= 0 && yInt <= canvasHeight) {
                distances.push(dist(x1, y1, 0, yInt));
            }
        }

        // Intersection with y = 0
        if (y2 - y1 !== 0) {
            let t = -y1 / (y2 - y1);
            let xInt = x1 + t * (x2 - x1);
            if (xInt >= 0 && xInt <= canvasWidth) {
                distances.push(dist(x1, y1, xInt, 0));
            }
        }

        // Intersection with x = canvasWidth
        if (x2 - x1 !== 0) {
            let t = (canvasWidth - x1) / (x2 - x1);
            let yInt = y1 + t * (y2 - y1);
            if (yInt >= 0 && yInt <= canvasHeight) {
                distances.push(dist(x1, y1, canvasWidth, yInt));
            }
        }

        // Intersection with y = canvasHeight
        if (y2 - y1 !== 0) {
            let t = (canvasHeight - y1) / (y2 - y1);
            let xInt = x1 + t * (x2 - x1);
            if (xInt >= 0 && xInt <= canvasWidth) {
                distances.push(dist(x1, y1, xInt, canvasHeight));
            }
        }

        // Return the minimum distance found
        return Math.min(...distances);
        }

        function movePointAlongLine(x1, y1, x2, y2, distance, i,canvasWidth, canvasHeight,direction,shape="none") {
            // Calculate the direction vector
            let dx = x1 - x2;
            let dy = y1 - y2;
            
            // Calculate the length of the line
            let length = Math.sqrt(dx*dx+dy*dy);
            
            // Normalize the direction vector
            let ux = dx / length;
            let uy = dy / length;
            
            // Calculate the new point after moving a certain distance
            let xNew = x1 + direction * distance * ux;
            let yNew = y1 + direction * distance * uy;
            
            if(shape == "circle") {
                setupVariables.circles[i].centerX = xNew/canvasWidth;
                setupVariables.circles[i].centerY = yNew/canvasHeight;
            } else if(shape == "line") {
                setupVariables.lines[i].centerX = xNew/canvasWidth;
                setupVariables.lines[i].centerY = yNew/canvasHeight;
            }else{
                setupVariables.seedpoints[i].x = xNew/canvasWidth;
                setupVariables.seedpoints[i].y = yNew/canvasHeight;
            }
        }

        function getOriginalValues(original, modified) {
            let differences = {};

            for (let key in original) {
                if (modified.hasOwnProperty(key)) {
                if (Array.isArray(original[key]) && Array.isArray(modified[key])) {
                    if (JSON.stringify(original[key]) !== JSON.stringify(modified[key])) {
                        differences[key] = original[key];
                    }
                } else if (typeof original[key] === 'object' && typeof modified[key] === 'object') {
                    const nestedDifferences = getOriginalValues(original[key], modified[key]);
                    if (Object.keys(nestedDifferences).length > 0) {
                        differences[key] = nestedDifferences;
                    }
                } else if (original[key] !== modified[key]) {
                    differences[key] = original[key];
                }
                } else {
                    differences[key] = original[key]; // Property was deleted in modified
                }
            }

            // Check for new properties in modified
            for (let key in modified) {
                if (!original.hasOwnProperty(key)) {
                differences[key] = null; // New property
                }
            }

            return differences;
        }

        function reconstructOriginal(modified, differences) {
            let original = JSON.parse(JSON.stringify(modified)); // Deep copy of modified object

            function applyDifferences(obj, diff) {
                for (let key in diff) {
                    if (Array.isArray(diff[key])) {
                        obj[key] = diff[key]; // Replace the entire array
                    } else if (typeof diff[key] === 'object' && diff[key] !== null && typeof obj[key] === 'object') {
                        applyDifferences(obj[key], diff[key]);
                    } else if (diff[key] !== null) {
                        obj[key] = diff[key];
                    } else {
                        delete obj[key];
                    }
                }
                // Add back properties that were in the original but not in modified
                for (let key in diff) {
                    if (!obj.hasOwnProperty(key) && diff[key] !== null) {
                        obj[key] = diff[key];
                    }
                }
            }

            applyDifferences(original, differences);
            return original;
        }

  </script>
</body>
</html>
