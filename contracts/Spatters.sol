// SPDX-License-Identifier: MIT
pragma solidity ^0.8.20;

import "@openzeppelin/contracts/token/ERC721/ERC721.sol";
import "@openzeppelin/contracts/access/Ownable.sol";
import "@openzeppelin/contracts/utils/ReentrancyGuard.sol";
import "@openzeppelin/contracts/utils/Strings.sol";
import "@openzeppelin/contracts/utils/Base64.sol";
import "./ExponentialPricing.sol";
import "./MetadataParser.sol";
import "./DateTime.sol";

/**
 * @title Spatters
 * @dev Fully on-chain dynamic NFT collection with time-based mutations
 * 999 total supply with exponential pricing and anti-whale protection
 */
contract Spatters is ERC721, Ownable, ReentrancyGuard {
    using Strings for uint256;

    // ============ State Variables ============

    uint256 public constant MAX_SUPPLY = 999;
    uint256 public constant OWNER_RESERVE = 25;
    uint256 public constant MAX_METADATA_LENGTH = 10000; // 10KB limit
    
    // Anti-whale protection
    uint256 public constant MAX_PER_TRANSACTION = 2;
    uint256 public constant MAX_PER_WALLET = 10;
    uint256 public constant COOLDOWN_PERIOD = 1 hours;
    
    // Token state
    struct TokenData {
        string currentMetadata;      // Current JSON metadata (~3-4KB)
        uint256 mintTimestamp;       // When token was minted
        uint256 mutationCount;       // Number of mutations
        uint256 lastMutationDate;    // Timestamp of last mutation (for cooldown)
    }
    
    mapping(uint256 => TokenData) public tokens;
    uint256 private _nextTokenId = 1;
    uint256 public collectionLaunchDate;  // Set when token #1 is minted
    
    // Anti-whale tracking
    mapping(address => uint256) public mintedPerWallet;
    mapping(address => uint256) public lastMintTime;
    
    // ============ Events ============
    
    event Minted(
        uint256 indexed tokenId,
        address indexed minter,
        string initialMetadata,
        bytes32 seed
    );
    
    event Mutated(
        uint256 indexed tokenId,
        uint256 indexed mutationIndex,
        string mutationType,
        string fullMetadata,      // Complete state snapshot for history
        bytes32 seed,
        uint256 timestamp
    );
    
    // ============ Constructor ============
    
    constructor() ERC721("Spatters", "SPAT") Ownable(msg.sender) {}
    
    // ============ Minting Functions ============
    
    /**
     * @dev Owner mint for first 25 tokens (free)
     * @param to Address to mint to
     * @param metadata Optional JSON metadata (if empty, generated by client)
     */
    function ownerMint(address to, string memory metadata) external onlyOwner nonReentrant {
        require(_nextTokenId <= OWNER_RESERVE, "Owner mint period ended");
        require(bytes(metadata).length <= MAX_METADATA_LENGTH, "Metadata too large");
        
        uint256 tokenId = _nextTokenId++;
        
        // Set collection launch date on first mint
        if (tokenId == 1) {
            collectionLaunchDate = block.timestamp;
        }
        
        // Store metadata
        tokens[tokenId].currentMetadata = metadata;
        tokens[tokenId].mintTimestamp = block.timestamp;
        tokens[tokenId].mutationCount = 0;
        tokens[tokenId].lastMutationDate = 0;
        
        // Mint token
        _safeMint(to, tokenId);
        
        // Generate seed for event
        bytes32 seed = keccak256(abi.encodePacked(to, uint256(0), block.timestamp, tokenId));
        
        emit Minted(tokenId, to, metadata, seed);
    }
    
    /**
     * @dev Public mint for tokens 26-999 with anti-whale protection
     * @param metadata JSON metadata generated by client
     */
    function mint(string memory metadata) external payable nonReentrant {
        require(_nextTokenId > OWNER_RESERVE, "Public mint not started");
        require(_nextTokenId <= MAX_SUPPLY, "Max supply reached");
        require(msg.value >= getMintPrice(), "Insufficient payment");
        require(bytes(metadata).length <= MAX_METADATA_LENGTH, "Metadata too large");
        
        // Anti-whale checks
        require(mintedPerWallet[msg.sender] < MAX_PER_WALLET, "Max per wallet reached");
        require(
            block.timestamp >= lastMintTime[msg.sender] + COOLDOWN_PERIOD,
            "Cooldown active"
        );
        
        uint256 tokenId = _nextTokenId++;
        
        // Update anti-whale tracking
        mintedPerWallet[msg.sender]++;
        lastMintTime[msg.sender] = block.timestamp;
        
        // Store metadata
        tokens[tokenId].currentMetadata = metadata;
        tokens[tokenId].mintTimestamp = block.timestamp;
        tokens[tokenId].mutationCount = 0;
        tokens[tokenId].lastMutationDate = 0;
        
        // Mint token
        _safeMint(msg.sender, tokenId);
        
        // Generate seed
        bytes32 seed = keccak256(abi.encodePacked(msg.sender, uint256(0), block.timestamp, tokenId));
        
        emit Minted(tokenId, msg.sender, metadata, seed);
        
        // Refund excess payment
        if (msg.value > getMintPrice()) {
            (bool success, ) = payable(msg.sender).call{value: msg.value - getMintPrice()}("");
            require(success, "Refund failed");
        }
    }
    
    /**
     * @dev Calculate exponential mint price
     * Formula: price = 0.00618 * ((100/0.00618)^((n-25)/(999-25))) ETH
     */
    function getMintPrice() public view returns (uint256) {
        return ExponentialPricing.calculatePrice(_nextTokenId);
    }
    
    // ============ Mutation Functions ============
    
    /**
     * @dev Mutate an NFT (only owner can mutate, only on eligible dates)
     * @param tokenId Token to mutate
     * @param mutationType Type of mutation (e.g., "paletteChange")
     * @param newMetadata New JSON metadata after mutation
     */
    function mutate(
        uint256 tokenId,
        string memory mutationType,
        string memory newMetadata
    ) external nonReentrant {
        require(ownerOf(tokenId) == msg.sender, "Not token owner");
        require(bytes(newMetadata).length <= MAX_METADATA_LENGTH, "Metadata too large");
        require(canMutate(tokenId), "Cannot mutate now");
        
        // Prevent same-day mutations
        uint256 currentDate = block.timestamp / 1 days;
        require(tokens[tokenId].lastMutationDate != currentDate, "Already mutated today");
        
        // Update token data
        tokens[tokenId].currentMetadata = newMetadata;
        tokens[tokenId].mutationCount++;
        tokens[tokenId].lastMutationDate = currentDate;
        
        // Generate seed for this mutation
        bytes32 seed = keccak256(
            abi.encodePacked(
                msg.sender,
                tokens[tokenId].mutationCount,
                block.timestamp,
                tokenId
            )
        );
        
        emit Mutated(
            tokenId,
            tokens[tokenId].mutationCount,
            mutationType,
            newMetadata,
            seed,
            block.timestamp
        );
    }
    
    /**
     * @dev Check if a token can mutate based on time-based rules
     * Returns true if ANY of the 4 eligibility conditions are met:
     * 1. Individual anniversary (token's mint date anniversary)
     * 2. Collection anniversary (collection launch date anniversary)
     * 3. Month eligibility (based on circles and lines count)
     * 4. Quarter-end eligibility (based on unique colors count)
     */
    function canMutate(uint256 tokenId) public view returns (bool) {
        require(_ownerOf(tokenId) != address(0), "Token does not exist");
        
        TokenData memory tokenData = tokens[tokenId];
        
        // Prevent same-day mutations
        uint256 currentDate = block.timestamp / 1 days;
        if (tokenData.lastMutationDate == currentDate) {
            return false;
        }
        
        // Parse metadata to extract eligibility parameters
        (uint256 circles, uint256 lines, uint256 uniqueColors) = 
            MetadataParser.parseMetadata(tokenData.currentMetadata);
        
        // Check 1: Individual Anniversary (token's mint date anniversary)
        if (DateTime.isSameMonthAndDay(tokenData.mintTimestamp, block.timestamp)) {
            return true;
        }
        
        // Check 2: Collection Anniversary (collection launch date anniversary)
        if (collectionLaunchDate > 0 && 
            DateTime.isSameMonthAndDay(collectionLaunchDate, block.timestamp)) {
            return true;
        }
        
        // Check 3: Month Eligibility (based on circles and lines)
        // Formula: month = (circles * 3) + lines
        // Can mutate on the 1st day of the calculated month
        uint256 eligibilityMonth = MetadataParser.calculateEligibilityMonth(circles, lines);
        if (DateTime.isMonthAndDay(block.timestamp, eligibilityMonth, 1)) {
            return true;
        }
        
        // Check 4: Quarter-End Eligibility (based on unique colors)
        (uint256 quarterMonth, uint256 quarterDay) = 
            MetadataParser.getQuarterEndDate(uniqueColors);
        if (quarterMonth > 0 && DateTime.isMonthAndDay(block.timestamp, quarterMonth, quarterDay)) {
            return true;
        }
        
        return false;
    }
    
    // ============ View Functions ============
    
    /**
     * @dev Get token metadata
     */
    function getTokenMetadata(uint256 tokenId) external view returns (string memory) {
        require(_ownerOf(tokenId) != address(0), "Token does not exist");
        return tokens[tokenId].currentMetadata;
    }
    
    /**
     * @dev Returns token URI with base64-encoded JSON
     */
    function tokenURI(uint256 tokenId) public view override returns (string memory) {
        require(_ownerOf(tokenId) != address(0), "Token does not exist");
        
        string memory json = string(
            abi.encodePacked(
                '{"name": "Spatters #',
                tokenId.toString(),
                '", "description": "A fully on-chain dynamic NFT with time-based mutations", "metadata": ',
                tokens[tokenId].currentMetadata,
                '}'
            )
        );
        
        return string(
            abi.encodePacked(
                "data:application/json;base64,",
                Base64.encode(bytes(json))
            )
        );
    }
    
    /**
     * @dev Get total supply
     */
    function totalSupply() public view returns (uint256) {
        return _nextTokenId - 1;
    }
    
    // ============ Owner Functions ============
    
    /**
     * @dev Withdraw contract balance
     */
    function withdraw() external onlyOwner nonReentrant {
        uint256 balance = address(this).balance;
        require(balance > 0, "No balance to withdraw");
        
        (bool success, ) = payable(owner()).call{value: balance}("");
        require(success, "Transfer failed");
    }
    
    /**
     * @dev Get contract balance
     */
    function getContractBalance() external view returns (uint256) {
        return address(this).balance;
    }
}

