<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8">
<meta name="viewport" content="width=device-width, initial-scale=1.0">
<title>Spatters #{{TOKEN_ID}}</title>
</head>
<body>
<script>
const CONFIG = {
  sepoliaRpc: "{{SEPOLIA_RPC}}",
  mainnetRpc: "{{MAINNET_RPC}}",
  tokenId: {{TOKEN_ID}},
  generatorContract: "{{GENERATOR_CONTRACT}}",
  spattersContract: "{{SPATTERS_CONTRACT}}",
  storageAddresses: {{STORAGE_ADDRESSES}},
  artBlocksRegistry: "0x37861f95882ACDba2cCD84F5bFc4598e2ECDDdAF",
  p5DependencyBytes32: "0x703540312e302e30000000000000000000000000000000000000000000000000",
  p5ChunkCount: 10
};

async function ethCall(rpcUrl, to, data) {
  const response = await fetch(rpcUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      method: 'eth_call',
      params: [{ to, data }, 'latest'],
      id: Date.now()
    })
  });
  const json = await response.json();
  if (json.error) throw new Error(json.error.message);
  return json.result;
}

async function getBytecode(rpcUrl, address) {
  const response = await fetch(rpcUrl, {
    method: 'POST',
    headers: { 'Content-Type': 'application/json' },
    body: JSON.stringify({
      jsonrpc: '2.0',
      method: 'eth_getCode',
      params: [address, 'latest'],
      id: Date.now()
    })
  });
  const json = await response.json();
  if (json.error) throw new Error(json.error.message);
  return json.result;
}

function hexToString(hex) {
  if (!hex || hex === '0x') return '';
  if (hex.startsWith('0x')) hex = hex.slice(2);
  let str = '';
  for (let i = 0; i < hex.length; i += 2) {
    const code = parseInt(hex.substr(i, 2), 16);
    if (code === 0) continue;
    str += String.fromCharCode(code);
  }
  return str;
}

function encodeUint256(num) {
  return num.toString(16).padStart(64, '0');
}

function decodeAbiString(hex) {
  if (hex.startsWith('0x')) hex = hex.slice(2);
  const offset = parseInt(hex.slice(0, 64), 16) * 2;
  const length = parseInt(hex.slice(offset, offset + 64), 16);
  const data = hex.slice(offset + 64, offset + 64 + length * 2);
  return hexToString('0x' + data);
}

async function decompressGzip(compressedData) {
  const ds = new DecompressionStream('gzip');
  const blob = new Blob([compressedData]);
  const decompressedStream = blob.stream().pipeThrough(ds);
  return await new Response(decompressedStream).text();
}

const GET_DEPENDENCY_SCRIPT_SELECTOR = '0x518cb3df';

async function loadP5jsFromArtBlocks() {
  const chunks = [];
  for (let i = 0; i < CONFIG.p5ChunkCount; i++) {
    const indexHex = encodeUint256(i);
    const callData = GET_DEPENDENCY_SCRIPT_SELECTOR + CONFIG.p5DependencyBytes32.slice(2) + indexHex;
    const result = await ethCall(CONFIG.mainnetRpc, CONFIG.artBlocksRegistry, callData);
    chunks.push(decodeAbiString(result));
  }
  const compressedBase64 = chunks.join('');
  const compressedBinary = atob(compressedBase64);
  const compressedArray = new Uint8Array(compressedBinary.length);
  for (let i = 0; i < compressedBinary.length; i++) {
    compressedArray[i] = compressedBinary.charCodeAt(i);
  }
  return await decompressGzip(compressedArray);
}

async function getTokenData(tokenId) {
  const selector = '0xb09afec1';
  const data = selector + encodeUint256(tokenId);
  const result = await ethCall(CONFIG.sepoliaRpc, CONFIG.generatorContract, data);
  const hex = result.slice(2);
  const seed = '0x' + hex.slice(0, 64);
  const mutationSeedsOffset = parseInt(hex.slice(64, 128), 16) * 2;
  const mutationTypesOffset = parseInt(hex.slice(128, 192), 16) * 2;
  const paletteOffset = parseInt(hex.slice(192, 256), 16) * 2;
  const mutationSeedsLength = parseInt(hex.slice(mutationSeedsOffset, mutationSeedsOffset + 64), 16);
  const mutationSeeds = [];
  for (let i = 0; i < mutationSeedsLength; i++) {
    const pos = mutationSeedsOffset + 64 + (i * 64);
    mutationSeeds.push('0x' + hex.slice(pos, pos + 64));
  }
  const mutationTypesLength = parseInt(hex.slice(mutationTypesOffset, mutationTypesOffset + 64), 16);
  const mutationTypes = [];
  for (let i = 0; i < mutationTypesLength; i++) {
    const offsetPos = mutationTypesOffset + 64 + (i * 64);
    const strOffset = parseInt(hex.slice(offsetPos, offsetPos + 64), 16) * 2;
    const absOffset = mutationTypesOffset + 64 + strOffset;
    const strLength = parseInt(hex.slice(absOffset, absOffset + 64), 16);
    const strData = hex.slice(absOffset + 64, absOffset + 64 + strLength * 2);
    mutationTypes.push(hexToString(strData));
  }
  const customPalette = [];
  for (let i = 0; i < 6; i++) {
    const offsetPos = paletteOffset + (i * 64);
    const strOffset = parseInt(hex.slice(offsetPos, offsetPos + 64), 16) * 2;
    const absOffset = paletteOffset + strOffset;
    const strLength = parseInt(hex.slice(absOffset, absOffset + 64), 16);
    if (strLength > 0) {
      const strData = hex.slice(absOffset + 64, absOffset + 64 + strLength * 2);
      customPalette.push(hexToString(strData));
    } else {
      customPalette.push('');
    }
  }
  return { seed, mutationSeeds, mutationTypes, customPalette };
}

async function loadSpattersJs() {
  const chunks = await Promise.all(
    CONFIG.storageAddresses.map(async (addr) => {
      const bytecode = await getBytecode(CONFIG.sepoliaRpc, addr);
      return hexToString(bytecode);
    })
  );
  return chunks.join('');
}

function hexToSeed(hexString) {
  const truncated = hexString.slice(0, 18);
  return parseInt(truncated, 16);
}

async function loadFromBlockchain() {
  const spattersJs = await loadSpattersJs();
  const tokenData = await getTokenData(CONFIG.tokenId);
  const mintingSeed = hexToSeed(tokenData.seed);
  const mutations = tokenData.mutationSeeds.map((seed, i) => [hexToSeed(seed), tokenData.mutationTypes[i]]);
  const customPalette = tokenData.customPalette.filter(c => c && c.length > 0);
  eval(spattersJs);
  window.setup = function() {
    generate(mintingSeed, mutations, customPalette.length > 0 ? customPalette : []);
  };
  const p5jsCode = await loadP5jsFromArtBlocks();
  eval(p5jsCode);
}

window.onload = loadFromBlockchain;
</script>
</body>
</html>
